<!DOCTYPE html>
<html lang="th">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ตรวจสอบการนับผ่านระบบ SMCO ของสาขา - SPVi Operations Audit</title>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-auth-compat.js"></script>
    
    <!-- Configuration Manager -->
    <script src="../config.js"></script>
    
    <!-- Session Manager -->
    <script src="../session-manager.js"></script>
    
    <!-- Firebase Auth System -->
    <script src="../firebase-auth.js"></script>
    
    <!-- Main Stylesheet -->
    <link rel="stylesheet" href="../styles/spvi-main.css">
    <link rel="stylesheet" href="../styles/print-header.css">
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        body { font-family: 'Sarabun', sans-serif; }
        
        /* Upload sections */
        .upload-section {
            border: 2px dashed #cbd5e1;
            border-radius: 0.75rem;
            padding: 2rem;
            text-align: center;
            margin-bottom: 2rem;
            transition: all 0.3s ease;
        }

        .upload-section:hover {
            border-color: #3b82f6;
            background-color: #f8fafc;
        }

        .upload-section.dragover {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }

        .file-input {
            display: none;
        }

        .upload-btn {
            background: #3b82f6;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            cursor: pointer;
            font-family: 'Sarabun', sans-serif;
            font-weight: 500;
            transition: background 0.3s ease;
        }

        .upload-btn:hover {
            background: #2563eb;
        }

        .file-info {
            margin-top: 1rem;
            padding: 1rem;
            background: #f0fdf4;
            border: 1px solid #bbf7d0;
            border-radius: 0.5rem;
            display: none;
        }

        /* Status and processing */
        .processing-status {
            text-align: center;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0.5rem;
            display: none;
        }

        .processing-status.processing {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            color: #92400e;
        }

        .processing-status.success {
            background: #d1fae5;
            border: 1px solid #10b981;
            color: #065f46;
        }

        .processing-status.error {
            background: #fee2e2;
            border: 1px solid #ef4444;
            color: #991b1b;
        }

        /* Tables */
        .data-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 1rem;
            font-size: 0.9rem;
            background: white;
        }

        .data-table th,
        .data-table td {
            padding: 0.75rem;
            text-align: left;
            border-bottom: 1px solid #e2e8f0;
        }

        .data-table th {
            background: #f8fafc;
            font-weight: 600;
            color: #374151;
            position: sticky;
            top: 0;
        }

        .data-table tbody tr:hover {
            background: #f8fafc;
        }

        /* Results sections */
        .results-section {
            display: none;
        }

        .group-section {
            margin-bottom: 2rem;
            border: 1px solid #e2e8f0;
            border-radius: 0.75rem;
            overflow: hidden;
        }

        .group-header {
            background: #f8fafc;
            padding: 1rem 1.5rem;
            border-bottom: 1px solid #e2e8f0;
            font-weight: 700;
            font-size: 1.1rem;
            color: #1e293b;
        }

        .group-content {
            padding: 1.5rem;
        }

        /* Summary stats */
        .summary-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 2rem;
        }

        .stat-card {
            background: #f8fafc;
            padding: 1rem;
            border-radius: 0.5rem;
            border: 1px solid #e2e8f0;
            text-align: center;
        }

        .stat-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: #3b82f6;
        }

        .stat-label {
            font-size: 0.875rem;
            color: #6b7280;
            margin-top: 0.25rem;
        }

        /* Missing branches */
        .missing-branches-section {
            background: #fef3c7;
            border: 1px solid #f59e0b;
            border-radius: 0.5rem;
            padding: 1rem;
            margin-bottom: 1.5rem;
        }

        .missing-branches-title {
            color: #92400e;
            font-size: 1rem;
            font-weight: 600;
            margin: 0 0 0.75rem 0;
        }

        .missing-branches-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .missing-branch-tag {
            background: #fed7aa;
            color: #9a3412;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.875rem;
            font-weight: 500;
            border: 1px solid #fdba74;
        }

        /* Row highlighting */
        .data-table tbody tr.diff-row {
            background-color: #fef2f2 !important;
            border-left: 4px solid #ef4444;
        }

        .data-table tbody tr.diff-row:hover {
            background-color: #fee2e2 !important;
        }

        .data-table tbody tr.match-row {
            background-color: #f0fdf4 !important;
            border-left: 4px solid #22c55e;
        }

        .data-table tbody tr.match-row:hover {
            background-color: #dcfce7 !important;
        }

        .data-table tbody tr.soh-updated {
            background-color: #f0f9ff !important;
            border-left: 4px solid #0ea5e9;
        }

        .data-table tbody tr.soh-updated:hover {
            background-color: #e0f2fe !important;
        }

        .data-table .clickable-doc {
            color: #2563eb;
            cursor: pointer;
            text-decoration: underline;
        }

        .data-table .clickable-doc:hover {
            color: #1d4ed8;
            font-weight: 600;
        }

        /* Detail file uploads */
        .detail-upload-section {
            margin-top: 1rem;
            padding: 1rem;
            background: #f8fafc;
            border: 1px solid #e2e8f0;
            border-radius: 0.5rem;
        }

        .detail-upload-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: #374151;
            margin-bottom: 0.5rem;
        }

        .detail-upload-area {
            border: 2px dashed #cbd5e1;
            border-radius: 0.5rem;
            padding: 1rem;
            text-align: center;
            transition: all 0.3s ease;
        }

        .detail-upload-area:hover {
            border-color: #3b82f6;
            background-color: #f8fafc;
        }

        .detail-upload-area.dragover {
            border-color: #3b82f6;
            background-color: #eff6ff;
        }

        .detail-upload-btn {
            background: #4f46e5;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            cursor: pointer;
            font-family: 'Sarabun', sans-serif;
            font-weight: 500;
            transition: background 0.3s ease;
        }

        .detail-upload-btn:hover {
            background: #4338ca;
        }

        .uploaded-files-list {
            margin-top: 0.5rem;
        }

        .uploaded-file-item {
            display: flex;
            justify-content: between;
            align-items: center;
            padding: 0.5rem;
            background: white;
            border: 1px solid #e2e8f0;
            border-radius: 0.375rem;
            margin-bottom: 0.25rem;
            font-size: 0.875rem;
        }

        .uploaded-file-name {
            flex: 1;
            color: #374151;
        }

        .uploaded-file-status {
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-size: 0.75rem;
            font-weight: 500;
        }

        .status-processing {
            background: #fef3c7;
            color: #92400e;
        }

        .status-success {
            background: #d1fae5;
            color: #065f46;
        }

        .status-error {
            background: #fee2e2;
            color: #991b1b;
        }

        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal-content {
            background: white;
            border-radius: 0.75rem;
            padding: 1.5rem;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
            box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid #e2e8f0;
        }

        .modal-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: #1e293b;
        }

        .modal-close {
            background: #6b7280;
            color: white;
            border: none;
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            cursor: pointer;
            font-family: 'Sarabun', sans-serif;
        }

        .modal-close:hover {
            background: #4b5563;
        }

        /* Export section */
        .export-section {
            margin-top: 2rem;
            text-align: center;
        }

        .export-btn {
            background: #10b981;
            color: white;
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            cursor: pointer;
            font-family: 'Sarabun', sans-serif;
            font-weight: 500;
            margin: 0 0.5rem;
            transition: background 0.3s ease;
        }

        .export-btn:hover {
            background: #059669;
        }

        .no-data {
            text-align: center;
            padding: 2rem;
            color: #6b7280;
            font-style: italic;
        }

        /* Progress Bar Styles */
        .progress-container {
            margin: 1rem 0;
        }

        .progress-bar {
            width: 100%;
            height: 20px;
            background-color: #e5e7eb;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #3b82f6, #1d4ed8);
            border-radius: 10px;
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-text {
            text-align: center;
            font-size: 0.75rem;
            font-weight: 600;
            color: #374151;
            margin-top: 0.25rem;
        }

        /* SOH Statistics */
        .soh-stats {
            display: flex;
            gap: 1rem;
            margin: 1rem 0;
            flex-wrap: wrap;
        }

        .soh-stat-item {
            background: #f0f9ff;
            border: 1px solid #bae6fd;
            border-radius: 0.5rem;
            padding: 0.75rem;
            text-align: center;
            min-width: 120px;
            flex: 1;
        }

        .soh-stat-number {
            font-size: 1.5rem;
            font-weight: 700;
            color: #0369a1;
            margin-bottom: 0.25rem;
        }

        .soh-stat-label {
            font-size: 0.75rem;
            color: #374151;
            font-weight: 500;
        }

        /* Loading animation for SOH upload button */
        .upload-btn.loading {
            background: #9ca3af;
            cursor: not-allowed;
        }

        .upload-btn.loading:before {
            content: "⟳ ";
            animation: spin 1s linear infinite;
            display: inline-block;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Sortable Table Styles */
        .sortable-table th.sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 20px;
        }

        .sortable-table th.sortable:hover {
            background-color: #e2e8f0;
        }

        .sort-icon {
            position: absolute;
            right: 5px;
            font-size: 0.8rem;
            color: #9ca3af;
        }

        .sort-icon.asc::after {
            content: '↑';
            color: #3b82f6;
        }

        .sort-icon.desc::after {
            content: '↓';
            color: #3b82f6;
        }

        /* Branch Status Table */
        .branch-status-section {
            margin-bottom: 2rem;
        }

        .branch-status-title {
            font-size: 1.25rem;
            font-weight: 700;
            color: #1e293b;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-pass {
            color: #065f46;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-weight: 600;
            font-size: 0.75rem;
        }

        .status-fail {
            color: #991b1b;
            padding: 0.25rem 0.5rem;
            border-radius: 0.25rem;
            font-weight: 600;
            font-size: 0.75rem;
        }

        /* Tab Navigation Styles */
        .tab-navigation {
            display: flex;
            border-bottom: 2px solid #e2e8f0;
            margin-bottom: 2rem;
            background: #f8fafc;
            border-radius: 0.5rem 0.5rem 0 0;
            overflow: hidden;
        }

        .tab-button {
            flex: 1;
            padding: 1rem 1.5rem;
            background: #f8fafc;
            border: none;
            cursor: pointer;
            font-family: 'Sarabun', sans-serif;
            font-weight: 600;
            font-size: 1rem;
            color: #64748b;
            transition: all 0.3s ease;
            border-bottom: 3px solid transparent;
            position: relative;
        }

        .tab-button:hover {
            background: #f1f5f9;
            color: #475569;
        }

        .tab-button.active {
            background: white;
            color: #3b82f6;
            border-bottom-color: #3b82f6;
        }

        .tab-button.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 3px;
            background: #3b82f6;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .tab-icon {
            margin-right: 0.5rem;
            font-size: 1.1rem;
        }
    </style>
</head>
<body class="min-h-screen bg-gradient-to-br from-blue-50 via-white to-blue-50">
    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="fixed inset-0 bg-gray-900 bg-opacity-50 backdrop-blur-sm flex items-center justify-center z-50">
        <div class="bg-white rounded-xl p-8 shadow-2xl max-w-sm mx-4">
            <div class="flex flex-col items-center">
                <div class="animate-spin rounded-full h-16 w-16 border-4 border-blue-200 border-t-blue-600 mb-4"></div>
                <h3 class="text-lg font-semibold text-gray-900 mb-2">กำลังเตรียมข้อมูล</h3>
                <p class="text-gray-600 text-center">กรุณารอสักครู่...</p>
            </div>
        </div>
    </div>



    <!-- Main Content -->
    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
        <!-- Header -->
        <header class="mb-6 md:mb-8 text-center relative no-print mt-2 md:mt-4">
            <h1 class="text-2xl md:text-4xl font-bold text-slate-900 mb-1 md:mb-2">SMCO Check</h1>
            <p class="text-slate-500 text-sm md:text-base text-center">ตรวจสอบและวิเคราะห์การควบคุมการจัดการสินค้าคงคลังของสาขา</p>
        </header>

        <div class="bg-white rounded-xl shadow-sm border border-gray-200 overflow-hidden">
            <!-- Content -->
            <div class="p-6">
            <!-- Upload Section -->
            <div class="border-2 border-dashed border-gray-300 rounded-xl p-8 text-center mb-6 transition-all duration-300 hover:border-blue-400 hover:bg-blue-50" id="uploadSection">
                <h3 class="text-lg font-semibold text-gray-900 mb-2"> 1.อัพโหลดไฟล์ SMCO Data</h3>
                <p class="text-gray-600 mb-4">กรุณาเลือกไฟล์ .xlsx ที่มีข้อมูล SMCO Check</p>
                <input type="file" id="fileInput" class="hidden" accept=".xlsx,.xls" />
                <button class="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium" onclick="document.getElementById('fileInput').click()">
                    เลือกไฟล์
                </button>
                <div class="mt-4 p-4 bg-green-50 border border-green-200 rounded-lg hidden" id="fileInfo"></div>
            </div>

            <!-- Global Detail Files Upload Section -->
            <div class="border-2 border-dashed border-gray-300 rounded-xl p-8 text-center mb-6 transition-all duration-300 hover:border-purple-400 hover:bg-purple-50 hidden" id="detailUploadSection">
                <h3 class="text-lg font-semibold text-gray-900 mb-2"> 2.อัพโหลดไฟล์รายละเอียด (Detail Files)</h3>
                <p class="text-gray-600 text-sm mb-4">
                    อัพโหลดไฟล์รายละเอียดทั้งหมดพร้อมกัน ระบบจะจัดกลุ่มไฟล์อัตโนมัติตาม Doc No<br>
                    สามารถเลือกหลายไฟล์พร้อมกันได้ (รองรับการลากและวาง)
                </p>
                <input type="file" id="globalDetailFileInput" class="hidden" accept=".xlsx,.xls" multiple />
                <div id="globalDetailDropZone" class="cursor-pointer">
                    <button class="bg-purple-600 text-white px-6 py-3 rounded-lg hover:bg-purple-700 transition-colors font-medium">
                        เลือกไฟล์รายละเอียด
                    </button>
                </div>
                <div class="mt-4 text-xs text-gray-500">
                    รองรับไฟล์ .xlsx และ .xls • สามารถอัพโหลดหลายไฟล์พร้อมกัน
                </div>
                
                <!-- Global Detail Files List -->
                <div class="mt-4" id="globalDetailFilesList" style="display: none;">
                    <div class="text-left">
                        <h4 class="font-semibold text-gray-800 mb-2">ไฟล์ที่อัพโหลด:</h4>
                        <div id="globalDetailFilesContainer" class="space-y-2"></div>
                    </div>
                </div>
            </div>

            <!-- SOH Upload Section -->
            <div class="border-2 border-dashed border-gray-300 rounded-xl p-8 text-center mb-6 transition-all duration-300 hover:border-green-400 hover:bg-green-50 hidden" id="sohUploadSection">
                <h3 class="text-lg font-semibold text-gray-900 mb-2"> 3.อัพโหลดไฟล์ SOH (Stock On Hand) สำหรับอัพเดท Final OH</h3>
                <p class="text-gray-600 text-sm mb-4">
                    ไฟล์ SOH จะถูกใช้เพื่อ:<br>
                    • เพิ่มคอลัมน์ Final OH ให้กับตารางรายละเอียด<br>
                    • คำนวณ Final OH (Check OH - Final OH)<br>
                    • ลบ SKU ที่มี Final OH = 0 ออกจากตารางรายละเอียด<br>
                    • อัพเดทข้อมูลจาก AVAILABLE_QTY ในไฟล์ SOH
                </p>
                <input type="file" id="sohFileInput" class="hidden" accept=".xlsx,.xls" />
                <button class="bg-green-600 text-white px-6 py-3 rounded-lg hover:bg-green-700 transition-colors font-medium" onclick="document.getElementById('sohFileInput').click()">
                    <span id="sohUploadText">เลือกไฟล์ SOH</span>
                </button>
                <div class="mt-4 p-4 bg-green-50 border border-green-200 rounded-lg hidden" id="sohFileInfo"></div>
                
                <!-- SOH Progress Bar -->
                <div class="progress-container" id="sohProgressContainer" style="display: none;">
                    <div class="progress-bar">
                        <div class="progress-fill" id="sohProgressFill"></div>
                    </div>
                    <div class="progress-text" id="sohProgressText">0%</div>
                </div>
                
                <div id="sohProcessingStatus" style="margin-top: 1rem; font-weight: bold;"></div>
                
                <!-- SOH Statistics -->
                <div id="sohStats" class="soh-stats" style="display: none;">
                    <div class="soh-stat-item">
                        <div class="soh-stat-number" id="sohRecordsProcessed">0</div>
                        <div class="soh-stat-label">รายการที่ประมวลผล</div>
                    </div>
                    <div class="soh-stat-item">
                        <div class="soh-stat-number" id="sohRecordsMatched">0</div>
                        <div class="soh-stat-label">รายการที่จับคู่สำเร็จ</div>
                    </div>
                </div>
            </div>

            <!-- Processing Status -->
            <div class="text-center p-4 mx-4 rounded-lg hidden" id="processingStatus"></div>

            <!-- Results Section -->
            <div class="hidden" id="resultsSection">
                <!-- Tab Navigation -->
                <div class="tab-navigation">
                    <button class="tab-button active" onclick="switchTab('overview')" data-tab="overview">
                        <span class="tab-icon">📊</span>
                        Overview
                    </button>
                    <button class="tab-button" onclick="switchTab('byGroup')" data-tab="byGroup">
                        <span class="tab-icon">📋</span>
                        By Group
                    </button>
                </div>

                <!-- Overview Tab Content -->
                <div class="tab-content active" id="overviewTab">
                    <!-- Summary Stats -->
                    <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-8" id="summaryStats"></div>
                    
                    <!-- Branch Status Overview -->
                    <div id="branchStatusOverview"></div>
                </div>

                <!-- By Group Tab Content -->
                <div class="tab-content" id="byGroupTab">
                    <!-- Group Results -->
                    <div id="groupResults"></div>
                </div>

                <!-- Export Section -->
                <div class="text-center mt-8 space-x-4">
                    <button class="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium" onclick="exportOverviewToExcel()">Excel Overview</button>
                    <button class="bg-purple-600 text-white px-6 py-3 rounded-lg hover:bg-purple-700 transition-colors font-medium" onclick="exportAllGroupData()">Export All Groups Data</button>
                    <button class="bg-orange-600 text-white px-6 py-3 rounded-lg hover:bg-orange-700 transition-colors font-medium" onclick="exportDiscrepancySKU()">Export Discrepancy SKU</button>
                    <button class="bg-blue-600 text-white px-6 py-3 rounded-lg hover:bg-blue-700 transition-colors font-medium" onclick="exportToPDF()">
                        <svg class="w-5 h-5 mr-2 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z"/>
                        </svg>
                        Export PDF
                    </button>
                </div>
            </div>
            </div>
        </div>
    </main>

    <!-- Authentication Scripts moved to end of file -->

    <style media="print">
        .upload-section, .export-section, nav, .no-print, button, .tab-navigation {
            display: none !important;
        }
        
        body {
            background: white !important;
            padding: 1rem !important;
        }
        
        .modal-overlay {
            display: none !important;
        }
        
        /* Ensure tables and content are visible in PDF */
        .data-table, .results-section, .group-section {
            page-break-inside: avoid;
        }
        
        /* Improve table formatting for PDF */
        .data-table th,
        .data-table td {
            border: 1px solid #ddd !important;
            padding: 8px !important;
        }
        
        .data-table th {
            background-color: #f5f5f5 !important;
            font-weight: bold !important;
        }
        
        /* Show tab content for PDF */
        .tab-content {
            display: block !important;
        }
    </style>

    <script>
        let processedData = {};
        let allData = [];

        // File upload handling
        document.getElementById('fileInput').addEventListener('change', handleFileUpload);
        document.getElementById('sohFileInput').addEventListener('change', handleSOHFileUpload);

        // Drag and drop functionality
        const uploadSection = document.getElementById('uploadSection');
        uploadSection.addEventListener('dragover', (e) => {
            e.preventDefault();
            uploadSection.classList.add('dragover');
        });

        uploadSection.addEventListener('dragleave', () => {
            uploadSection.classList.remove('dragover');
        });

        uploadSection.addEventListener('drop', (e) => {
            e.preventDefault();
            uploadSection.classList.remove('dragover');
            const files = e.dataTransfer.files;
            if (files.length > 0) {
                handleFile(files[0]);
            }
        });

        function handleFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                handleFile(file);
            }
        }

        function handleSOHFileUpload(event) {
            const file = event.target.files[0];
            if (file) {
                handleSOHFile(file);
            }
        }

        function handleFile(file) {
            if (!file.name.match(/\.(xlsx|xls)$/)) {
                showStatus('error', 'กรุณาเลือกไฟล์ .xlsx หรือ .xls เท่านั้น');
                return;
            }

            // Show file info
            const fileInfo = document.getElementById('fileInfo');
            fileInfo.innerHTML = `
                <strong>ไฟล์:</strong> ${file.name}<br>
                <strong>ขนาด:</strong> ${(file.size / 1024 / 1024).toFixed(2)} MB<br>
                <strong>แก้ไขล่าสุด:</strong> ${new Date(file.lastModified).toLocaleString('th-TH')}
            `;
            fileInfo.style.display = 'block';

            // Process file
            processFile(file);
        }

        function processFile(file) {
            showStatus('processing', 'กำลังประมวลผลข้อมูล...');

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet);

                    allData = jsonData;
                    processData(jsonData);
                    showStatus('success', `ประมวลผลสำเร็จ! พบข้อมูล ${jsonData.length} รายการ`);
                    showResults();
                } catch (error) {
                    console.error('Error processing file:', error);
                    showStatus('error', 'เกิดข้อผิดพลาดในการประมวลผลไฟล์');
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function handleSOHFile(file) {
            if (!file.name.match(/\.(xlsx|xls)$/)) {
                showSOHStatus('error', 'กรุณาเลือกไฟล์ .xlsx หรือ .xls เท่านั้น');
                return;
            }

            // Show file info
            const sohFileInfo = document.getElementById('sohFileInfo');
            sohFileInfo.innerHTML = `
                <strong>ไฟล์ SOH:</strong> ${file.name}<br>
                <strong>ขนาด:</strong> ${(file.size / 1024 / 1024).toFixed(2)} MB<br>
                <strong>แก้ไขล่าสุด:</strong> ${new Date(file.lastModified).toLocaleString('th-TH')}
            `;
            sohFileInfo.style.display = 'block';

            // Process SOH file
            processSOHFile(file);
        }

        function processSOHFile(file) {
            showSOHStatus('processing', 'กำลังประมวลผลไฟล์ SOH...');

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet);

                    // Validate required columns
                    if (jsonData.length === 0) {
                        throw new Error('ไฟล์ SOH ไม่มีข้อมูล');
                    }

                    const firstRow = jsonData[0];
                    const requiredColumns = ['BRANCH_CODE', 'SKU', 'AVAILABLE_QTY'];
                    const missingColumns = requiredColumns.filter(col => !(col in firstRow));
                    
                    if (missingColumns.length > 0) {
                        throw new Error(`ไฟล์ SOH ขาดคอลัมน์ที่จำเป็น: ${missingColumns.join(', ')}`);
                    }

                    // Check for SUBCLASS_CODE column (needed for iCenter filtering)
                    if (!('SUBCLASS_CODE' in firstRow)) {
                        console.warn('ไฟล์ SOH ไม่มีคอลัมน์ SUBCLASS_CODE - การกรองข้อมูล iCenter อาจไม่ทำงาน');
                    }

                    // Check if detail files exist
                    if (Object.keys(detailFiles).length === 0) {
                        showSOHStatus('error', 'กรุณาอัพโหลดไฟล์รายละเอียด (Detail Files) ก่อนอัพโหลดไฟล์ SOH');
                        return;
                    }

                    // Validate data types
                    let invalidRows = 0;
                    const validData = jsonData.filter(row => {
                        const branchCode = (row['BRANCH_CODE'] || '').toString().trim();
                        const sku = (row['SKU'] || '').toString().trim();
                        const qty = parseFloat(row['AVAILABLE_QTY']);
                        
                        if (!branchCode || !sku || isNaN(qty)) {
                            invalidRows++;
                            return false;
                        }
                        return true;
                    });

                    if (invalidRows > 0) {
                        console.warn(`พบข้อมูลไม่ถูกต้อง ${invalidRows} รายการ จะข้ามไป`);
                    }

                    if (validData.length === 0) {
                        throw new Error('ไม่พบข้อมูล SOH ที่ถูกต้อง');
                    }

                    // Process SOH data and update detail files
                    updateDetailFilesWithSOH(validData);
                    
                    const statusMessage = invalidRows > 0 
                        ? `ประมวลผล SOH สำเร็จ! อัพเดทข้อมูล ${validData.length} รายการ (ข้าม ${invalidRows} รายการที่ไม่ถูกต้อง)`
                        : `ประมวลผล SOH สำเร็จ! อัพเดทข้อมูล ${validData.length} รายการ`;
                    
                    showSOHStatus('success', statusMessage);
                } catch (error) {
                    console.error('Error processing SOH file:', error);
                    showSOHStatus('error', `เกิดข้อผิดพลาดในการประมวลผลไฟล์ SOH: ${error.message}`);
                         // Reset upload button state
                const uploadBtn = document.querySelector('#sohUploadSection button');
                if (uploadBtn) {
                    uploadBtn.classList.remove('loading');
                    const uploadText = uploadBtn.querySelector('#sohUploadText');
                    if (uploadText) uploadText.textContent = 'เลือกไฟล์ SOH';
                }
                    
                    // Hide progress
                    document.getElementById('sohProgressContainer').style.display = 'none';
                }
            };
            reader.readAsArrayBuffer(file);
        }

        // SOH data storage
        let sohData = [];

        function updateDetailFilesWithSOH(sohJsonData) {
            sohData = sohJsonData;
            let totalUpdates = 0;
            let totalRemovals = 0;
            let totalProcessed = 0;
            
            // Show progress container
            const progressContainer = document.getElementById('sohProgressContainer');
            const progressFill = document.getElementById('sohProgressFill');
            const progressText = document.getElementById('sohProgressText');
            const uploadBtn = document.querySelector('#sohUploadSection button');
            
            if (progressContainer) progressContainer.style.display = 'block';
            if (uploadBtn) {
                uploadBtn.classList.add('loading');
                const uploadText = uploadBtn.querySelector('#sohUploadText');
                if (uploadText) uploadText.textContent = 'กำลังประมวลผล...';
            }

            // Calculate total operations
            let totalOperations = 0;
            Object.keys(detailFiles).forEach(groupName => {
                Object.keys(detailFiles[groupName]).forEach(docNo => {
                    totalOperations += detailFiles[groupName][docNo].data.length;
                });
            });

            // Process each group's detail files
            let currentOperation = 0;
            
            Object.keys(detailFiles).forEach(groupName => {
                Object.keys(detailFiles[groupName]).forEach(docNo => {
                    const detailFileData = detailFiles[groupName][docNo];
                    const originalCount = detailFileData.data.length;
                    
                    // Update each row in detail data
                    const updatedData = [];
                    
                    detailFileData.data.forEach(row => {
                        currentOperation++;
                        const progress = Math.round((currentOperation / totalOperations) * 100);
                        
                        // Update progress bar
                        progressFill.style.width = `${progress}%`;
                        progressText.textContent = `${progress}%`;
                        
                        // Find matching SOH record by BRANCH_CODE and SKU
                        const sohMatch = sohData.find(sohRow => {
                            const sohBranch = (sohRow['BRANCH_CODE'] || '').toString().trim();
                            const sohSku = (sohRow['SKU'] || '').toString().trim();
                            const detailBranch = (row['Branch'] || '').toString().trim();
                            const detailSku = (row['SKU'] || '').toString().trim();
                            
                            return sohBranch === detailBranch && sohSku === detailSku;
                        });

                        totalProcessed++;

                        if (sohMatch) {
                            // Add Final OH column from SOH AVAILABLE_QTY
                            const finalOH = parseFloat(sohMatch['AVAILABLE_QTY']) || 0;
                            row['Final OH'] = finalOH;
                            
                            // For iCenter group: filter out SKUs with SUBCLASS_CODE = "OTH"
                            if (groupName === 'iCenter') {
                                const subclassCode = (sohMatch['SUBCLASS_CODE'] || '').toString().trim().toUpperCase();
                                if (subclassCode === 'OTH') {
                                    console.log(`Filtering out iCenter SKU with SUBCLASS_CODE = OTH: ${row['SKU']}`);
                                    totalRemovals++;
                                    return; // Skip this row (don't add to updatedData)
                                }
                            }
                            
                            // Keep row regardless of Final OH value (no removal based on Final Diff)
                            updatedData.push(row);
                            totalUpdates++;
                        } else {
                            // No SOH match found, keep original row
                            updatedData.push(row);
                        }
                    });
                    
                    // Update the detail file data
                    detailFiles[groupName][docNo].data = updatedData;
                    
                    console.log(`Updated ${docNo}: ${originalCount} -> ${updatedData.length} rows`);
                });
            });

            // Complete progress
            setTimeout(() => {
                progressFill.style.width = '100%';
                progressText.textContent = '100%';
                
                // Show statistics
                document.getElementById('sohRecordsProcessed').textContent = totalProcessed;
                document.getElementById('sohRecordsMatched').textContent = totalUpdates;
                document.getElementById('sohStats').style.display = 'flex';
                
                // Reset upload button
                const uploadBtn = document.querySelector('#sohUploadSection button');
                if (uploadBtn) {
                    uploadBtn.classList.remove('loading');
                    const uploadText = uploadBtn.querySelector('#sohUploadText');
                    if (uploadText) uploadText.textContent = '✓ SOH อัพเดทแล้ว';
                }
                
                // Hide progress after completion
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                }, 2000);
                
                // Refresh the results display to show updated data
                showGroupResults();
                
                // Show summary of updates
                let summaryMessage = `SOH อัพเดทเสร็จสิ้น: อัพเดท ${totalUpdates} รายการ`;
                if (totalRemovals > 0) {
                    summaryMessage += `, กรองออก ${totalRemovals} รายการ (iCenter SUBCLASS_CODE = OTH)`;
                }
                showSOHStatus('success', summaryMessage);
            }, 500);
        }

        function showStatus(type, message) {
            const status = document.getElementById('processingStatus');
            status.classList.remove('hidden', 'bg-yellow-100', 'border-yellow-400', 'text-yellow-800', 
                                    'bg-green-100', 'border-green-400', 'text-green-800',
                                    'bg-red-100', 'border-red-400', 'text-red-800');
            
            if (type === 'processing') {
                status.classList.add('bg-yellow-100', 'border-yellow-400', 'text-yellow-800', 'border');
            } else if (type === 'success') {
                status.classList.add('bg-green-100', 'border-green-400', 'text-green-800', 'border');
            } else if (type === 'error') {
                status.classList.add('bg-red-100', 'border-red-400', 'text-red-800', 'border');
            }
            
            status.textContent = message;
            status.classList.remove('hidden');

            if (type === 'success' || type === 'error') {
                setTimeout(() => {
                    status.classList.add('hidden');
                }, 3000);
            }
        }

        function showSOHStatus(type, message) {
            const status = document.getElementById('sohProcessingStatus');
            status.className = `processing-status ${type}`;
            status.textContent = message;
            status.style.display = 'block';

            if (type === 'success' || type === 'error') {
                setTimeout(() => {
                    status.style.display = 'none';
                }, 5000);
            }
        }

        // Define expected branches by group based on checklist.html
        const expectedBranches = {
            'Head Office': [
                'B000 - Head Office'
            ],
            'AIS, A-Store, Mobi': [
                'B034 - AIS Shop Lotus Rayong',
                'B035 - AIS Shop BigC Arun',
                'B037 - Mobi Phayao',
                'B038 - Mobi Lamphun',
                'B040 - AIS Robinson Lifestyle Chanthaburi',
                'B044 - AIS Shop Lotus Rojana',
                'B046 - AIS Lotus Ban Chang',
                'B047 - AIS TW Lotus Lom Sak',
                'B049 - Mobi Phichit',
                'B050 - AIS TW BigC Wichian Buri',
                'B051 - AIS Shop RobinsonKamphaengPhet',
                'B052 - AIS Buddy Phayao',
                'B053 - AIS Shop Lotus Phetchabun',
                'B054 - AIS shop Big C sattahip',
                'B056 - AIS Shop Robinson Chonburi',
                'B058 - AIS TW Lotus U-Tapao',
                'B059 - AIS Shop Central Rayong',
                'B064 - AIS TW Lotus SiThep',
                'B068 - AIS A-Store SWU',
                'B070 - AIS A-Store PSU',
                'B075 - AIS Telewiz Lotus Chonburi',
                'B076 - A-Store มหาวิทยาลัยมหิดล ศาลายา',
                'B078 - AIS Robinson Mae Sot',
                'B079 - AIS A-Store SUT',
                'B081 - AIS TW Laemtong Chonburi',
                'B083 - AIS A-Store BU',
                'B084 - Mobi Suvarnabhumi',
                'B087 - AIS Robinson Ban Chang',
                'B089 - A-Store มหาวิทยาลัยแม่ฟ้าหลวง',
                'B091 - A-Store มหาวิทยาลัยราชภัฏเชียงใหม่',
                'B092 - AIS Shop Robinson Lifestyle Thalang',
                'B095 - A-Store มหาวิทยาลัยมหาสารคาม',
                'B096 - A-Store มหาวิทยาลัยเกษตรศาสตร์ ศรีราชา',
                'B098 - Mobi Lotus Bo Win',
                'B099 - AIS Mini Shop Lotus Pak Kret',
                'B100 - AIS Telewiz Lotus Sattahip',
                'B101 - AIS Buddy Krua Sahapat',
                'B102 - A-Store Kasetsart University',
                'B109 - AIS Telewiz Lotus พะเยา',
                'B110 - Mobi Esplanade',
                'B111 - AIS Shop Robinson Chalong',
                'B112 - AIS Telewiz Lotus Samkong Phuket'
            ],
            'U-Store': [
                'B006 - U Store TUR',
                'B007 - U Store ABB',
                'B008 - U Store TU Thaprajan',
                'B012 - U Store KUB',
                'B013 - U Store MUS',
                'B016 - U Store BUR',
                'B017 - U Store DPU',
                'B019 - U Store BUU',
                'B061 - U Store Mae Fah Luang University',
                'B062 - U Store KMUTNB',
                'B063 - U Store NU',
                'B065 - U Store MSU',
                'B066 - U Store RBRU',
                'B067 - U Store CMRU',
                'B069 - U Store PSU',
                'B071 - U Store UP',
                'B072 - U Store SUT',
                'B073 - U Store Maejo University',
                'B074 - U Store RMUTT',
                'B085 - U Store NPRU',
                'B090 - U Store Pibulsongkram Rajabhat University',
                'B093 - U Store TU Rungsit-MED',
                'B094 - U Store SIAMSCAPE',
                'B097 - U Store Kasetsart University ศรีราชา',
                'B103 - U Store RMUTK',
                'B104 - U Store Phranakhon Rajabhat University',
                'B105 - U Store Nakhon Sawan Rajabhat University'
            ],
            'iStudio, iBeat': [
                'B002 - IBeat – IT Mall',
                'B004 - IBeat Esplanade',
                'B009 - iStudio Central Chaengwattana',
                'B010 - iStudio Seacon Square',
                'B018 - iStudio Central Rama 9',
                'B021 - IBeat Gateway Ekamai',
                'B024 - IBeat – Central Chiang Rai',
                'B031 - iStudio Central Rayong',
                'B048 - I Beat Robinson kampaeng phet',
                'B106 - iStudio Central Westville',
                'B107 - iStudio Central Nakhon Sawan'
            ],
            'iCenter': [
                'B020 - iCenter Central Changwattana',
                'B032 - iCenter Central Chiang Rai',
                'B036 - iCenter Laemtong Rayong',
                'B039 - iCenter Homepro Nakhonpatom',
                'B055 - iCenter G Tower',
                'B077 - iCenter Phuke',
                'B080 - Icenter Robinson Chanthaburi'
            ]
        };

        // Helper function to get full branch name from branch code
        function getFullBranchName(branchCode) {
            if (!branchCode) return '';
            
            // Extract branch code from the input (handle cases like "B034" or "B034 - AIS Shop Lotus Rayong")
            const code = branchCode.split(' ')[0].trim();
            
            // Search through all groups to find the full branch name
            for (const groupName in expectedBranches) {
                const branch = expectedBranches[groupName].find(fullName => 
                    fullName.startsWith(code + ' -')
                );
                if (branch) {
                    return branch;
                }
            }
            
            // If not found in expected branches, return the original code
            return branchCode;
        }

        function processData(data) {
            processedData = {
                'AIS, A-Store, Mobi': [],
                'U-Store': [],
                'iStudio, iBeat': [],
                'iCenter': [],
                'Head Office': []
            };

            // Track processed branches
            const processedBranches = {
                'AIS, A-Store, Mobi': new Set(),
                'U-Store': new Set(),
                'iStudio, iBeat': new Set(),
                'iCenter': new Set(),
                'Head Office': new Set()
            };

            // Group by branch type
            data.forEach(row => {
                const branch = row['Branch'] || '';
                const branchLower = branch.toLowerCase();

                let groupType;
                if (branchLower.includes('ais') || branchLower.includes('a-store') || branchLower.includes('mobi')) {
                    groupType = 'AIS, A-Store, Mobi';
                } else if (branchLower.includes('u store') || branchLower.includes('u-store')) {
                    groupType = 'U-Store';
                } else if (branchLower.includes('istudio') || branchLower.includes('ibeat')) {
                    groupType = 'iStudio, iBeat';
                } else if (branchLower.includes('icenter')) {
                    groupType = 'iCenter';
                } else if (branchLower.includes('head office')) {
                    groupType = 'Head Office';
                } else {
                    // Try to categorize based on other patterns
                    groupType = 'Head Office'; // Default fallback
                }

                row.groupType = groupType;
            });

            // Process each group according to specific rules
            processAISGroup(data.filter(row => row.groupType === 'AIS, A-Store, Mobi'));
            processUStoreGroup(data.filter(row => row.groupType === 'U-Store'));
            processIStudioGroup(data.filter(row => row.groupType === 'iStudio, iBeat'));
            processICenterGroup(data.filter(row => row.groupType === 'iCenter'));
            processHeadOfficeGroup(data.filter(row => row.groupType === 'Head Office'));

            // Track which branches have been processed
            Object.keys(processedData).forEach(groupName => {
                processedData[groupName].forEach(row => {
                    processedBranches[groupName].add(row['Branch']);
                });
            });

            // Store processed branches for missing branch analysis
            window.processedBranches = processedBranches;
        }

        function processAISGroup(data) {
            // AIS, A-Store, Mobi: Check Stock, Status Confirm/Draft, include all records to track branches
            const branchGroups = groupByBranch(data);
            
            Object.keys(branchGroups).forEach(branchId => {
                const branchData = branchGroups[branchId]
                    .filter(row => 
                        (row['Check'] === 'Check Stock') &&
                        (row['Status'] === 'Confirm' || row['Status'] === 'Draft') &&
                        (row['Onhand'] != 0 && row['Counted'] != 0)
                    )
                    .sort((a, b) => new Date(b['Create Date']) - new Date(a['Create Date']));

                if (branchData.length > 0) {
                    processedData['AIS, A-Store, Mobi'].push(branchData[0]);
                }
            });
        }

        function processUStoreGroup(data) {
            // U-Store: Check Serial, Classes (AP-IPH-APPLE IPHONE, AP-IPD-APPLE IPAD, AP-MAC-APPLE MAC), latest by Create Date per Branch per Class
            const targetClasses = ['AP-IPH-APPLE IPHONE', 'AP-IPD-APPLE IPAD', 'AP-MAC-APPLE MAC'];
            const branchGroups = groupByBranch(data);

            Object.keys(branchGroups).forEach(branchId => {
                targetClasses.forEach(targetClass => {
                    const classData = branchGroups[branchId]
                        .filter(row => 
                            (row['Check'] === 'Check Serial') &&
                            (row['Class'] === targetClass) &&
                            (row['Status'] === 'Confirm' || row['Status'] === 'Draft')
                        )
                        .sort((a, b) => new Date(b['Create Date']) - new Date(a['Create Date']));

                    if (classData.length > 0) {
                        processedData['U-Store'].push(classData[0]);
                    }
                });
            });
        }

        function processIStudioGroup(data) {
            // iStudio, iBeat: Check Serial, Class AP-IPH-APPLE IPHONE only, latest by Create Date per Branch
            const branchGroups = groupByBranch(data);

            Object.keys(branchGroups).forEach(branchId => {
                const branchData = branchGroups[branchId]
                    .filter(row => 
                        (row['Check'] === 'Check Serial') &&
                        (row['Class'] === 'AP-IPH-APPLE IPHONE') &&
                        (row['Status'] === 'Confirm' || row['Status'] === 'Draft')
                    )
                    .sort((a, b) => new Date(b['Create Date']) - new Date(a['Create Date']));

                if (branchData.length > 0) {
                    processedData['iStudio, iBeat'].push(branchData[0]);
                }
            });
        }

        function processICenterGroup(data) {
            // iCenter: Same as AIS group - Check Stock, Status Confirm/Draft, include all records to track branches
            const branchGroups = groupByBranch(data);
            
            Object.keys(branchGroups).forEach(branchId => {
                const branchData = branchGroups[branchId]
                    .filter(row => 
                        (row['Check'] === 'Check Stock') &&
                        (row['Status'] === 'Confirm' || row['Status'] === 'Draft') &&
                        (row['Onhand'] != 0 && row['Counted'] != 0)
                    )
                    .sort((a, b) => new Date(b['Create Date']) - new Date(a['Create Date']));

                if (branchData.length > 0) {
                    processedData['iCenter'].push(branchData[0]);
                }
            });
        }

        function processHeadOfficeGroup(data) {
            // Head Office: Same as AIS group - Check Stock, Status Confirm/Draft, include all records to track branches
            const branchGroups = groupByBranch(data);
            
            Object.keys(branchGroups).forEach(branchId => {
                const branchData = branchGroups[branchId]
                    .filter(row => 
                        (row['Check'] === 'Check Stock') &&
                        (row['Status'] === 'Confirm' || row['Status'] === 'Draft') &&
                        (row['Onhand'] != 0 && row['Counted'] != 0)
                    )
                    .sort((a, b) => new Date(b['Create Date']) - new Date(a['Create Date']));

                if (branchData.length > 0) {
                    processedData['Head Office'].push(branchData[0]);
                }
            });
        }

        function groupByBranch(data) {
            return data.reduce((groups, row) => {
                const branchId = row['Branch'];
                if (!groups[branchId]) {
                    groups[branchId] = [];
                }
                groups[branchId].push(row);
                return groups;
            }, {});
        }

        function showResults() {
            document.getElementById('resultsSection').classList.remove('hidden');
            document.getElementById('sohUploadSection').classList.remove('hidden');
            document.getElementById('detailUploadSection').classList.remove('hidden');
            
            // Show summary stats
            showSummaryStats();
            
            // Show branch status overview first
            showBranchStatusOverview();
            
            // Show group results
            showGroupResults();
        }

        function switchTab(tabName) {
            // Remove active class from all tab buttons and contents
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });

            // Add active class to selected tab button and content
            document.querySelector(`[data-tab="${tabName}"]`).classList.add('active');
            document.getElementById(`${tabName}Tab`).classList.add('active');
        }

        function showBranchStatusOverview() {
            const branchStatusHtml = `
                <div class="branch-status-section">
                    <div class="branch-status-title">
                        สถานะสาขาทั้งหมด - Branch Status Overview
                    </div>
                    ${generateBranchStatusTable()}
                </div>
            `;
            
            // Insert into overview tab instead of before group results
            const overviewTab = document.getElementById('overviewTab');
            const existingBranchStatus = overviewTab.querySelector('.branch-status-section');
            if (existingBranchStatus) {
                existingBranchStatus.remove();
            }
            
            // Add after summary stats
            const summaryStats = overviewTab.querySelector('#summaryStats');
            summaryStats.insertAdjacentHTML('afterend', branchStatusHtml);
            
            // Initialize sorting for the new table
            setTimeout(() => initializeSortableTables(), 100);
        }

        function generateBranchStatusTable() {
            const allExpectedBranches = [];
            const processedBranchesFlat = new Set();
            
            // Collect all expected branches and processed branches
            Object.keys(expectedBranches).forEach(groupName => {
                expectedBranches[groupName].forEach(branch => {
                    allExpectedBranches.push({
                        branch: branch,
                        group: groupName
                    });
                });
                
                // Collect processed branches
                if (window.processedBranches && window.processedBranches[groupName]) {
                    Array.from(window.processedBranches[groupName]).forEach(branch => {
                        processedBranchesFlat.add(branch);
                    });
                }
            });
            
            let tableHtml = `
                <table class="data-table sortable-table">
                    <thead>
                        <tr>
                            <th class="sortable" onclick="sortTable(this, 0)">Branch Code <span class="sort-icon">↕</span></th>
                            <th class="sortable" onclick="sortTable(this, 1)">Branch Name <span class="sort-icon">↕</span></th>
                            <th class="sortable" onclick="sortTable(this, 2)">Group <span class="sort-icon">↕</span></th>
                            <th class="sortable" onclick="sortTable(this, 3)">Status <span class="sort-icon">↕</span></th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            // Sort branches by branch code
            allExpectedBranches.sort((a, b) => {
                const aCode = a.branch.split(' ')[0];
                const bCode = b.branch.split(' ')[0];
                return aCode.localeCompare(bCode);
            });
            
            allExpectedBranches.forEach(item => {
                const branchCode = item.branch.split(' ')[0];
                const branchName = item.branch.substring(item.branch.indexOf(' ') + 1);
                
                // Check if branch was found in processed data
                const isFound = Array.from(processedBranchesFlat).some(processed => 
                    processed.includes(branchCode)
                );
                
                const statusClass = isFound ? 'status-pass' : 'status-fail';
                const statusText = isFound ? 'PASS' : 'FAIL';
                
                tableHtml += `
                    <tr>
                        <td>${branchCode}</td>
                        <td>${branchName}</td>
                        <td>${item.group}</td>
                        <td><span class="${statusClass}">${statusText}</span></td>
                    </tr>
                `;
            });
            
            tableHtml += '</tbody></table>';
            return tableHtml;
        }

        function showSummaryStats() {
            // Calculate total expected branches across all groups
            let totalExpectedBranches = 0;
            Object.keys(expectedBranches).forEach(groupName => {
                totalExpectedBranches += (expectedBranches[groupName] || []).length;
            });
            
            // Calculate branches that have data (found in processed data)
            const processedBranchesFlat = new Set();
            Object.keys(expectedBranches).forEach(groupName => {
                if (window.processedBranches && window.processedBranches[groupName]) {
                    Array.from(window.processedBranches[groupName]).forEach(branch => {
                        processedBranchesFlat.add(branch);
                    });
                }
            });
            
            // Count branches that were found in data
            let branchesFound = 0;
            Object.keys(expectedBranches).forEach(groupName => {
                const expectedForGroup = expectedBranches[groupName] || [];
                expectedForGroup.forEach(expected => {
                    const expectedCode = expected.split(' ')[0];
                    const isFound = Array.from(processedBranchesFlat).some(processed => 
                        processed.includes(expectedCode)
                    );
                    if (isFound) {
                        branchesFound++;
                    }
                });
            });
            
            // Calculate branches not found
            const branchesNotFound = totalExpectedBranches - branchesFound;
            
            const statsHtml = `
                <div class="bg-white p-6 rounded-lg border border-gray-200 text-center">
                    <div class="text-3xl font-bold text-gray-700">${totalExpectedBranches}</div>
                    <div class="text-sm text-gray-600 mt-1">สาขาทั้งหมด</div>
                </div>
                <div class="bg-white p-6 rounded-lg border border-gray-200 text-center">
                    <div class="text-3xl font-bold text-green-600">${branchesFound}</div>
                    <div class="text-sm text-gray-600 mt-1">สาขาที่พบข้อมูล</div>
                </div>
                <div class="bg-white p-6 rounded-lg border border-gray-200 text-center">
                    <div class="text-3xl font-bold text-red-600">${branchesNotFound}</div>
                    <div class="text-sm text-gray-600 mt-1">สาขาที่ไม่พบข้อมูล</div>
                </div>
            `;
            
            document.getElementById('summaryStats').innerHTML = statsHtml;
        }

        function showGroupResults() {
            const groupResultsContainer = document.getElementById('groupResults');
            let html = '';

            Object.keys(processedData).forEach(groupName => {
                const groupData = processedData[groupName];
                
                // Find missing branches for this group
                const expectedForGroup = expectedBranches[groupName] || [];
                const processedForGroup = window.processedBranches ? Array.from(window.processedBranches[groupName] || new Set()) : [];
                const missingBranches = expectedForGroup.filter(expected => {
                    return !processedForGroup.some(processed => {
                        // Flexible matching - check if the expected branch pattern exists in processed branch
                        const expectedCode = expected.split(' ')[0]; // Get B000, B001, etc.
                        return processed.includes(expectedCode);
                    });
                });
                
                // Count matches and discrepancies
                const totalRecords = groupData.length;
                const matchCount = groupData.filter(row => {
                    const onhand = parseFloat(row['Onhand']) || 0;
                    const counted = parseFloat(row['Counted']) || 0;
                    return onhand === counted && onhand !== 0;
                }).length;
                const discrepancyCount = groupData.filter(row => {
                    const diff = parseFloat(row['Diff']) || 0;
                    return diff !== 0;
                }).length;
                
                html += `
                    <div class="group-section">
                        <div class="group-header">
                            ${groupName} (${totalRecords} รายการ: ${matchCount} ตรงกัน, ${discrepancyCount} ไม่ตรงกัน)
                            ${sohData && sohData.length > 0 ? '<span style="background: #10b981; color: white; padding: 0.25rem 0.5rem; border-radius: 0.25rem; font-size: 0.75rem; margin-left: 0.5rem;">📊 SOH Integrated</span>' : ''}
                        </div>
                        <div class="group-content">
                `;

                // Show missing branches warning if any
                if (missingBranches.length > 0) {
                    html += `
                        <div class="missing-branches-section">
                            <h4 class="missing-branches-title">⚠️ สาขาที่ไม่พบข้อมูลในไฟล์ (${missingBranches.length} สาขา)</h4>
                            <div class="missing-branches-list">
                                ${missingBranches.map(branch => `<span class="missing-branch-tag">${branch}</span>`).join('')}
                            </div>
                        </div>
                    `;
                }

                if (groupData.length === 0) {
                    html += '<div class="no-data">ไม่พบข้อมูลที่ต้องตรวจสอบ</div>';
                } else {
                    // Add color legend
                    html += `
                        <div style="margin-bottom: 1rem; padding: 0.75rem; background-color: #f9fafb; border-radius: 0.5rem; font-size: 0.875rem;">
                            <strong>สัญลักษณ์สี:</strong>
                            <span style="display: inline-block; width: 12px; height: 12px; background-color: #22c55e; margin: 0 0.25rem; border-radius: 2px;"></span>
                            <span style="color: #16a34a;">เขียว = Onhand = Count (ตรงกัน)</span> | 
                            <span style="display: inline-block; width: 12px; height: 12px; background-color: #ef4444; margin: 0 0.25rem; border-radius: 2px;"></span>
                            <span style="color: #dc2626;">แดง = Onhand ≠ Count (ไม่ตรงกัน)</span>
                        </div>
                    `;
                    
                    html += `
                        <table class="data-table sortable-table">
                            <thead>
                                <tr>
                                    <th class="sortable" onclick="sortTable(this, 0)">Create Date <span class="sort-icon">↕</span></th>
                                    <th class="sortable" onclick="sortTable(this, 1)">Doc No <span class="sort-icon">↕</span></th>
                                    <th class="sortable" onclick="sortTable(this, 2)">Status <span class="sort-icon">↕</span></th>
                                    <th class="sortable" onclick="sortTable(this, 3)">Branch <span class="sort-icon">↕</span></th>
                                    <th class="sortable" onclick="sortTable(this, 4)">Class <span class="sort-icon">↕</span></th>
                                    <th class="sortable" onclick="sortTable(this, 5)">Check <span class="sort-icon">↕</span></th>
                                    <th class="sortable" onclick="sortTable(this, 6)">Onhand <span class="sort-icon">↕</span></th>
                                    <th class="sortable" onclick="sortTable(this, 7)">Counted <span class="sort-icon">↕</span></th>
                                    <th class="sortable" onclick="sortTable(this, 8)">Diff <span class="sort-icon">↕</span></th>
                                </tr>
                            </thead>
                            <tbody>
                    `;

                    groupData.forEach((row, index) => {
                        const onhand = parseFloat(row['Onhand']) || 0;
                        const counted = parseFloat(row['Counted']) || 0;
                        const diff = parseFloat(row['Diff']) || 0;
                        const isDiffRow = diff !== 0;
                        const isMatchRow = onhand === counted && onhand !== 0;
                        const docNo = row['Doc No'] || '';
                        const fullBranchName = getFullBranchName(row['Branch']);
                        
                        // Determine row class based on onhand vs counted comparison
                        let rowClass = '';
                        if (isMatchRow) {
                            rowClass = 'match-row';
                        } else if (isDiffRow) {
                            rowClass = 'diff-row';
                        }
                        
                        html += `
                            <tr class="${rowClass}" data-doc-no="${docNo}" data-group="${groupName}">
                                <td>${row['Create Date'] || ''}</td>
                                <td class="${docNo ? 'clickable-doc' : ''}" 
                                    ${docNo ? `onclick="showDocDetail('${docNo}', '${groupName}')"` : ''}>
                                    ${docNo}
                                </td>
                                <td>${row['Status'] || ''}</td>
                                <td>${fullBranchName}</td>
                                <td>${row['Class'] || ''}</td>
                                <td>${row['Check'] || ''}</td>
                                <td>${row['Onhand'] || ''}</td>
                                <td>${row['Counted'] || ''}</td>
                                <td>${row['Diff'] || ''}</td>
                            </tr>
                        `;
                    });

                    html += '</tbody></table>';
                }

                html += '</div></div>';
            });

            groupResultsContainer.innerHTML = html;
            
            // Setup global detail file upload handler after DOM is rendered
            setTimeout(() => {
                setupGlobalDetailFileHandler();
                // Initialize sorting for group tables (default sort by branch)
                initializeSortableTables();
            }, 100);
        }

        function exportOverviewToExcel() {
            const wb = XLSX.utils.book_new();

            // Calculate total expected branches across all groups
            let totalExpectedBranches = 0;
            Object.keys(expectedBranches).forEach(groupName => {
                totalExpectedBranches += (expectedBranches[groupName] || []).length;
            });
            
            // Calculate branches that have data (found in processed data)
            const processedBranchesFlat = new Set();
            Object.keys(expectedBranches).forEach(groupName => {
                if (window.processedBranches && window.processedBranches[groupName]) {
                    Array.from(window.processedBranches[groupName]).forEach(branch => {
                        processedBranchesFlat.add(branch);
                    });
                }
            });
            
            // Count branches that were found in data
            let branchesFound = 0;
            Object.keys(expectedBranches).forEach(groupName => {
                const expectedForGroup = expectedBranches[groupName] || [];
                expectedForGroup.forEach(expected => {
                    const expectedCode = expected.split(' ')[0];
                    const isFound = Array.from(processedBranchesFlat).some(processed => 
                        processed.includes(expectedCode)
                    );
                    if (isFound) {
                        branchesFound++;
                    }
                });
            });
            
            const branchesNotFound = totalExpectedBranches - branchesFound;

            // Create overview summary sheet
            const overviewSummaryData = [
                ['Metric', 'Count'],
                ['สาขาทั้งหมด (Total Branches)', totalExpectedBranches],
                ['สาขาที่พบข้อมูล (Branches Found)', branchesFound],
                ['สาขาที่ไม่พบข้อมูล (Branches Not Found)', branchesNotFound]
            ];
            const overviewSummaryWs = XLSX.utils.aoa_to_sheet(overviewSummaryData);
            XLSX.utils.book_append_sheet(wb, overviewSummaryWs, 'Overview Summary');

            // Create branch status sheet with all branches
            const branchStatusData = [['Branch Code', 'Branch Name', 'Group', 'Status']];
            const allExpectedBranches = [];
            
            // Collect all expected branches
            Object.keys(expectedBranches).forEach(groupName => {
                expectedBranches[groupName].forEach(branch => {
                    allExpectedBranches.push({
                        branch: branch,
                        group: groupName
                    });
                });
            });
            
            // Sort branches by branch code
            allExpectedBranches.sort((a, b) => {
                const aCode = a.branch.split(' ')[0];
                const bCode = b.branch.split(' ')[0];
                return aCode.localeCompare(bCode);
            });
            
            allExpectedBranches.forEach(item => {
                const branchCode = item.branch.split(' ')[0];
                const branchName = item.branch.substring(item.branch.indexOf(' ') + 1);
                
                // Check if branch was found in processed data
                const isFound = Array.from(processedBranchesFlat).some(processed => 
                    processed.includes(branchCode)
                );
                
                const statusText = isFound ? 'PASS' : 'FAIL';
                
                branchStatusData.push([branchCode, branchName, item.group, statusText]);
            });
            
            const branchStatusWs = XLSX.utils.aoa_to_sheet(branchStatusData);
            XLSX.utils.book_append_sheet(wb, branchStatusWs, 'Branch Status');

            // Create missing branches sheet
            const missingBranchesData = [['Group', 'Missing Branch Code', 'Missing Branch Name']];
            Object.keys(expectedBranches).forEach(groupName => {
                const expectedForGroup = expectedBranches[groupName] || [];
                const processedForGroup = window.processedBranches ? Array.from(window.processedBranches[groupName] || new Set()) : [];
                const missingBranches = expectedForGroup.filter(expected => {
                    return !processedForGroup.some(processed => {
                        const expectedCode = expected.split(' ')[0];
                        return processed.includes(expectedCode);
                    });
                });
                missingBranches.forEach(branch => {
                    const branchCode = branch.split(' ')[0];
                    const branchName = branch.substring(branch.indexOf(' ') + 1);
                    missingBranchesData.push([groupName, branchCode, branchName]);
                });
            });
            const missingWs = XLSX.utils.aoa_to_sheet(missingBranchesData);
            XLSX.utils.book_append_sheet(wb, missingWs, 'Missing Branches');

            // Save file
            const fileName = `SMCO_Overview_${new Date().toISOString().split('T')[0]}.xlsx`;
            XLSX.writeFile(wb, fileName);
        }

        function exportDiscrepancySKU() {
            const wb = XLSX.utils.book_new();
            
            // Collect all discrepancy SKU data from detail files
            const allDiscrepancyData = [];
            
            if (Object.keys(detailFiles).length === 0) {
                alert('ไม่พบไฟล์รายละเอียด กรุณาอัพโหลดไฟล์รายละเอียดก่อน');
                return;
            }

            Object.keys(detailFiles).forEach(groupName => {
                Object.keys(detailFiles[groupName]).forEach(docNo => {
                    const detailData = detailFiles[groupName][docNo].data;
                    
                    // Filter only SKUs with negative differences (Diff < 0 only)
                    // Also filter out rows where Final OH is 0 or blank when SOH data is available
                    // For iCenter group, also filter out SKUs with GLUE or ADHESIVE in SKU Description
                    const discrepancyRows = detailData.filter(row => {
                        const diff = parseFloat(row['Diff']) || 0;
                        // Only show negative differences (shortages/undercounts)
                        if (diff >= 0) return false;
                        
                        // If SOH data is available, filter out rows where Final OH is 0, blank, or "-"
                        const hasSOHData = sohData && sohData.length > 0;
                        if (hasSOHData) {
                            const finalOH = row['Final OH'];
                            // Check if Final OH is undefined, null, empty, "-", or 0
                            if (finalOH === undefined || finalOH === null || finalOH === '' || finalOH === '-' || parseFloat(finalOH) === 0 || isNaN(parseFloat(finalOH))) {
                                return false;
                            }
                        }
                        
                        // Additional filter for iCenter group: exclude GLUE and ADHESIVE
                        if (groupName === 'iCenter') {
                            const skuDesc = (row['SKU Description'] || '').toString().toUpperCase();
                            if (skuDesc.includes('GLUE') || skuDesc.includes('ADHESIVE')) {
                                return false;
                            }
                        }
                        
                        return true;
                    });
                    
                    discrepancyRows.forEach(row => {
                        const hasSOHData = sohData && sohData.length > 0;
                        const fullBranchName = getFullBranchName(row['Branch']);
                        const exportRow = {
                            'Group': groupName,
                            'Doc No': docNo,
                            'Branch': fullBranchName,
                            'SKU': row['SKU'] || '',
                            'SKU Description': row['SKU Description'] || '',
                            'OH (Original)': row['OH'] || 0,
                            'Scan': row['Scan'] || 0,
                            'Diff (Scan - OH)': row['Diff'] || 0,
                            'Reason': row['Reason'] || ''
                        };
                        
                        // Add SOH data if available (without Final Diff calculation)
                        if (hasSOHData && row['Final OH'] !== undefined) {
                            exportRow['Final OH (from SOH)'] = row['Final OH'];
                            exportRow['SOH Updated'] = 'Yes';
                        } else if (hasSOHData) {
                            exportRow['Final OH (from SOH)'] = 'N/A';
                            exportRow['SOH Updated'] = 'No';
                        }
                        
                        allDiscrepancyData.push(exportRow);
                    });
                });
            });

            if (allDiscrepancyData.length === 0) {
                alert('ไม่พบรายการที่มีความแตกต่าง (Discrepancy)');
                return;
            }

            // Create discrepancy SKU sheet
            const discrepancyWs = XLSX.utils.json_to_sheet(allDiscrepancyData);
            XLSX.utils.book_append_sheet(wb, discrepancyWs, 'Discrepancy SKU');

            // Create summary by group sheet
            const groupSummary = {};
            allDiscrepancyData.forEach(row => {
                const group = row['Group'];
                if (!groupSummary[group]) {
                    groupSummary[group] = {
                        'Group': group,
                        'Total Discrepancy Items': 0,
                        'Unique Branches': new Set(),
                        'Unique SKUs': new Set()
                    };
                }
                groupSummary[group]['Total Discrepancy Items']++;
                groupSummary[group]['Unique Branches'].add(getFullBranchName(row['Branch']));
                groupSummary[group]['Unique SKUs'].add(row['SKU']);
            });

            const summaryData = Object.values(groupSummary).map(item => ({
                'Group': item['Group'],
                'Total Discrepancy Items': item['Total Discrepancy Items'],
                'Unique Branches Count': item['Unique Branches'].size,
                'Unique SKUs Count': item['Unique SKUs'].size
            }));

            const summaryWs = XLSX.utils.json_to_sheet(summaryData);
            XLSX.utils.book_append_sheet(wb, summaryWs, 'Discrepancy Summary');

            // Save file
            const fileName = `SMCO_Discrepancy_SKU_${new Date().toISOString().split('T')[0]}.xlsx`;
            XLSX.writeFile(wb, fileName);
        }

        function exportAllGroupData() {
            if (Object.keys(processedData).length === 0) {
                alert('ไม่พบข้อมูลกลุ่ม กรุณาอัพโหลดไฟล์และประมวลผลข้อมูลก่อน');
                return;
            }

            const wb = XLSX.utils.book_new();

            // Create a sheet for each group
            Object.keys(processedData).forEach(groupName => {
                const groupData = processedData[groupName];
                
                if (groupData.length > 0) {
                    // Create clean data for export
                    const exportData = groupData.map(row => ({
                        'Create Date': row['Create Date'] || '',
                        'Doc No': row['Doc No'] || '',
                        'Status': row['Status'] || '',
                        'Branch': getFullBranchName(row['Branch']),
                        'Class': row['Class'] || '',
                        'Check': row['Check'] || '',
                        'Onhand': row['Onhand'] || 0,
                        'Counted': row['Counted'] || 0,
                        'Diff': row['Diff'] || 0
                    }));

                    // Create worksheet for this group
                    const ws = XLSX.utils.json_to_sheet(exportData);
                    
                    // Auto-adjust column widths
                    const wscols = [
                        { wch: 12 }, // Create Date
                        { wch: 16 }, // Doc No
                        { wch: 10 }, // Status
                        { wch: 25 }, // Branch
                        { wch: 20 }, // Class
                        { wch: 12 }, // Check
                        { wch: 10 }, // Onhand
                        { wch: 10 }, // Counted
                        { wch: 10 }  // Diff
                    ];
                    ws['!cols'] = wscols;

                    // Add the worksheet to workbook with safe sheet name
                    const safeGroupName = groupName.replace(/[^a-zA-Z0-9 ]/g, '').substring(0, 30);
                    XLSX.utils.book_append_sheet(wb, ws, safeGroupName);
                } else {
                    // Create empty sheet for groups with no data
                    const emptyData = [{
                        'Message': `No data found for ${groupName}`,
                        'Create Date': '',
                        'Doc No': '',
                        'Status': '',
                        'Branch': '',
                        'Class': '',
                        'Check': '',
                        'Onhand': '',
                        'Counted': '',
                        'Diff': ''
                    }];
                    const ws = XLSX.utils.json_to_sheet(emptyData);
                    const safeGroupName = groupName.replace(/[^a-zA-Z0-9 ]/g, '').substring(0, 30);
                    XLSX.utils.book_append_sheet(wb, ws, safeGroupName);
                }
            });

            // Create a summary sheet with all data combined
            const allData = [];
            Object.keys(processedData).forEach(groupName => {
                processedData[groupName].forEach(row => {
                    allData.push({
                        'Group': groupName,
                        'Create Date': row['Create Date'] || '',
                        'Doc No': row['Doc No'] || '',
                        'Status': row['Status'] || '',
                        'Branch': row['Branch'] || '',
                        'Class': row['Class'] || '',
                        'Check': row['Check'] || '',
                        'Onhand': row['Onhand'] || 0,
                        'Counted': row['Counted'] || 0,
                        'Diff': row['Diff'] || 0
                    });
                });
            });

            if (allData.length > 0) {
                const summaryWs = XLSX.utils.json_to_sheet(allData);
                // Auto-adjust column widths for summary
                const wscols = [
                    { wch: 18 }, // Group
                    { wch: 12 }, // Create Date
                    { wch: 16 }, // Doc No
                    { wch: 10 }, // Status
                    { wch: 25 }, // Branch
                    { wch: 20 }, // Class
                    { wch: 12 }, // Check
                    { wch: 10 }, // Onhand
                    { wch: 10 }, // Counted
                    { wch: 10 }  // Diff
                ];
                summaryWs['!cols'] = wscols;
                XLSX.utils.book_append_sheet(wb, summaryWs, 'All Groups Summary');
            }

            // Save file
            const fileName = `SMCO_All_Groups_Data_${new Date().toISOString().split('T')[0]}.xlsx`;
            XLSX.writeFile(wb, fileName);
        }

        function exportToPDF() {
            // Check if jsPDF is available
            if (typeof window.jspdf === 'undefined') {
                alert('PDF library not loaded. Please refresh the page and try again.');
                return;
            }

            // Get the button to show loading state
            const button = event.target.closest('button');
            const originalText = button.innerHTML;
            
            try {
                // Set loading state
                button.innerHTML = `
                    <svg class="w-5 h-5 mr-2 inline animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                    </svg>
                    กำลังสร้าง PDF...
                `;
                button.disabled = true;

                // Create temporary div for PDF content with professional header
                const pdfContent = document.createElement('div');
                pdfContent.style.width = '210mm';
                pdfContent.style.padding = '15mm 20mm';
                pdfContent.style.backgroundColor = 'white';
                pdfContent.style.fontFamily = 'Sarabun, sans-serif';
                pdfContent.style.fontSize = '12pt';
                pdfContent.style.lineHeight = '1.4';
                pdfContent.style.position = 'absolute';
                pdfContent.style.left = '-9999px';
                pdfContent.style.top = '0';
                pdfContent.style.boxSizing = 'border-box';

                // Add professional header
                const today = new Date().toLocaleDateString('th-TH', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });

                pdfContent.innerHTML = `
                    <div style="text-align: center; margin-bottom: 30px; border-bottom: 2px solid #000; padding-bottom: 15px;">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
                            <div style="text-align: left; font-size: 10pt; font-weight: bold;">
                                Operation Audit Division<br>
                                (ฝ่ายตรวจสอบปฏิบัติการ)
                            </div>
                            <div style="text-align: right; font-size: 8pt; max-width: 280px;">
                                บริษัท เอส พี วี ไอ จำกัด (มหาชน)<br>
                                เลขที่ 2 อาคารพรีเมียร์เพลซ ชั้น 3 ซอยพรีเมียร์ 2 ถนนศรีนครินทร์<br>
                                แขวงหนองบอน เขตประเวศ กรุงเทพมหานคร 10250<br>
                                โทร. (66) 61-417-9777  Line ID : iStudio by spvi
                            </div>
                        </div>
                        <h1 style="font-size: 18pt; font-weight: bold; margin: 0;">SMCO Check Report</h1>
                        <p style="font-size: 12pt; color: #666; margin: 5px 0 0 0;">รายงานตรวจสอบและวิเคราะห์การควบคุมการจัดการสินค้าคงคลังของสาขา</p>
                        <p style="font-size: 10pt; color: #888; margin: 10px 0 0 0;">วันที่สร้างรายงาน: ${today}</p>
                    </div>
                `;

                // Get the main content and clone it
                const originalElement = document.querySelector('main');
                const contentClone = originalElement.cloneNode(true);
                
                // Remove unwanted elements from the cloned content
                const elementsToRemove = contentClone.querySelectorAll(`
                    .upload-section,
                    .export-section, 
                    .tab-navigation, 
                    .no-print, 
                    button,
                    #uploadSection,
                    #sohUploadSection,
                    #detailUploadSection,
                    .detail-upload-section,
                    .detail-upload-area,
                    .uploaded-files-list,
                    header,
                    nav,
                    .loading-overlay,
                    #loadingOverlay,
                    .modal-overlay,
                    #processingStatus,
                    .processing-status,
                    .bg-green-100,
                    .bg-yellow-100,
                    .bg-red-100
                `);
                elementsToRemove.forEach(el => el.remove());

                // Clean up the header in the content (we already have our professional header)
                const existingHeaders = contentClone.querySelectorAll('header, h1');
                existingHeaders.forEach(header => {
                    if (header.textContent.includes('SMCO Check')) {
                        header.remove();
                    }
                });

                // Only show Overview tab content for PDF
                const tabContents = contentClone.querySelectorAll('.tab-content');
                tabContents.forEach(tab => {
                    if (tab.id === 'overviewTab') {
                        tab.style.display = 'block';
                        tab.style.marginBottom = '30px';
                    } else {
                        tab.remove(); // Remove other tabs (like byGroupTab)
                    }
                });

                // Improve table styling for PDF and make it fill A4 size
                const tables = contentClone.querySelectorAll('.data-table');
                tables.forEach(table => {
                    table.style.pageBreakInside = 'avoid';
                    table.style.border = '1px solid #ddd';
                    table.style.borderCollapse = 'collapse';
                    table.style.width = '100%';
                    table.style.marginBottom = '20px';
                    table.style.fontSize = '9pt'; // Smaller font for better fit
                    
                    const cells = table.querySelectorAll('th, td');
                    cells.forEach(cell => {
                        cell.style.border = '1px solid #ddd';
                        cell.style.padding = '6px'; // Reduced padding
                        cell.style.fontSize = '9pt';
                        cell.style.lineHeight = '1.2';
                        cell.style.wordWrap = 'break-word';
                    });
                    
                    const headers = table.querySelectorAll('th');
                    headers.forEach(header => {
                        header.style.backgroundColor = '#f5f5f5';
                        header.style.fontWeight = 'bold';
                        header.style.fontSize = '9pt';
                    });
                });

                // Adjust summary stats cards for better PDF layout
                const statsCards = contentClone.querySelectorAll('.stat-card');
                statsCards.forEach(card => {
                    card.style.padding = '8px';
                    card.style.margin = '4px';
                    card.style.fontSize = '10pt';
                });

                // Make summary stats section more compact
                const summaryStats = contentClone.querySelector('#summaryStats');
                if (summaryStats) {
                    summaryStats.style.marginBottom = '15px';
                }

                // Remove outer container styling completely for PDF
                const mainContainer = contentClone.querySelector('.bg-white.rounded-xl.shadow-sm.border.border-gray-200');
                if (mainContainer) {
                    mainContainer.style.border = 'none';
                    mainContainer.style.boxShadow = 'none';
                    mainContainer.style.backgroundColor = 'transparent';
                    mainContainer.style.borderRadius = '0';
                    mainContainer.style.padding = '0';
                    mainContainer.style.margin = '0';
                }

                // Append cleaned content to PDF container
                pdfContent.appendChild(contentClone);
                
                // Add PDF content to body temporarily
                document.body.appendChild(pdfContent);
                
                // Generate PDF using html2canvas and jsPDF
                setTimeout(async () => {
                    try {
                        const canvas = await html2canvas(pdfContent, {
                            backgroundColor: 'white',
                            width: pdfContent.scrollWidth,
                            height: pdfContent.scrollHeight,
                            logging: false,
                            allowTaint: true,
                            scale: 2
                        });

                        const { jsPDF } = window.jspdf;
                        const pdf = new jsPDF('p', 'mm', 'a4');
                        
                        const imgWidth = 210; // A4 width in mm
                        const pageHeight = 295; // A4 height in mm (slightly less to account for margins)
                        const imgHeight = (canvas.height * imgWidth) / canvas.width;
                        
                        // Add first page
                        pdf.addImage(canvas.toDataURL('image/png'), 'PNG', 0, 0, imgWidth, imgHeight);
                        
                        // Add additional pages if content exceeds one page
                        if (imgHeight > pageHeight + 5) { // 5mm tolerance
                            let heightLeft = imgHeight - pageHeight;
                            
                            while (heightLeft > 5) { // Only continue if significant content remains
                                pdf.addPage();
                                const yPosition = -(imgHeight - heightLeft);
                                pdf.addImage(canvas.toDataURL('image/png'), 'PNG', 0, yPosition, imgWidth, imgHeight);
                                heightLeft -= pageHeight;
                            }
                        }

                        // Clean up
                        document.body.removeChild(pdfContent);

                        // Download PDF
                        const fileName = `SMCO_Check_Report_${new Date().toISOString().split('T')[0]}.pdf`;
                        pdf.save(fileName);

                    } catch (error) {
                        console.error('Error generating PDF:', error);
                        alert('เกิดข้อผิดพลาดในการสร้าง PDF กรุณาลองใหม่อีกครั้ง');
                        // Clean up on error
                        if (pdfContent.parentNode) {
                            document.body.removeChild(pdfContent);
                        }
                    } finally {
                        // Restore button state
                        button.innerHTML = originalText;
                        button.disabled = false;
                    }
                }, 100);

            } catch (error) {
                console.error('Error in PDF export:', error);
                alert('เกิดข้อผิดพลาดในการเตรียม PDF กรุณาลองใหม่อีกครั้ง');
                // Restore button state
                button.innerHTML = originalText;
                button.disabled = false;
            }
        }

        // Detail file handling
        let detailFiles = {}; // Store detail files by group and doc number
        let globalDetailHandlerSetup = false; // Flag to prevent multiple setup

        function handleDetailFiles(files, groupName) {
            const groupId = groupName.replace(/[^a-zA-Z0-9]/g, '');
            const uploadedFilesContainer = document.getElementById(`uploaded-files-${groupId}`);
            
            Array.from(files).forEach(file => {
                if (!file.name.match(/\.(xlsx|xls)$/)) {
                    alert(`ไฟล์ ${file.name} ไม่ใช่ไฟล์ Excel`);
                    return;
                }

                // Create file item UI
                const fileItem = document.createElement('div');
                fileItem.className = 'uploaded-file-item';
                fileItem.innerHTML = `
                    <span class="uploaded-file-name">${file.name}</span>
                    <span class="uploaded-file-status status-processing">กำลังประมวลผล...</span>
                `;
                uploadedFilesContainer.appendChild(fileItem);

                // Process the file
                processDetailFile(file, groupName, fileItem);
            });
        }

        function processDetailFile(file, groupName, fileItem) {
            const reader = new FileReader();
            
            reader.onload = function(e) {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const sheetName = workbook.SheetNames[0];
                    const worksheet = workbook.Sheets[sheetName];
                    const jsonData = XLSX.utils.sheet_to_json(worksheet);

                    // Extract doc number from filename (assuming format like PB049250600004.xlsx)
                    const docNoMatch = file.name.match(/([A-Z]{2}\d{12})/);
                    const extractedDocNo = docNoMatch ? docNoMatch[1] : null;

                    if (!extractedDocNo) {
                        throw new Error('ไม่พบ Doc No ในชื่อไฟล์');
                    }

                    // Check if this doc number exists in the main results
                    const mainRecord = processedData[groupName].find(row => 
                        row['Doc No'] && row['Doc No'].includes(extractedDocNo)
                    );

                    if (!mainRecord) {
                        throw new Error(`ไม่พบ Doc No ${extractedDocNo} ในผลลัพธ์หลัก`);
                    }

                    // Filter data: OH <> 0 and SKU/SKU Description not contain DEMO and SKU not end with -D
                    // For iCenter group, also filter out SKUs with GLUE or ADHESIVE in SKU Description
                    const filteredData = jsonData.filter(row => {
                        const oh = parseFloat(row['OH']) || 0;
                        const sku = (row['SKU'] || '').toString().toUpperCase();
                        const skuDesc = (row['SKU Description'] || '').toString().toUpperCase();
                        
                        // Basic filter: OH not 0, no DEMO, and SKU doesn't end with -D
                        let shouldInclude = oh !== 0 && !sku.includes('DEMO') && !skuDesc.includes('DEMO') && !sku.endsWith('-D');
                        
                        // Additional filter for iCenter group: exclude GLUE and ADHESIVE
                        if (shouldInclude && groupName === 'iCenter') {
                            shouldInclude = !skuDesc.includes('GLUE') && !skuDesc.includes('ADHESIVE');
                        }
                        
                        return shouldInclude;
                    });

                    // Calculate totals
                    const totalOH = filteredData.reduce((sum, row) => sum + (parseFloat(row['OH']) || 0), 0);
                    const totalScan = filteredData.reduce((sum, row) => sum + (parseFloat(row['Scan']) || 0), 0);

                    // Update main record
                    mainRecord['Onhand'] = totalOH;
                    mainRecord['Counted'] = totalScan;
                    mainRecord['Diff'] = totalScan - totalOH;

                    // Store detail data
                    if (!detailFiles[groupName]) {
                        detailFiles[groupName] = {};
                    }
                    detailFiles[groupName][extractedDocNo] = {
                        filename: file.name,
                        data: filteredData.map(row => ({
                            'Branch': row['Branch'] || '',
                            'SKU': row['SKU'] || '',
                            'SKU Description': row['SKU Description'] || '',
                            'OH': row['OH'] || 0,
                            'Scan': row['Scan'] || 0,
                            'Diff': (parseFloat(row['Scan']) || 0) - (parseFloat(row['OH']) || 0),
                            'Reason': row['Reason'] || ''
                        }))
                    };

                    // Update file status
                    const statusElement = fileItem.querySelector('.uploaded-file-status');
                    const isUpdate = statusElement.textContent.includes('อัพเดทข้อมูล');
                    const statusText = isUpdate ? `อัพเดทแล้ว (${filteredData.length} รายการ)` : `สำเร็จ (${filteredData.length} รายการ)`;
                    statusElement.textContent = statusText;
                    statusElement.className = 'uploaded-file-status status-success';

                    // Refresh the results display
                    showGroupResults();

                } catch (error) {
                    console.error('Error processing detail file:', error);
                    const statusElement = fileItem.querySelector('.uploaded-file-status');
                    statusElement.textContent = `ข้อผิดพลาด: ${error.message}`;
                    statusElement.className = 'uploaded-file-status status-error';
                }
            };

            reader.readAsArrayBuffer(file);
        }

        function setupGlobalDetailFileHandler() {
            // Prevent multiple setup
            if (globalDetailHandlerSetup) {
                console.log('Global detail handler already set up, skipping...');
                return;
            }

            console.log('Setting up global detail file handler...');
            const dropZone = document.getElementById('globalDetailDropZone');
            const fileInput = document.getElementById('globalDetailFileInput');
            const uploadedFilesContainer = document.getElementById('globalDetailFilesContainer');
            const filesList = document.getElementById('globalDetailFilesList');

            // Check if elements exist before setting up handlers
            if (!dropZone || !fileInput || !uploadedFilesContainer) {
                console.warn('Global detail upload elements not found in DOM');
                console.log('dropZone:', dropZone);
                console.log('fileInput:', fileInput);
                console.log('uploadedFilesContainer:', uploadedFilesContainer);
                return;
            }

            console.log('All elements found, setting up event handlers...');

            dropZone.addEventListener('click', () => {
                console.log('Drop zone clicked, opening file dialog...');
                fileInput.click();
            });

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('border-blue-500');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('border-blue-500');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('border-blue-500');
                const files = Array.from(e.dataTransfer.files);
                handleGlobalDetailFiles(files, uploadedFilesContainer, filesList);
            });

            fileInput.addEventListener('change', (e) => {
                console.log('File input change event triggered');
                console.log('Selected files:', e.target.files);
                console.log('Number of files:', e.target.files.length);
                
                const files = Array.from(e.target.files);
                if (files.length > 0) {
                    console.log('Processing files...');
                    handleGlobalDetailFiles(files, uploadedFilesContainer, filesList);
                } else {
                    console.log('No files selected');
                }
                
                // Reset file input to allow selecting the same files again
                console.log('Resetting file input...');
                fileInput.value = '';
            });

            // Mark as set up
            globalDetailHandlerSetup = true;
            console.log('Global detail file handler setup complete');
        }

        function handleGlobalDetailFiles(files, uploadedFilesContainer, filesList) {
            // Show the files list container
            if (filesList) {
                filesList.style.display = 'block';
            }

            files.forEach(file => {
                console.log(`Processing file: ${file.name}`);
                
                // Check file type
                if (!file.name.match(/\.(xlsx|xls)$/)) {
                    alert(`ไฟล์ ${file.name} ไม่ใช่ไฟล์ Excel`);
                    return;
                }

                // Extract doc number from filename
                const docNoMatch = file.name.match(/([A-Z]{2}\d{12})/);
                const extractedDocNo = docNoMatch ? docNoMatch[1] : null;

                if (!extractedDocNo) {
                    alert(`ไม่พบ Doc No ในชื่อไฟล์: ${file.name}`);
                    return;
                }

                console.log(`Extracted Doc No: ${extractedDocNo}`);

                // Find which group this doc number belongs to
                let targetGroup = null;
                for (const [groupName, groupData] of Object.entries(processedData)) {
                    const found = groupData.find(row => 
                        row['Doc No'] && row['Doc No'].includes(extractedDocNo)
                    );
                    if (found) {
                        targetGroup = groupName;
                        console.log(`Found target group: ${targetGroup}`);
                        break;
                    }
                }

                if (!targetGroup) {
                    alert(`ไม่พบ Doc No ${extractedDocNo} ในผลลัพธ์หลัก`);
                    return;
                }

                // Check if file with same name already exists in the uploaded files list
                const existingFileItems = uploadedFilesContainer.querySelectorAll('.uploaded-file-item');
                let existingFileItem = null;
                
                existingFileItems.forEach(item => {
                    const fileNameSpan = item.querySelector('.uploaded-file-name');
                    if (fileNameSpan && fileNameSpan.textContent.startsWith(file.name)) {
                        existingFileItem = item;
                    }
                });

                let fileItem;
                if (existingFileItem) {
                    // Update existing file item
                    console.log(`Updating existing file: ${file.name}`);
                    fileItem = existingFileItem;
                    const statusElement = fileItem.querySelector('.uploaded-file-status');
                    statusElement.textContent = 'กำลังอัพเดทข้อมูล...';
                    statusElement.className = 'uploaded-file-status status-processing';
                    
                    // Update the group display in case it changed
                    const fileNameElement = fileItem.querySelector('.uploaded-file-name');
                    fileNameElement.textContent = `${file.name} (${targetGroup})`;
                } else {
                    // Create new file item display
                    console.log(`Adding new file: ${file.name}`);
                    fileItem = document.createElement('div');
                    fileItem.className = 'uploaded-file-item flex justify-between items-center p-3 bg-gray-50 rounded border';
                    fileItem.innerHTML = `
                        <span class="uploaded-file-name">${file.name} (${targetGroup})</span>
                        <span class="uploaded-file-status status-processing">กำลังประมวลผล...</span>
                    `;
                    uploadedFilesContainer.appendChild(fileItem);
                }

                // Process the file with the detected group
                processDetailFile(file, targetGroup, fileItem);
            });
        }

        function showDocDetail(docNo, groupName) {
            // Find the detail data
            const groupDetails = detailFiles[groupName];
            if (!groupDetails) {
                alert('ไม่พบไฟล์รายละเอียดสำหรับกลุ่มนี้');
                return;
            }

            // Find matching doc number
            const matchingDocKey = Object.keys(groupDetails).find(key => docNo.includes(key));
            if (!matchingDocKey) {
                alert(`ไม่พบไฟล์รายละเอียดสำหรับ Doc No: ${docNo}`);
                return;
            }

            const detailData = groupDetails[matchingDocKey];
            showDetailModal(docNo, detailData, groupName);
        }

        function showDetailModal(docNo, detailData, groupName) {
            // Create modal if it doesn't exist
            let modal = document.getElementById('detailModal');
            if (!modal) {
                modal = document.createElement('div');
                modal.id = 'detailModal';
                modal.className = 'modal-overlay';
                modal.innerHTML = `
                    <div class="modal-content">
                        <div class="modal-header">
                            <h3 class="modal-title" id="modalTitle"></h3>
                            <button class="modal-close" onclick="closeDetailModal()">ปิด</button>
                        </div>
                        <div id="modalBody"></div>
                    </div>
                `;
                document.body.appendChild(modal);
            }

            // Check if SOH data is available
            const hasSOHData = sohData && sohData.length > 0;
            
            // Filter to show only rows with negative differences (Diff < 0 only)
            // Also filter out rows where Final OH is 0 or blank when SOH data is available
            // For iCenter group, also filter out SKUs with GLUE or ADHESIVE in SKU Description
            const diffRows = detailData.data.filter(row => {
                const diff = parseFloat(row['Diff']) || 0;
                // Only show negative differences (shortages/undercounts)
                if (diff >= 0) return false;
                
                // If SOH data is available, filter out rows where Final OH is 0, blank, or "-"
                if (hasSOHData) {
                    const finalOH = row['Final OH'];
                    // Check if Final OH is undefined, null, empty, "-", or 0
                    if (finalOH === undefined || finalOH === null || finalOH === '' || finalOH === '-' || parseFloat(finalOH) === 0 || isNaN(parseFloat(finalOH))) {
                        return false;
                    }
                }
                
                // Additional filter for iCenter group: exclude GLUE and ADHESIVE
                if (groupName === 'iCenter') {
                    const skuDesc = (row['SKU Description'] || '').toString().toUpperCase();
                    if (skuDesc.includes('GLUE') || skuDesc.includes('ADHESIVE')) {
                        return false;
                    }
                }
                
                return true;
            });

            // Update modal content
            document.getElementById('modalTitle').textContent = `รายละเอียด ${docNo} - รายการที่มีความแตกต่าง (${diffRows.length} รายการ)${hasSOHData ? ' - รวม SOH' : ''}`;
            
            if (diffRows.length === 0) {
                document.getElementById('modalBody').innerHTML = `
                    <div class="no-data">ไม่พบรายการที่มีความแตกต่าง (Diff = 0 ทั้งหมด)</div>
                `;
            } else {
                // Build table header based on SOH data availability
                let headerHtml = `
                    <table class="data-table sortable-table">
                        <thead>
                            <tr>
                                <th class="sortable" onclick="sortTable(this, 0)">Branch <span class="sort-icon">↕</span></th>
                                <th class="sortable" onclick="sortTable(this, 1)">SKU <span class="sort-icon">↕</span></th>
                                <th class="sortable" onclick="sortTable(this, 2)">SKU Description <span class="sort-icon">↕</span></th>
                                <th class="sortable" onclick="sortTable(this, 3)">OH <span class="sort-icon">↕</span></th>
                                <th class="sortable" onclick="sortTable(this, 4)">Scan <span class="sort-icon">↕</span></th>
                                <th class="sortable" onclick="sortTable(this, 5)">Diff <span class="sort-icon">↕</span></th>
                                <th class="sortable" onclick="sortTable(this, 6)" style="background-color: #fff3cd; color: #856404;">Reason <span class="sort-icon">↕</span></th>`;
                
                if (hasSOHData) {
                    headerHtml += `
                                <th class="sortable" onclick="sortTable(this, 7)" style="background-color: #e8f5e8;">Final OH <span class="sort-icon">↕</span></th>`;
                }
                
                headerHtml += `
                            </tr>
                        </thead>
                        <tbody>
                `;

                let tableHtml = headerHtml;

                diffRows.forEach(row => {
                    const isSOHUpdated = hasSOHData && row['Final OH'] !== undefined;
                    const rowClass = isSOHUpdated ? 'diff-row soh-updated' : 'diff-row';
                    const fullBranchName = getFullBranchName(row['Branch']);
                    
                    tableHtml += `
                        <tr class="${rowClass}">
                            <td>${fullBranchName}</td>
                            <td>${row['SKU']}</td>
                            <td>${row['SKU Description']}</td>
                            <td>${row['OH']}</td>
                            <td>${row['Scan']}</td>
                            <td>${row['Diff']}</td>
                            <td style="background-color: #fffbf0; font-style: ${row['Reason'] ? 'normal' : 'italic'}; color: ${row['Reason'] ? '#856404' : '#9ca3af'};">${row['Reason'] || 'No reason provided'}</td>`;
                    
                    if (hasSOHData) {
                        const finalOH = row['Final OH'] !== undefined ? row['Final OH'] : '-';
                        tableHtml += `
                            <td style="background-color: #f0f8f0; font-weight: ${isSOHUpdated ? 'bold' : 'normal'};">${finalOH}</td>`;
                    }
                    
                    tableHtml += '</tr>';
                });

                tableHtml += '</tbody></table>';
                document.getElementById('modalBody').innerHTML = tableHtml;
            }

            // Show modal
            modal.style.display = 'flex';
        }

        function closeDetailModal() {
            const modal = document.getElementById('detailModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        // Close modal when clicking outside
        document.addEventListener('click', (e) => {
            const modal = document.getElementById('detailModal');
            if (modal && e.target === modal) {
                closeDetailModal();
            }
        });

        // Sortable table functionality
        function sortTable(header, columnIndex) {
            const table = header.closest('table');
            const tbody = table.querySelector('tbody');
            const rows = Array.from(tbody.querySelectorAll('tr'));
            const isAscending = header.classList.contains('sort-asc');
            
            // Clear all sort classes
            table.querySelectorAll('th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
                const icon = th.querySelector('.sort-icon');
                if (icon) icon.className = 'sort-icon';
            });
            
            // Set new sort direction
            if (isAscending) {
                header.classList.add('sort-desc');
                header.querySelector('.sort-icon').className = 'sort-icon desc';
            } else {
                header.classList.add('sort-asc');
                header.querySelector('.sort-icon').className = 'sort-icon asc';
            }
            
            // Sort rows
            rows.sort((a, b) => {
                const aText = a.cells[columnIndex].textContent.trim();
                const bText = b.cells[columnIndex].textContent.trim();
                
                // Try to parse as numbers
                const aNum = parseFloat(aText);
                const bNum = parseFloat(bText);
                
                if (!isNaN(aNum) && !isNaN(bNum)) {
                    return isAscending ? bNum - aNum : aNum - bNum;
                } else {
                    return isAscending ? bText.localeCompare(aText) : aText.localeCompare(bText);
                }
            });
            
            // Reorder DOM
            rows.forEach(row => tbody.appendChild(row));
        }

        // Initialize sortable tables
        function initializeSortableTables() {
            document.querySelectorAll('.sortable-table').forEach(table => {
                // Find branch column and sort by default
                const headers = table.querySelectorAll('th');
                headers.forEach((header, index) => {
                    if (header.textContent.toLowerCase().includes('branch')) {
                        sortTable(header, index);
                    }
                });
            });
        }

        function exportAllGroupData() {
            if (Object.keys(processedData).length === 0) {
                alert('ไม่พบข้อมูลกลุ่ม กรุณาอัพโหลดไฟล์และประมวลผลข้อมูลก่อน');
                return;
            }

            const wb = XLSX.utils.book_new();

            // Create a sheet for each group
            Object.keys(processedData).forEach(groupName => {
                const groupData = processedData[groupName];
                
                if (groupData.length > 0) {
                    // Create clean data for export
                    const exportData = groupData.map(row => ({
                        'Create Date': row['Create Date'] || '',
                        'Doc No': row['Doc No'] || '',
                        'Status': row['Status'] || '',
                        'Branch': getFullBranchName(row['Branch']),
                        'Class': row['Class'] || '',
                        'Check': row['Check'] || '',
                        'Onhand': row['Onhand'] || 0,
                        'Counted': row['Counted'] || 0,
                        'Diff': row['Diff'] || 0
                    }));

                    // Create worksheet for this group
                    const ws = XLSX.utils.json_to_sheet(exportData);
                    
                    // Auto-adjust column widths
                    const wscols = [
                        { wch: 12 }, // Create Date
                        { wch: 16 }, // Doc No
                        { wch: 10 }, // Status
                        { wch: 25 }, // Branch
                        { wch: 20 }, // Class
                        { wch: 12 }, // Check
                        { wch: 10 }, // Onhand
                        { wch: 10 }, // Counted
                        { wch: 10 }  // Diff
                    ];
                    ws['!cols'] = wscols;

                    // Add the worksheet to workbook with safe sheet name
                    const safeGroupName = groupName.replace(/[^a-zA-Z0-9 ]/g, '').substring(0, 30);
                    XLSX.utils.book_append_sheet(wb, ws, safeGroupName);
                } else {
                    // Create empty sheet for groups with no data
                    const emptyData = [{
                        'Message': `No data found for ${groupName}`,
                        'Create Date': '',
                        'Doc No': '',
                        'Status': '',
                        'Branch': '',
                        'Class': '',
                        'Check': '',
                        'Onhand': '',
                        'Counted': '',
                        'Diff': ''
                    }];
                    const ws = XLSX.utils.json_to_sheet(emptyData);
                    const safeGroupName = groupName.replace(/[^a-zA-Z0-9 ]/g, '').substring(0, 30);
                    XLSX.utils.book_append_sheet(wb, ws, safeGroupName);
                }
            });

            // Create a summary sheet with all data combined
            const allData = [];
            Object.keys(processedData).forEach(groupName => {
                processedData[groupName].forEach(row => {
                    allData.push({
                        'Group': groupName,
                        'Create Date': row['Create Date'] || '',
                        'Doc No': row['Doc No'] || '',
                        'Status': row['Status'] || '',
                        'Branch': row['Branch'] || '',
                        'Class': row['Class'] || '',
                        'Check': row['Check'] || '',
                        'Onhand': row['Onhand'] || 0,
                        'Counted': row['Counted'] || 0,
                        'Diff': row['Diff'] || 0
                    });
                });
            });

            if (allData.length > 0) {
                const summaryWs = XLSX.utils.json_to_sheet(allData);
                // Auto-adjust column widths for summary
                const wscols = [
                    { wch: 18 }, // Group
                    { wch: 12 }, // Create Date
                    { wch: 16 }, // Doc No
                    { wch: 10 }, // Status
                    { wch: 25 }, // Branch
                    { wch: 20 }, // Class
                    { wch: 12 }, // Check
                    { wch: 10 }, // Onhand
                    { wch: 10 }, // Counted
                    { wch: 10 }  // Diff
                ];
                summaryWs['!cols'] = wscols;
                XLSX.utils.book_append_sheet(wb, summaryWs, 'All Groups Summary');
            }

            // Save file
            const fileName = `SMCO_All_Groups_Data_${new Date().toISOString().split('T')[0]}.xlsx`;
            XLSX.writeFile(wb, fileName);
        }

    </script>

    <!-- Authentication Scripts -->
    <script>
        // Initialize authentication when page loads
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                // Initialize Firebase
                await SPViAuth.initializeFirebase();
                
                // Check authentication - redirect to login if not authenticated
                const isAuthenticated = await SPViAuth.checkAuthentication();
                if (!isAuthenticated) {
                    window.location.href = '../index.html';
                    return;
                }
                
                // User info will be added automatically by firebase-auth.js init()
                // No need to call addUserInfo() manually
                
                // Setup centralized devtools protection
                SPViAuth.setupDevToolsProtection();

                // Check tool access permission after authentication is confirmed
                if (window.SPViSessionManager && window.SPViSessionManager.checkToolAccess) {
                    const hasAccess = await window.SPViSessionManager.checkToolAccess('smcoCheck');
                    if (!hasAccess) {
                        // Access denied - modal will be shown by checkToolAccess function
                        // Optionally hide main content
                        document.querySelector('main')?.style.setProperty('display', 'none');
                    }
                }
            } catch (error) {
                // Authentication error handled silently for production
                // If authentication fails, redirect to login
                window.location.href = '../index.html';
            }
            
            // Hide loading overlay
            setTimeout(() => {
                document.getElementById('loadingOverlay').style.display = 'none';
            }, 1000);
            
            // Initialize session and auth (fallback)
            if (typeof initializeSession === 'function') {
                initializeSession();
            }
            if (typeof initializeAuth === 'function') {
                initializeAuth();
            }
        });
    </script>

    <style media="print">
        .upload-section, .export-section, nav, #loadingOverlay, .tab-navigation {
            display: none !important;
        }
        
        body {
            background: white !important;
            padding: 1rem !important;
        }
        
        .modal-overlay {
            display: none !important;
        }
        
        .tab-content {
            display: block !important;
        }
        
        main {
            max-width: none !important;
            margin: 0 !important;
            padding: 0 !important;
        }
    </style>
</body>
</html>