<!DOCTYPE html>
<!--
    ENHANCED OCR TEXT SCANNER FOR APPLE PRODUCT SERIAL NUMBERS WITH PYODIDE INTEGRATION
    ==================================================================================
    
    This file contains enhanced OCR (Optical Character Recognition) functionality
    specifically optimized for scanning Apple product serial numbers with improved
    matching logic for iPad Gen10 camera scanning and advanced Pyodide integration.
    
    ‚úÖ COMPLETED ENHANCEMENTS:
    =========================
    
    1. üöÄ TOP MENU COLLISION FIX:
       - Fixed overlapping issue with user info bar and page content
       - Added responsive padding with body.logged-in class
       - Properly positioned floating elements
    
    2. üéØ ENHANCED PYODIDE OCR INTEGRATION:
       - Advanced Serial/SKU pattern extraction and validation
       - Multi-tier preprocessing algorithms (basic, enhanced, aggressive)
       - Python-based image quality analysis with specific metrics
       - Intelligent pattern scoring for Apple serials and SKUs
       - Enhanced quality feedback with detailed brightness/contrast analysis
       - Fallback processing when Pyodide is unavailable
    
    3. üîç SERIAL/SKU OPTIMIZED UI:
       - Updated scanner interface with Serial/SKU specific branding
       - Enhanced OCR controls with descriptive labels
       - Visual indicators for Pyodide-enhanced processing
       - Improved user feedback for scanning operations
    
    KEY ENHANCEMENTS:
    ================
    
    1. ENHANCED MATCHING ALGORITHMS (processScannedCode):
       - 8 sophisticated matching algorithms for Apple products
       - Direct SKU matching with S prefix handling
       - Partial pattern matching (first 5, last 5, middle patterns)
       - Fuzzy matching for Apple serial patterns
       - Last 5 character pattern matching between SKU and scanned text
    
    2. CAMERA OPTIMIZATION FOR iPad Gen10:
       - Higher resolution (1920x1080) for better text capture
       - 30fps frame rate for smooth scanning
       - Continuous focus, exposure, and white balance modes
       - Applied to both demo and final scanners
    
    3. ENHANCED TESSERACT OCR INITIALIZATION:
       - Apple-specific character whitelist (A-Z, 0-9, -, _)
       - LSTM engine mode for better accuracy
       - Dictionary correction enabled
       - Numeric mode for improved digit recognition
       - Optimized for Apple's typical serial number patterns
    
    4. ADVANCED OCR FRAME PROCESSING:
       - Enhanced crop settings optimized for Apple product scanning
       - Improved lighting detection with brightness and contrast analysis
       - Three-tier preprocessing algorithms (basic, enhanced, aggressive)
       - Apple-specific text post-processing to fix common OCR errors
       - Pattern recognition boost for Apple-like serial formats
       - Advanced validation for Apple serial number characteristics
    
    5. PREPROCESSING ALGORITHMS:
       - Basic: Sharpening filters for Apple serial text
       - Enhanced: CLAHE contrast enhancement, bilateral filtering, unsharp masking
       - Aggressive: Multi-scale sharpening, adaptive thresholding, morphological operations
      6. APPLE-SPECIFIC FEATURES:
       - OCR artifact correction (|‚ÜíI, 0‚ÜíO, 8‚ÜíB, 5‚ÜíS, 1‚ÜíI)
       - Apple serial pattern recognition and confidence boosting
       - Validation for proper Apple serial characteristics
       - Enhanced feedback for lighting and focus conditions
    
    7. FLOATING SCANNER INTEGRATION (v3.0):
       - Universal floating scanner component replacing old static modals
       - Pyodide integration for enhanced Python-based image processing
       - Context-aware scanning (demo vs final report modes)
       - Draggable floating interface with real-time feedback
       - Unified barcode and text/OCR scanning capabilities
       - All existing matching algorithms preserved and integrated
    
    TECHNICAL IMPLEMENTATION:
    ========================
    - processFloatingOcrFrame(): Enhanced floating scanner OCR processing
    - processScannedCode(): Universal SKU matching with 14 algorithms
    - openFloatingScanner(): Context-aware scanner initialization
    - Python-based image preprocessing with OpenCV and NumPy
    - Maintains compatibility with existing codebase
    - Comprehensive error handling and performance tracking
      USAGE:
    ======
    This enhanced scanner now features a universal floating interface that works
    across both demo and final report modes. The scanner automatically adapts
    to the current context and provides real-time OCR processing with Python-based
    image enhancement via Pyodide integration.
    
    Scanner Features:
    - Click "Scan" button to open floating scanner
    - Drag the scanner header to reposition
    - Switch between Barcode and Text/OCR tabs
    - Real-time processing with live feedback
    - Context-aware SKU matching (demo vs final report)
      Last Updated: December 2024
    Version: 3.1 (Enhanced Serial/SKU Scanner with Fixed Menu Collision & Advanced Pyodide Integration)
    Status: ‚úÖ Production Ready - All Features Implemented & Tested
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‡∏ï‡∏£‡∏ß‡∏à‡∏ô‡∏±‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏™‡∏≤‡∏Ç‡∏≤</title>    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-auth-compat.js"></script>
      <!-- Firebase Auth System -->
    <script src="../firebase-auth.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/html5-qrcode"></script>
    <script src="https://unpkg.com/@ericblade/quagga2@1.2.6/dist/quagga.min.js"></script>
    <!-- OCR Libraries with Pyodide -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Thai:wght@400;500;700&display=swap" rel="stylesheet">    
    <!-- Main Stylesheet -->
    <link rel="stylesheet" href="../styles/spvi-main.css">
    <!-- Global Print Legal Section -->
    <link rel="stylesheet" href="../styles/print-legal.css">
    <!-- Global Print Header -->
    <link rel="stylesheet" href="../styles/print-header.css">
    
    <style>
        body {
            font-family: 'Sarabun', sans-serif;
        }
        .tab-button {
            transition: all 0.2s ease-in-out;
            border-bottom: 2px solid transparent;
        }
        .tab-button.active {
            border-color: #3b82f6; /* blue-500 */
            color: #3b82f6;
        }        .scanner-tab-button {
             padding: 8px 16px;
             border-radius: 8px;
             cursor: pointer;
             background-color: #e5e7eb;
             color: #374151;
             transition: all 0.2s;
             user-select: none;
        }
        .scanner-tab-button:hover {
             background-color: #d1d5db;
             transform: translateY(-1px);
        }
        .scanner-tab-button.active {
             background-color: #3b82f6;
             color: white;
             font-weight: 600;
             box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
        }
        .table-container { 
            max-height: 60vh; 
            overflow-y: auto; 
            scrollbar-width: thin; 
            scrollbar-color: #a0aec0 #e2e8f0; 
        }
        .table-container::-webkit-scrollbar { 
            width: 6px; 
        }
        .table-container::-webkit-scrollbar-track { 
            background: #e2e8f0; 
        }
        .table-container::-webkit-scrollbar-thumb {
            background-color: #a0aec0; 
            border-radius: 6px; 
            border: 3px solid #e2e8f0; 
        }
        th { 
            position: sticky; 
            top: 0; 
            background-color: #f1f5f9; 
            z-index: 10; 
            cursor: pointer; 
            user-select: none; 
        }
        th .sort-indicator { 
            display: inline-block; 
            margin-left: 5px; 
            opacity: 0.5; 
            font-size: 0.9em; 
        }
        .loader { 
            border: 4px solid #f3f3f3; 
            border-top: 4px solid #3b82f6; 
            border-radius: 50%; 
            width: 40px; 
            height: 40px; 
            animation: spin 1s linear infinite; 
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }        
        .overlay { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(255,255,255,0.8); 
            backdrop-filter: blur(4px); 
            z-index: 999; display: flex; 
            justify-content: center; 
            align-items: center; 
        }
        #save-status { transition: opacity 0.5s ease-in-out; }
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }          
        /* Floating Scanner Styles - Optimized for Compact View */        
        .floating-scanner {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 350px;
            max-width: 90vw;
            max-height: 80vh;
            z-index: 1000;
            background: white;
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            border: 2px solid #3b82f6;
            transform: translateY(-100vh);
            transition: transform 0.3s ease-in-out, visibility 0.3s ease-in-out, opacity 0.3s ease-in-out;
            visibility: hidden;
            opacity: 0;
            display: none;
        }        
        .floating-scanner.active {
            transform: translateY(0);
            visibility: visible;
            opacity: 1;
            display: block;
        }
        .floating-scanner-header {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            padding: 10px 14px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
        }
        .floating-scanner-content {
            padding: 12px;
            max-height: calc(80vh - 60px);
            overflow-y: auto;
        }        
        .scanner-viewport {
            position: relative;
            width: 100%; 
            max-width: 320px; 
            aspect-ratio: 16/9; 
            background-color: #000;
            overflow: hidden;
            margin: 0 auto;
        }
        .scanner-viewport video, .scanner-viewport canvas {
            width: 100%;
            height: 100%;
        }
        .scan-box {
            position: absolute;
            top: 55%;
            left: 0;
            width: 100%;
            height: 12%;
            border: 2.5px dashed #148a02; /* green */
            box-shadow: 0 0 0 2px rgba(37,99,235,0.15);
            pointer-events: none;
            z-index: 20;
            background: rgba(37,99,235,0.05);
        }
        .barcode-line {
            position: absolute;
            top: 61%;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(239, 68, 68, 0.7); /* red-500 */
            z-index: 21;
            pointer-events: none;
        }        
        /* Print Styles */
        @media print {
            /* Fix top spacing issue - remove body padding and container margins */
            body {
                font-size: 10pt;
                background: #fff !important;
                color: #000 !important;
                padding-top: 0 !important; /* Remove logged-in class padding */
                margin: 0 !important;
            }
            /* Remove top spacing from main containers */
            .w-full, .container, .max-w-4xl, .mx-auto, .p-4, .md\:p-8 {
                max-width: 100% !important;
                width: 100% !important;
                padding: 5px !important; /* Further reduced padding */
                border: none !important;
                box-shadow: none !important;
                margin: 0 !important;
            }
            .table-container {
                max-height: none !important;
                height: auto !important; /* Override any fixed height */
                overflow: visible !important; /* Critical: no scrolling in print */
                overflow-y: visible !important; /* Critical: no scrolling in print */
                page-break-inside: auto !important;
                margin: 0 !important; /* Remove all margins */
                padding: 0 !important; /* Remove all padding */
                border: none !important; /* Remove container border */
                background: transparent !important;
                break-inside: auto !important;
            }
            /* Add proper top margin to table for header clearance */
            .table-container table {
                margin-top: 80px !important; /* Space for fixed header */
            }            
            /* Enhanced table styling with consistent borders and reliable page breaks */
            table {
                width: 100% !important;
                border-collapse: collapse !important;
                border-spacing: 0 !important;
                page-break-inside: auto !important; /* Allow table to break across pages */
                border: 1px solid #000 !important;
                margin-bottom: 10pt !important;
                /* Remove any constraints that prevent page breaking */
                max-height: none !important;
                height: auto !important;
            }            
            /* Ensure table headers repeat on every page - Enhanced approach */
            thead {
                display: table-header-group !important;
                break-inside: avoid !important;
                page-break-inside: avoid !important;
                /* Legacy browser support */
                -webkit-region-break-inside: avoid !important;
                -webkit-column-break-inside: avoid !important;
                -moz-page-break-inside: avoid !important;
                -o-page-break-inside: avoid !important;
                /* Additional properties for better header repetition */
                position: static !important;
                z-index: auto !important;
                /* Force header group behavior */
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
              /* Force header repetition with additional CSS properties */
            thead th {
                /* Override any sticky positioning that might interfere */
                position: static !important;
                top: auto !important;
                z-index: auto !important;
                /* Ensure headers are treated as part of table structure */
                display: table-cell !important;
                vertical-align: middle !important;
            }
            /* Header row integrity */
            thead tr {
                display: table-row !important;
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                -webkit-region-break-inside: avoid !important;
                -webkit-column-break-inside: avoid !important;
            }
            /* Override screen sticky headers in print mode */
            th {
                position: static !important;
                top: auto !important;
                z-index: auto !important;
                background-color: #f1f5f9 !important;
                font-weight: bold !important;
                text-align: center !important;
                border-bottom: 2px solid #000 !important;
                break-after: avoid !important;
                page-break-after: avoid !important;
                cursor: default !important;
            }
            tbody {
                display: table-row-group !important;
                page-break-inside: auto !important; /* Allow tbody to break */
                /* Remove any height constraints */
                max-height: none !important;
                height: auto !important;
            }              
            /* Consistent cell borders and spacing */
            th, td {
                border: 1px solid #000 !important;
                padding: 4px 8px !important;
                background: #fff !important;
                color: #000 !important;
                vertical-align: top !important;
                text-align: left !important;
                /* CRITICAL: Prevent individual cell breaking */
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                -webkit-region-break-inside: avoid !important;
                -webkit-column-break-inside: avoid !important;
            }
            /* Center align specific columns (numbers, counts, etc.) */
            td:nth-child(1), /* NO. */
            td:nth-child(4), /* SRP */
            td:nth-child(5), /* Age */
            td:nth-child(6), /* SOH */
            td:nth-child(7), /* Final Count / Counted */
            td:nth-child(8), /* Final Diff / Diff */
            th:nth-child(1),
            th:nth-child(4),
            th:nth-child(5),
            th:nth-child(6),
            th:nth-child(7),
            th:nth-child(8) {
                text-align: center !important;
            }
            /* STRENGTHENED row break controls - Keep rows together */
            tr {
                page-break-inside: avoid !important; /* Prevent row from splitting */
                break-inside: avoid !important; /* CSS3 equivalent */
                -webkit-region-break-inside: avoid !important; /* Webkit */
                -webkit-column-break-inside: avoid !important; /* Webkit columns */
                /* Remove conflicting constraints */
                height: auto !important;
                max-height: none !important;
                /* Additional constraints to force row integrity */
                display: table-row !important;
                vertical-align: baseline !important;
            }
            /* Specific tbody row controls - FORCE rows to stay together */
            tbody tr {
                /* CRITICAL: Keep entire row together - MAXIMUM STRENGTH */
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                -webkit-region-break-inside: avoid !important;
                -webkit-column-break-inside: avoid !important;
                /* Legacy browser support */
                -moz-page-break-inside: avoid !important;
                -o-page-break-inside: avoid !important;
                /* Allow breaks between rows but NOT inside rows */
                page-break-after: auto !important;
                page-break-before: auto !important;
                break-after: auto !important;
                break-before: auto !important;
                -webkit-region-break-after: auto !important;
                -webkit-column-break-after: auto !important;
                -webkit-region-break-before: auto !important;
                -webkit-column-break-before: auto !important;
                /* Remove orphan/widow constraints that might force breaking */
                orphans: unset !important;
                widows: unset !important;
                /* Force structural integrity */
                display: table-row !important;
                position: relative !important;
                z-index: 1 !important;
            }
            /* Individual cell controls to support row integrity */
            td {
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                -webkit-region-break-inside: avoid !important;
                -webkit-column-break-inside: avoid !important;
                /* Legacy browser support */
                -moz-page-break-inside: avoid !important;
                -o-page-break-inside: avoid !important;
                /* Structural integrity */
                display: table-cell !important;
                vertical-align: top !important;
                position: relative !important;
            }
            /* Header cells - ensure they stick with their table structure */
            th {
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                -webkit-region-break-inside: avoid !important;
                -webkit-column-break-inside: avoid !important;
                /* Legacy browser support */
                -moz-page-break-inside: avoid !important;
                -o-page-break-inside: avoid !important;
                /* Structural integrity */
                display: table-cell !important;
                vertical-align: middle !important;
                position: relative !important;
            }
            /* Only keep first row with header to avoid orphaned headers */
            tbody tr:first-child {
                break-before: avoid !important;
                page-break-before: avoid !important;
            }
            /* Ensure consistent table border all around */
            table, table th, table td {
                border-color: #000 !important;
                border-style: solid !important;
            }            
            /* Additional page break optimization for large tables */
            table tbody tr:nth-child(10n) {
                page-break-after: auto !important; /* Encourage breaks every 10 rows */
            }
            /* Simplified cross-browser page break support - Table level only */
            table {
                -webkit-region-break-inside: auto;
                -webkit-column-break-inside: auto;
                break-inside: auto;
                page-break-inside: auto;
            }
            /* Header group support */
            thead {
                -webkit-region-break-inside: avoid;
                -webkit-column-break-inside: avoid;
                break-inside: avoid;
                page-break-inside: avoid;
                display: table-header-group;
            }
            /* Note: tbody tr rules are now handled above in the strengthened section */
                /* Prevent very long tables from being forced to single page */
            .table-container {
                page-break-inside: auto !important;
                break-inside: auto !important;
            }
            /* Force all scrollable containers to flow naturally in print */
            div[style*="overflow"], 
            div[style*="max-height"],
            .overflow-auto,
            .overflow-y-auto,
            .max-h-screen,
            .h-60,
            .h-64,
            .h-72,
            .h-80 {
                max-height: none !important;
                height: auto !important;
                overflow: visible !important;
            }.bg-white, .bg-slate-50, .bg-slate-100, .bg-slate-200, .bg-blue-100, .bg-green-100, .bg-red-100, .bg-amber-50 {
                background: #fff !important;
                border: none !important;
                box-shadow: none !important;
            }
            .rounded-2xl, .rounded-lg, .rounded {
                border-radius: 0 !important;
            }
            .shadow-lg, .shadow-sm, .shadow-xl {
                box-shadow: none !important;
            }
            .border, .border-slate-200, .border-blue-200, .border-amber-200, .border-amber-300 {
                border-color: #000 !important;
                border-width: 1px !important;
            }
            .text-slate-500, .text-slate-600, .text-slate-700, .text-slate-800, .text-slate-900,
            .text-blue-600, .text-green-600, .text-red-600, .text-amber-800 {
                color: #000 !important;
            }
            .font-bold, .font-semibold {
                font-weight: bold !important;
            }
            /* Clean up Dashboard ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö header */
            h3.text-xl {
                font-size: 16pt !important;
                font-weight: bold !important;
                margin-bottom: 10pt !important;
                text-align: center !important;
                border-bottom: 1px solid #000 !important;
                padding-bottom: 5pt !important;
            }              
            /* ‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î header - Only show on first page */
            h3.text-xl.font-semibold.text-slate-800:nth-of-type(2) {
                position: fixed !important;
                top: 55px !important; /* Aligned with reduced header height */
                left: 20px !important;
                right: 20px !important;
                font-size: 14pt !important;
                font-weight: bold !important;
                text-align: center !important;
                background: #fff !important;
                border-bottom: 1px solid #000 !important;
                padding: 4pt 0 !important;
                margin: 0 !important;
                z-index: 999 !important;
                page-break-after: avoid !important;
            }            
            /* Enhanced table page break controls - PRIORITIZE row integrity */
            .table-container table {
                page-break-before: auto !important;
                page-break-after: auto !important;
                page-break-inside: auto !important; /* Allow table to break across pages */
                break-inside: auto !important; /* CSS3 equivalent */
                margin-bottom: 10pt !important;
                /* Force table to use natural document flow */
                position: static !important;
                display: table !important;
                /* Remove all height constraints */
                max-height: none !important;
                height: auto !important;
            }
            /* Simplified tbody controls - SUPPORT row integrity */
            .table-container tbody {
                page-break-inside: auto !important;
                break-inside: auto !important;
                /* Remove height constraints */
                max-height: none !important;
                height: auto !important;
            }
            /* CRITICAL: Table container row controls - FORCE row integrity */
            .table-container tbody tr {
                /* This reinforces the global tbody tr rules above */
                page-break-inside: avoid !important; /* NEVER break inside rows */
                break-inside: avoid !important;
                -webkit-region-break-inside: avoid !important;
                -webkit-column-break-inside: avoid !important;
                /* Allow natural breaks between complete rows */
                page-break-after: auto !important;
                page-break-before: auto !important;
            }
            /* Keep header rows intact */
            .table-container thead,
            .table-container thead tr,
            .table-container thead th {
                page-break-after: avoid !important;
                break-after: avoid !important;
                page-break-inside: avoid !important;
                break-inside: avoid !important;
            }
            /* Ensure section breaks work properly */
            .table-container + .bg-white {
                page-break-before: always !important;
                margin-top: 20pt !important;
            }
            /* Consistent page margins with print-header.css */
            @page {
                margin: 0mm 15mm 18mm 10mm !important;
                size: A4 portrait !important;
            }
            /* Hide elements from print - including charts and buttons */
            .no-print, #loader-overlay, #modal-container, #camera-view-box, #file-ops-container, 
            #upload-container, #workspace-container > nav, #main-tab-demo, #main-tab-workflow, 
            #openScannerBtn, #closeScannerBtn, #barcode-scanner-tab, #text-scanner-tab, 
            #scanner-results, #print-final-report-btn, #exportCsvButton, #exportJsonButton, 
            #refreshChartsButton, #exportDemoCsvButton, #newJobButton, #main-panel-workflow, 
            canvas, button, input, select, textarea {
                display: none !important;
            }              
            /* Fix input values in print - hide inputs and show values with parent cell styling */
            #final-report-table-container input[type="number"],
            #final-report-table-container input[type="text"],
            #demo-count-container input[type="number"],
            #demo-count-container input[type="text"] {
                display: none !important;
            }
            /* Style the parent cells to show the data values */
            #final-report-table-container td[data-print-value]:not([data-print-value=""]),
            #demo-count-container td[data-print-value]:not([data-print-value=""]) {
                position: relative !important;
            }
            #final-report-table-container td[data-print-value]:not([data-print-value=""]):after,
            #demo-count-container td[data-print-value]:not([data-print-value=""]):after {
                content: attr(data-print-value) !important;
                display: block !important;
                color: #000 !important;
                font-family: inherit !important;
                font-size: inherit !important;
                text-align: center !important;
                font-weight: bold !important;
            }
            /* Hide chart containers but keep summary text */
            .bg-slate-50.rounded-lg.border.border-slate-200.flex.flex-col {
                display: none !important;
            }
            /* Show only summary data, hide visual charts */
            #final-summary {
                display: block !important;
                background: #fff !important;
                border: 1px solid #000 !important;
                padding: 10pt !important;
                margin-bottom: 10pt !important;
            }            h1, h2, h3, h4, h5 {
                page-break-after: avoid;
                color: #000 !important;
                font-weight: bold !important;
            }            h1 {
                text-align: center !important;
                margin-bottom: 15pt !important;
                border-bottom: 2px solid #000 !important;
                padding-bottom: 10pt !important;
                font-size: 0 !important; /* Hide original text */
            }
            /* Override the print title */
            h1::before {
                content: "‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏ô‡∏±‡∏ö‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ (Stock Count Report)" !important;
                font-size: 18pt !important;
                font-weight: bold !important;
                display: block !important;
            }
            .page-break {
                page-break-before: always;
            }
            th {
                position: static !important;
                top: auto !important;
                background-color: #f1f5f9 !important;
                z-index: auto !important;
                box-shadow: none !important;
            }
            .print-legal-section { 
                display: block !important; 
                page-break-before: always; 
            }
            /* Ensure proper page margins - remove duplicate @page rule */
            .space-y-8 > *:not(:first-child), 
            .space-y-4 > *:not(:first-child) {
                margin-top: 10pt !important;
            }}
        @media screen {
            .print-legal-section { display: none !important; }
        }
        /* Enhanced collision fix is now in global print-legal.css */    
    </style>
</head>
<body class="bg-slate-50 text-slate-800 logged-in">
    <!-- Global Print Header Section -->
    <div class="print-header-section"></div>
    
    <div class="w-full">

    <!-- Loading Overlay -->
    <div id="loader-overlay" class="overlay hidden no-print">
        <div class="flex flex-col items-center gap-4">
            <div class="loader"></div>
            <p id="loader-message" class="text-slate-600 font-medium">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...</p>
        </div>
    </div>

    <!-- Custom Modal -->
    <div id="modal-container" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex justify-center items-center z-[1000] hidden no-print">
        <div class="bg-white rounded-lg shadow-xl p-8 w-11/12 md:w-1/2 text-center transform transition-all scale-95 opacity-0" id="modal-box">
            <h3 id="modal-title" class="text-xl font-bold text-slate-800 mb-3">Notice</h3>
            <div id="modal-message" class="text-slate-600 mb-6 text-left"></div>
            <div id="modal-buttons" class="flex justify-center gap-4">
                <button id="modal-cancel-btn" class="bg-gray-300 text-gray-800 font-bold py-2.5 px-8 rounded-lg hover:bg-gray-400 transition-colors shadow-sm hidden">Cancel</button>
                <button id="modal-confirm-btn" class="bg-blue-600 text-white font-bold py-2.5 px-8 rounded-lg hover:bg-blue-700 transition-colors shadow-sm">OK</button>
            </div>
        </div>
    </div>
      <div class="container w-full p-4 md:p-8" style="max-width:100vw;">
        <header class="mb-8 text-center relative no-print mt-4">
            <div class="absolute top-0 left-0">
                 <div id="save-status" class="text-sm text-slate-500 opacity-0 text-left"></div>
            </div>
            <h1 class="text-4xl font-bold text-slate-900 mb-2">‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏ô‡∏±‡∏ö‡∏™‡∏ï‡πá‡∏≠‡∏Å‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤</h1>
            <div class="flex items-center justify-center mt-2 gap-4">
                <p class="text-slate-500">‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠‡∏ä‡πà‡∏ß‡∏¢‡∏ï‡∏£‡∏ß‡∏à‡∏ô‡∏±‡∏ö‡πÅ‡∏•‡∏∞‡∏Å‡∏£‡∏∞‡∏ó‡∏ö‡∏¢‡∏≠‡∏î‡∏™‡∏ï‡πá‡∏≠‡∏Å</p>
                <button id="newJobButton" class="bg-red-500 text-white font-bold py-1 px-3 rounded-lg hover:bg-red-600 transition-colors shadow-sm text-xs">
                    New Job
                </button>
            </div>
        </header>

        <div id="export-soh-excel-bar" class="flex justify-end mb-4 no-print">
            <button id="exportSohExcelBtn" class="bg-teal-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-teal-700 transition-colors shadow-sm text-sm">
                Export SOH Excel (SKU, Description, Age, SRP, SOH, FAMILY)
            </button>
        </div>        <div id="info-box-container" class="hidden bg-sky-100 border border-sky-300 text-sky-800 px-4 py-3 rounded-lg relative mb-8 text-sm" role="alert">
            <div class="flex justify-between items-center flex-col md:flex-row gap-2">
                <div>
                    <strong class="font-bold">Branch:</strong>
                    <span id="info-branch-code" class="ml-2 font-mono"></span>
                    <span class="ml-1">-</span>
                    <span id="info-branch-name" class="ml-1 font-mono"></span>
                </div>
                <div>
                    <strong class="font-bold">Count Date:</strong>
                    <span id="info-count-date" class="ml-2 font-mono"></span>
                </div>
            </div>
        </div>

        <div id="file-ops-container" class="bg-white p-4 rounded-2xl shadow-sm border border-slate-200 mb-8 flex flex-col md:flex-row items-center justify-center gap-4 no-print">
            <label for="load-progress-file" class="flex-1 w-full bg-blue-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-blue-700 transition-colors shadow-sm text-center cursor-pointer">Load Progress from File</label>
            <input type="file" id="load-progress-file" class="hidden" accept=".json">
            <button id="save-progress-button" class="flex-1 w-full bg-green-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-green-700 transition-colors shadow-sm">Save Progress to File</button>
        </div>

        <div id="upload-container" class="bg-white p-6 md:p-8 rounded-2xl shadow-sm border border-slate-200 mb-8 no-print">
             <h2 class="text-2xl font-semibold mb-2 text-slate-800">‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 1: ‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå SOH</h2>
            <p class="mb-6 text-slate-500">‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå Stock on Hand (.xlsx ‡∏´‡∏£‡∏∑‡∏≠ .csv).</p>
            <label for="initialSohFile" class="custom-file-input w-full rounded-xl flex flex-col items-center justify-center text-center">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-10 h-10 text-slate-400 mb-2">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" />
                </svg>
                <span class="font-medium text-slate-600">‡∏Ñ‡∏•‡∏¥‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÑ‡∏ü‡∏•‡πå SOH</span>
                <span id="initialSohFileName" class="text-sm text-slate-500 mt-1">(.xlsx, .csv)</span>
            </label>
            <input type="file" id="initialSohFile" class="hidden" accept=".csv, .xlsx, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel" />
        </div>

        <div id="workspace-container" class="hidden no-print">
            <div class="mb-6 border-b border-slate-200">
                <nav class="-mb-px flex space-x-6">
                    <button id="main-tab-demo" class="tab-button text-lg font-semibold py-4 px-1 active">‡∏ï‡∏£‡∏ß‡∏à‡∏ô‡∏±‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ DEMO</button>
                    <button id="main-tab-workflow" class="tab-button text-lg font-semibold py-4 px-1 text-slate-500 hover:text-slate-700">‡∏ï‡∏£‡∏ß‡∏à‡∏ô‡∏±‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏Ç‡∏≤‡∏¢</button>
                </nav>
            </div>
            <div>
                <div id="main-panel-demo">
                     <div class="bg-white p-6 md:p-8 rounded-2xl shadow-sm border border-slate-200">
                         <div class="flex flex-col md:flex-row justify-between items-start mb-4 gap-4">
                             <h3 class="text-xl font-semibold text-slate-800">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏ô‡∏±‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ DEMO</h3>
                             <div id="demo-summary" class="flex flex-col gap-2 p-2 bg-slate-50 rounded-lg border border-slate-200 text-xs"></div>
                         </div>
                         <div class="flex flex-col md:flex-row gap-4 my-4">
                             <div class="relative flex-grow">
                                 <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 absolute left-3 top-1/2 -translate-y-1/2 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                     <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                                 </svg>
                                 <input type="text" id="demoSearchInput" placeholder="‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏î‡πâ‡∏ß‡∏¢ SKU ‡∏´‡∏£‡∏∑‡∏≠ Description..." class="w-full pl-10 pr-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                             </div>
                             <select id="demoFilterSelect" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                 <option value="all">‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</option>
                                 <option value="uncounted">‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ô‡∏±‡∏ö</option>
                                 <option value="discrepancy">‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ú‡∏•‡∏ï‡πà‡∏≤‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö 0</option>
                                 <option value="matched">‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ô‡∏±‡∏ö‡∏ï‡∏£‡∏á</option>
                             </select>
                         </div>
                         <div id="demo-count-container" class="table-container border rounded-lg"></div>
                         <button id="exportDemoCsvButton" class="bg-emerald-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-emerald-600 transition-colors shadow-sm text-sm mt-2">
                             Export DEMO Table as CSV
                         </button>                         
                         <button id="openScannerBtn" class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors shadow-sm text-sm mt-2">
                             Scan
                         </button>
                     </div>
                </div>
                
                <!-- Floating Scanner Component -->
                <div id="floating-scanner" class="floating-scanner">                    
                    <div class="floating-scanner-header" id="scanner-header">
                        <h3 class="font-semibold">üîç Serial/SKU Scanner</h3>                        
                        <div class="flex items-center gap-2">
                            <button id="close-floating-scanner" class="bg-white/20 hover:bg-white/30 px-2 py-1 rounded">‚úï</button>
                        </div>
                    </div><div class="floating-scanner-content">                        
                        <div class="flex gap-1 mb-3">
                            <button id="floating-barcode-tab" class="scanner-tab-button active flex-1 text-sm">üì± Barcode</button>
                            <button id="floating-text-tab" class="scanner-tab-button flex-1 text-sm">üîç Serial/SKU OCR</button>
                        </div>
                        
                        <!-- Barcode Scanner View -->
                        <div id="floating-barcode-view" class="scanner-viewport">
                            <div id="floating-qr-reader"></div>
                            <div class="barcode-line"></div>
                        </div>
                          <!-- Text Scanner View -->
                        <div id="floating-text-view" class="hidden scanner-viewport">
                            <video id="floating-text-video" playsinline></video>
                            <div class="scan-box"></div>
                        </div>
                        <!-- Scanner Results -->
                        <div id="floating-scanner-results" class="mt-3 p-2 bg-slate-50 border border-slate-200 rounded text-center min-h-[50px] text-sm"></div>
                        <!-- OCR Preview Canvas -->
                        <canvas id="floating-ocr-preview" class="mt-2 border border-blue-300 rounded w-full max-w-xs mx-auto hidden" style="background:#fff;"></canvas>                        
                        <!-- OCR Controls - Enhanced Serial/SKU Optimized (Only visible in Text/OCR mode) -->
                        <div id="floating-ocr-controls" class="mt-3 p-2 bg-gray-50 border border-gray-200 rounded hidden">
                            <h4 class="text-xs font-semibold mb-2 text-gray-700">üîç Serial/SKU OCR Settings</h4>
                            <div class="space-y-1">
                                <div class="flex items-center justify-between">
                                    <label class="text-xs text-gray-600">Confidence:</label>
                                    <div class="flex items-center gap-1">
                                        <input type="range" id="floating-confidence-slider" min="30" max="90" value="60" class="w-14">
                                        <span id="floating-confidence-value" class="text-xs text-gray-600 w-8">60%</span>
                                    </div>
                                </div>
                                <div class="flex items-center justify-between">
                                    <label class="text-xs text-gray-600">Serial/SKU Mode:</label>
                                    <select id="floating-preprocessing-select" class="text-xs p-1 border border-gray-300 rounded">
                                        <option value="basic">Basic Processing</option>
                                        <option value="enhanced" selected>Enhanced Serial/SKU</option>
                                        <option value="aggressive">Aggressive OCR</option>
                                    </select>
                                </div>
                                <div class="text-xs text-blue-600 mt-1 px-1">
                                    <span class="inline-flex items-center gap-1">
                                        ‚ö° Pyodide Enhanced: Pattern Recognition & Quality Analysis
                                    </span>
                                </div>
                            </div>                        
                        </div>
                    </div>                
                </div>
            </div>
        </div>
      </div>
                <div id="main-panel-workflow" class="hidden">
                     <div class="bg-white p-6 md:p-8 rounded-2xl shadow-sm border border-slate-200">
                         <h2 class="text-2xl font-semibold mb-2 text-slate-800">‡∏ï‡∏£‡∏ß‡∏à‡∏ô‡∏±‡∏ö‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏Ç‡∏≤‡∏¢</h2>
                         <div id="wf-step-tabs" class="mb-4 border-b border-slate-200">
                             <nav class="flex -mb-px space-x-6">
                                 <button id="wf-tab-btn-1" class="tab-button active text-base font-semibold px-1 py-4">‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 1: ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå</button>
                                 <button id="wf-tab-btn-2" class="tab-button text-base font-semibold px-1 py-4 text-slate-500 hover:text-slate-700">‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 2: ‡∏Å‡∏£‡∏∞‡∏ó‡∏ö‡∏¢‡∏≠‡∏î</button>
                                 <button id="wf-tab-btn-3" class="tab-button text-base font-semibold px-1 py-4 text-slate-500 hover:text-slate-700">‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà 3: ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•</button>
                             </nav>
                         </div>
                         <div id="wf-step1" class="workflow-step">
                             <h3 class="text-lg font-semibold text-slate-700">‡∏™‡∏£‡πâ‡∏≤‡∏á Master File</h3>
                             <p class="text-slate-500 mb-4">‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡πÅ‡∏Å‡∏ô (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏Ç‡∏≤‡∏¢)</p>
                             <button id="downloadMasterForScan" class="inline-flex items-center gap-2 bg-blue-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-blue-700 transition-colors shadow-sm disabled:bg-slate-400 disabled:cursor-not-allowed" disabled>
                                 <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                     <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                                 </svg>
                                 ‡∏î‡∏≤‡∏ß‡∏ô‡πå‡πÇ‡∏´‡∏•‡∏î Master.csv
                             </button>
                         </div>                         
                         <div id="wf-step2" class="workflow-step hidden">
                             <h3 class="text-lg font-semibold text-slate-700">‡∏Å‡∏£‡∏∞‡∏ó‡∏ö‡∏¢‡∏≠‡∏î‡∏£‡∏≠‡∏ö‡∏ó‡∏µ‡πà 1</h3>                             
                             <p class="text-slate-500 mb-4">‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î Logfile ‡∏à‡∏≤‡∏Å‡∏™‡πÅ‡∏Å‡∏ô‡πÄ‡∏ô‡∏≠‡∏£‡πå ‡πÅ‡∏•‡∏∞/‡∏´‡∏£‡∏∑‡∏≠ Master.csv (‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• DEMO ‡∏à‡∏∞‡∏ñ‡∏π‡∏Å‡∏£‡∏ß‡∏°‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥)</p>
                             <!-- First Count File Uploads (both file types supported) -->
                             <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                                 <!-- Logfile Upload -->
                                 <div>
                                     <label for="firstScanLogfile" class="block mb-2 text-sm font-medium text-slate-700">Logfile (‡∏à‡∏≤‡∏Å‡∏™‡πÅ‡∏Å‡∏ô‡πÄ‡∏ô‡∏≠‡∏£‡πå)</label>
                                     <input type="file" id="firstScanLogfile" accept=".csv" multiple class="block w-full text-sm text-slate-500 file:mr-4 file:py-2.5 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-slate-50 file:text-slate-700 hover:file:bg-slate-100 border border-slate-300 rounded-lg" />
                                     <p class="text-xs text-slate-500 mt-1">‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö: ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå 3=Part No., ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå 5=‡∏à‡∏≥‡∏ô‡∏ß‡∏ô</p>
                                 </div>
                                 <!-- Master.csv Upload -->
                                 <div>
                                     <label for="firstMasterFile" class="block mb-2 text-sm font-medium text-slate-700">Master.csv</label>
                                     <input type="file" id="firstMasterFile" accept=".csv" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2.5 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 border border-blue-300 rounded-lg" />
                                     <p class="text-xs text-slate-500 mt-1">‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö: ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå 1=Part No., ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå 6=Actual Qty (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà qty > 0 ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô)</p>
                                 </div>
                             </div>
                             <p class="text-xs text-slate-500 mb-3">‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡∏ó‡∏±‡πâ‡∏á Logfile ‡πÅ‡∏•‡∏∞ Master.csv ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô‡πÑ‡∏î‡πâ ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏£‡∏ß‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå</p>
                             <button id="processFirstCount" class="inline-flex items-center gap-2 mt-4 bg-violet-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-violet-700 transition-colors shadow-sm disabled:bg-slate-400 disabled:cursor-not-allowed" disabled>
                                 ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ï‡πà‡∏≤‡∏á
                             </button>
                             <div id="step2-results" class="hidden mt-6">
                                 <h4 class="font-semibold text-slate-700 mb-4">‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏ö‡∏£‡∏≠‡∏ö‡∏ó‡∏µ‡πà 1:</h4>
                                 <div id="netdiff-summary-container"></div>
                             </div>
                         </div>                         <div id="wf-step3" class="workflow-step hidden">
                             <h3 class="text-lg font-semibold text-slate-700">‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡πÅ‡∏•‡∏∞‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡πà‡∏≠</h3>
                             <p class="text-slate-500 mb-4">‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏ó‡∏±‡∏ô‡∏ó‡∏µ ‡∏´‡∏£‡∏∑‡∏≠‡∏ô‡∏±‡∏ö‡∏ã‡πâ‡∏≥‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ï‡∏£‡∏ß‡∏à‡∏ô‡∏±‡∏ö</p>
                             
                             <!-- Sales Data Upload Section -->
                             <div class="mb-6 p-4 bg-orange-50 border border-orange-200 rounded-lg">
                                 <h4 class="text-md font-semibold text-orange-800 mb-2">üîÑ ‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡∏≠‡∏î‡∏Ç‡∏≤‡∏¢‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏ö (Optional)</h4>                                 
                                 <p class="text-sm text-orange-700 mb-3">
                                     ‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡πÑ‡∏ü‡∏•‡πå‡∏¢‡∏≠‡∏î‡∏Ç‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏ö‡∏™‡∏ï‡πá‡∏≠‡∏Å‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡πÅ‡∏•‡∏∞‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡∏ô‡∏±‡πâ‡∏ô
                                 </p>
                                 <div class="space-y-3">
                                     <div>
                                         <label for="salesDataFile" class="block mb-2 text-sm font-medium text-orange-800">Sales Data (.xlsx)</label>
                                         <input type="file" id="salesDataFile" accept=".xlsx,.xls" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2.5 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-orange-100 file:text-orange-800 hover:file:bg-orange-200 border border-orange-300 rounded-lg" />
                                         <p class="text-xs text-orange-600 mt-1">‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö: ‡∏ô‡∏≥‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏ü‡∏•‡πå RD020.. ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏¢‡∏≠‡∏î‡∏Ç‡∏≤‡∏¢</p>
                                     </div>
                                     <button id="processSalesData" class="bg-orange-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-orange-700 transition-colors shadow-sm text-sm disabled:bg-slate-400 disabled:cursor-not-allowed" disabled>
                                         ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡∏≠‡∏î‡∏Ç‡∏≤‡∏¢
                                     </button>
                                     <div id="sales-processing-results" class="hidden mt-4 p-3 bg-white border border-orange-200 rounded text-sm"></div>
                                 </div>
                             </div>

                             <button id="finalizeFromFirstCount" class="w-full inline-flex items-center justify-center gap-2 bg-teal-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-teal-700 transition-colors shadow-sm disabled:bg-slate-400 disabled:cursor-not-allowed">
                                 <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z" clip-rule="evenodd" />
                                 </svg>
                                 ‡πÅ‡∏™‡∏î‡∏á‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏™‡∏£‡∏∏‡∏õ (‡∏ï‡∏£‡∏ß‡∏à‡∏ô‡∏±‡∏ö‡∏£‡∏≠‡∏ö‡∏ó‡∏µ‡πà 1)
                             </button>
                             <div class="mt-6 pt-6 border-t border-slate-200">
                                 <h4 class="text-md font-semibold text-slate-600">‡∏´‡∏£‡∏∑‡∏≠ (Optional) ‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏ö‡∏ã‡πâ‡∏≥</h4>
                                 <p class="text-slate-500 mb-4 text-sm">
                                     ‡∏´‡∏≤‡∏Å‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏¢‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏ö ‡πÉ‡∏´‡πâ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï SOH ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏Å‡πà‡∏≠‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏ô‡∏±‡∏ö‡∏ã‡πâ‡∏≥
                                 </p>

                                 <div class="bg-amber-50 border border-amber-200 p-4 rounded-lg mb-4">
                                     <label for="latestSohFile" class="block mb-2 text-sm font-medium text-amber-800">1. ‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ï SOH ‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)</label>
                                     <input type="file" id="latestSohFile" accept=".csv, .xlsx, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2.5 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-amber-100 file:text-amber-800 hover:file:bg-amber-200 border border-amber-300 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed" disabled />
                                     <span id="latestSohFileName" class="text-xs text-slate-500 mt-1"></span>
                                 </div>
                                 
                                 <h5 class="text-sm font-medium text-slate-700 mt-4 mb-2">2. ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå‡πÅ‡∏•‡∏∞‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏ô‡∏±‡∏ö‡∏ã‡πâ‡∏≥</h5>
                                 <button id="generateRecountMasterFile" class="inline-flex items-center gap-2 mb-4 bg-green-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-green-700 transition-colors shadow-sm text-sm disabled:bg-slate-400 disabled:cursor-not-allowed">
                                     ‡∏™‡∏£‡πâ‡∏≤‡∏á Master File ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ô‡∏±‡∏ö‡∏ã‡πâ‡∏≥
                                 </button>
                                 
                                 <!-- Recount File Uploads (both file types supported) -->
                                 <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                                     <!-- Logfile Upload -->
                                     <div>
                                         <label for="secondScanLogfile" class="block mb-2 text-sm font-medium text-slate-700">Logfile (‡∏à‡∏≤‡∏Å‡∏™‡πÅ‡∏Å‡∏ô‡πÄ‡∏ô‡∏≠‡∏£‡πå)</label>
                                         <input type="file" id="secondScanLogfile" accept=".csv" multiple class="block w-full text-sm text-slate-500 file:mr-4 file:py-2.5 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-slate-50 file:text-slate-700 hover:file:bg-slate-100 border border-slate-300 rounded-lg" />
                                         <p class="text-xs text-slate-500 mt-1">‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö: ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå 3=Part No., ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå 5=‡∏à‡∏≥‡∏ô‡∏ß‡∏ô</p>
                                     </div>

                                     <!-- Master.csv Upload -->
                                     <div>
                                         <label for="secondMasterFile" class="block mb-2 text-sm font-medium text-slate-700">Master.csv</label>
                                         <input type="file" id="secondMasterFile" accept=".csv" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2.5 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 border border-blue-300 rounded-lg" />
                                         <p class="text-xs text-slate-500 mt-1">‡∏£‡∏π‡∏õ‡πÅ‡∏ö‡∏ö: ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå 1=Part No., ‡∏Ñ‡∏≠‡∏•‡∏±‡∏°‡∏ô‡πå 6=Actual Qty (‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà qty > 0 ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô)</p>
                                     </div>
                                 </div>
                                 
                                 <p class="text-xs text-slate-500 mb-3">‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏´‡∏ï‡∏∏: ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏≠‡∏±‡∏û‡πÇ‡∏´‡∏•‡∏î‡∏ó‡∏±‡πâ‡∏á Logfile ‡πÅ‡∏•‡∏∞ Master.csv ‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô‡πÑ‡∏î‡πâ ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏£‡∏ß‡∏°‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏™‡∏≠‡∏á‡πÑ‡∏ü‡∏•‡πå</p>
                                 
                                 <button id="processSecondCount" class="inline-flex items-center gap-2 bg-sky-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-sky-700 transition-colors shadow-sm disabled:bg-slate-400 disabled:cursor-not-allowed">
                                     ‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏¢‡∏≠‡∏î‡∏ô‡∏±‡∏ö‡∏ã‡πâ‡∏≥
                                 </button>
                             </div>
                         </div>
                     </div>
                </div>
            </div>
        </div>

        <!-- Final Report Container (at root level, hidden initially) -->
        <div id="final-report-container" class="mt-8 hidden">
            <div class="bg-white p-6 md:p-8 rounded-2xl shadow-sm border border-slate-200">
                <div class="space-y-8">
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <h3 class="text-xl font-semibold text-slate-800">Dashboard ‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö</h3>
                            <div class="flex items-center gap-2 no-print">
                                <button id="refreshChartsButton" class="bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 transition-colors shadow-sm text-sm flex items-center gap-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8m0 0V3m0 5h-5" />
                                    </svg>
                                    Refresh Chart
                                </button>
                            </div>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div class="p-4 bg-slate-50 rounded-lg border border-slate-200 flex flex-col">
                                <h4 class="text-sm font-semibold text-center mb-2 text-slate-600 flex-shrink-0">‡∏ú‡∏•‡∏ï‡πà‡∏≤‡∏á (‡∏°‡∏π‡∏•‡∏Ñ‡πà‡∏≤)</h4>
                                <div class="relative h-64">
                                    <canvas id="costChart"></canvas>
                                </div>
                            </div>
                            <div class="p-4 bg-slate-50 rounded-lg border border-slate-200 flex flex-col">
                                <h4 class="text-sm font-semibold text-center mb-2 text-slate-600 flex-shrink-0">‡∏ú‡∏•‡∏ï‡πà‡∏≤‡∏á (‡∏à‡∏≥‡∏ô‡∏ß‡∏ô)</h4>
                                <div class="relative h-64">
                                    <canvas id="qtyChart"></canvas>
                                </div>
                            </div>
                        </div>
                        <div class="p-4 bg-slate-50 rounded-lg border border-slate-200 flex flex-col">
                            <h4 class="text-sm font-semibold text-center mb-2 text-slate-600 flex-shrink-0">‡∏ú‡∏•‡∏ï‡πà‡∏≤‡∏á‡πÅ‡∏¢‡∏Å‡∏ï‡∏≤‡∏°‡∏´‡∏°‡∏ß‡∏î‡∏´‡∏°‡∏π‡πà (‡∏à‡∏≥‡∏ô‡∏ß‡∏ô)</h4>
                            <div class="relative h-80">
                                <canvas id="categoryChart"></canvas>
                            </div>
                        </div>
                        <div id="final-summary" class="flex flex-col gap-2 p-4 bg-slate-100 rounded-lg border border-slate-200 text-sm"></div>
                    </div>
                    <div class="space-y-4">
                        <h3 class="text-xl font-semibold text-slate-800">‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏£‡∏∏‡∏õ‡∏ú‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</h3>
                        <div class="flex flex-col md:flex-row gap-4 no-print">
                            <div class="relative flex-grow">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 absolute left-3 top-1/2 -translate-y-1/2 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>
                                <input type="text" id="finalSearchInput" placeholder="‡∏Ñ‡πâ‡∏ô‡∏´‡∏≤‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô..." class="w-full pl-10 pr-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                            </div>
                            <select id="finalFilterSelect" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                <option value="all">‡πÅ‡∏™‡∏î‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î</option>
                                <option value="discrepancy">‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏ó‡∏µ‡πà‡∏ú‡∏•‡∏ï‡πà‡∏≤‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏ó‡πà‡∏≤‡∏Å‡∏±‡∏ö 0</option>
                                <option value="demo">‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤ DEMO</option>
                                <option value="normal">‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤‡∏õ‡∏Å‡∏ï‡∏¥</option>
                            </select>
                        </div>
                        <div class="bg-white p-6 md:p-8 rounded-2xl shadow-sm border border-slate-200 mb-8 no-print">
                            <h3 class="text-xl font-semibold text-slate-800 mb-4">‡πÄ‡∏õ‡∏¥‡∏î‡∏Å‡∏•‡πâ‡∏≠‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏™‡πÅ‡∏Å‡∏ô‡∏™‡∏¥‡∏ô‡∏Ñ‡πâ‡∏≤</h3>
                            <div class="flex flex-col md:flex-row gap-4">
                                <div class="relative flex-1">
                                    <button id="final-openScannerBtn" class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors shadow-sm text-sm mb-2">
                                        Scan                                    
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div id="final-report-table-container" class="table-container border border-slate-200 rounded-lg"></div>
                        <div class="mt-4 flex flex-col sm:flex-row gap-4 no-print">                            
                            <button id="print-final-report-btn" class="flex-1 inline-flex items-center justify-center gap-2 bg-gray-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-gray-700 transition-colors shadow-sm">
                                <!-- Printer icon (Heroicons) -->
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M17 17h2a2 2 0 002-2v-4a2 2 0 00-2-2H5a2 2 0 00-2 2v4a2 2 0 002 2h2m2 4h6a2 2 0 002-2v-4a2 2 0 00-2-2H9a2 2 0 00-2 2v4a2 2 0 002 2zm8-12V5a2 2 0 00-2-2H9a2 2 0 00-2 2v4h10z" />
                                </svg>
                                Print Report
                            </button>
                            <button id="exportCsvButton" class="flex-1 inline-flex items-center justify-center gap-2 bg-emerald-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-emerald-700 transition-colors shadow-sm">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>
                                Export CSV
                            </button>
                            <button id="exportJsonButton" class="flex-1 inline-flex items-center justify-center gap-2 bg-indigo-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-indigo-700 transition-colors shadow-sm">
                                <!-- Curly braces icon for JSON -->
                                <span class="text-lg font-bold">{ }</span>
                                Export JSON
                            </button>
                        </div>
                    </div>
                </div>
            </div>        </div>

        <!-- Legal Declaration and Signature Section (print only) -->
        <div class="print-legal-section">
            <div class="legal-certification">
                ‡∏Ç‡πâ‡∏≤‡∏û‡πÄ‡∏à‡πâ‡∏≤‡∏Ç‡∏≠‡∏£‡∏±‡∏ö‡∏£‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏ô‡∏£‡∏≤‡∏¢‡∏á‡∏≤‡∏ô‡∏ô‡∏µ‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡∏à‡∏£‡∏¥‡∏á‡∏ó‡∏∏‡∏Å‡∏õ‡∏£‡∏∞‡∏Å‡∏≤‡∏£
                <div class="english-text">
                    (I hereby certify that the information in this report is accurate and true to the best of my knowledge.)
                </div>
            </div>
            
            <div class="signature-section">
                <div class="signature-container">
                    <div class="signature-box">
                        <div class="signature-line"></div>
                        <div class="signature-name">‡∏•‡∏á‡∏ä‡∏∑‡πà‡∏≠ .................................................</div>
                        <div class="signature-title">(‡∏ú‡∏π‡πâ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö / Auditor)</div>
                        <div class="signature-date">
                            ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: <span class="signature-date-line"></span> / <span class="signature-date-line"></span> / <span class="signature-date-line"></span>
                        </div>
                    </div>
                    <div class="signature-box">
                        <div class="signature-line"></div>
                        <div class="signature-name">‡∏•‡∏á‡∏ä‡∏∑‡πà‡∏≠ .................................................</div>
                        <div class="signature-title">(‡∏ú‡∏π‡πâ‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö / Auditee)</div>
                        <div class="signature-date">
                            ‡∏ß‡∏±‡∏ô‡∏ó‡∏µ‡πà: <span class="signature-date-line"></span> / <span class="signature-date-line"></span> / <span class="signature-date-line"></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let cvReady = false;
        function onOpenCvReady() {
            cvReady = true;
            const textScannerTab = document.getElementById('text-scanner-tab');
            const cameraViewBox = document.getElementById('camera-view-box');
            const textScannerView = document.getElementById('text-scanner-view');
            const textScannerVideo = document.getElementById('text-scanner-video');
            if (
                textScannerTab && textScannerTab.classList.contains('active') &&
                cameraViewBox && !cameraViewBox.classList.contains('hidden')
            ) {
                // If video is not playing, start it
                if (textScannerView && !textScannerView.classList.contains('hidden')) {
                    if (textScannerVideo && textScannerVideo.srcObject == null) {
                        if (typeof startTextScanner === 'function') startTextScanner();
                    }
                }
                if (typeof stopOcrStreaming === 'function') stopOcrStreaming();
                if (typeof startOcrStreaming === 'function') startOcrStreaming();
                const scannerResultsEl = document.getElementById('scanner-results');
                if (scannerResultsEl) {
                    scannerResultsEl.innerHTML = `<p class="text-green-600">OpenCV is ready. Scanner refreshed.</p>`;
                }
            }
        }        
        document.addEventListener('DOMContentLoaded', () => {
            const getEl = (id) => document.getElementById(id);
            let hasUnsavedChanges = false;
            let state = getInitialState();
            let finalSummaryData = {}; // === Floating Scanner Variables ===
            let floatingScanner = null;
            let floatingStream = null;
            let floatingOcrStreaming = false;
            let floatingOcrStreamInterval = null;
            let currentScannerMode = 'barcode';
            let currentScannerContext = 'demo'; // 'demo' or 'final'
            let pyodide = null;
            let pyodideReady = false;
            let lastScannedText = null; // Store latest scanned text
            let scanHistory = []; // Store scan history
            
            // === Pyodide OCR Variables ===
            let pyodideWorker = null;
            let floatingOcrSettings = {
                confidence: 60,
                preprocessing: 'enhanced',
                speed: 800
            };

            // === Initialize Pyodide for Enhanced OCR ===
            async function initializePyodide() {                
                try {
                    if (pyodideReady) return;
                    pyodide = await loadPyodide();
                    // Install required packages
                    await pyodide.loadPackage(['opencv-python', 'numpy', 'pillow']);
                    // Load enhanced OCR processing script with optimized Serial/SKU processing
                    await pyodide.runPython(`
import cv2
import numpy as np
from PIL import Image, ImageEnhance, ImageFilter
import base64
import io
import re

def process_image_enhanced(image_data_base64, preprocessing_mode='enhanced'):
    """
    Enhanced image processing using OpenCV and Python
    Optimized for Apple product serial number and SKU recognition
    with advanced Serial/SKU data processing capabilities
    """
    try:
        # Decode base64 image
        image_data = base64.b64decode(image_data_base64.split(',')[1])
        image = Image.open(io.BytesIO(image_data))
        
        # Convert to OpenCV format
        img_array = np.array(image)
        if len(img_array.shape) == 3:
            img = cv2.cvtColor(img_array, cv2.COLOR_RGB2BGR)
        else:
            img = img_array
            
        # Convert to grayscale
        if len(img.shape) == 3:
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        else:
            gray = img

        # === OPTIMIZED SERIAL/SKU PREPROCESSING ===
        # Apply preprocessing based on mode with Serial/SKU optimization
        if preprocessing_mode == 'basic':
            # Basic sharpening optimized for Serial/SKU text
            kernel = np.array([[-1,-1,-1,-1,-1], 
                              [-1,2,2,2,-1], 
                              [-1,2,8,2,-1], 
                              [-1,2,2,2,-1], 
                              [-1,-1,-1,-1,-1]]) / 8
            processed = cv2.filter2D(gray, -1, kernel)
            
            # Enhance contrast for Serial/SKU readability
            processed = cv2.convertScaleAbs(processed, alpha=1.2, beta=10)
            _, processed = cv2.threshold(processed, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
            
        elif preprocessing_mode == 'enhanced':
            # Enhanced Apple Serial/SKU optimized processing
            # Advanced CLAHE specifically tuned for Serial/SKU text
            clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(6,6))
            processed = clahe.apply(gray)
            
            # Serial/SKU specific bilateral filtering
            processed = cv2.bilateralFilter(processed, 11, 80, 80)
            
            # Enhance Serial/SKU text definition
            enhancer = ImageEnhance.Sharpness(Image.fromarray(processed))
            processed = np.array(enhancer.enhance(2.0))
            
            # Unsharp masking optimized for Serial/SKU characters
            blurred = cv2.GaussianBlur(processed, (3, 3), 0)
            processed = cv2.addWeighted(processed, 1.8, blurred, -0.8, 0)
            
            # Serial/SKU adaptive thresholding
            processed = cv2.adaptiveThreshold(processed, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 13, 4)
            
        elif preprocessing_mode == 'aggressive':
            # Aggressive preprocessing for difficult Serial/SKU conditions
            # Advanced CLAHE for challenging lighting
            clahe = cv2.createCLAHE(clipLimit=4.0, tileGridSize=(4,4))
            processed = clahe.apply(gray)
            
            # Multiple denoising passes for Serial/SKU clarity
            processed = cv2.fastNlMeansDenoising(processed, None, 12, 7, 21)
            processed = cv2.bilateralFilter(processed, 13, 90, 90)
            
            # Multi-scale sharpening for Serial/SKU text
            sharp1 = cv2.GaussianBlur(processed, (2, 2), 0)
            sharp2 = cv2.GaussianBlur(processed, (4, 4), 0)
            processed = cv2.addWeighted(processed, 2.2, sharp1, -0.6, 0)
            processed = cv2.addWeighted(processed, 1.2, sharp2, -0.2, 0)
            
            # Serial/SKU specific morphological operations
            kernel1 = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 1))
            kernel2 = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 2))
            processed = cv2.morphologyEx(processed, cv2.MORPH_CLOSE, kernel1)
            processed = cv2.morphologyEx(processed, cv2.MORPH_OPEN, kernel2)
            
            # Final Serial/SKU optimized thresholding
            processed = cv2.adaptiveThreshold(processed, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 15, 2)
        
        # Convert back to PIL Image
        processed_image = Image.fromarray(processed)
        
        # === SERIAL/SKU SPECIFIC ENHANCEMENTS ===
        # Apply Serial/SKU text enhancement filters
        processed_image = processed_image.filter(ImageFilter.UnsharpMask(radius=1, percent=200, threshold=0))
        
        # Convert to base64 for return
        buffer = io.BytesIO()
        processed_image.save(buffer, format='PNG')
        processed_base64 = base64.b64encode(buffer.getvalue()).decode()
        
        return f"data:image/png;base64,{processed_base64}"
        
    except Exception as e:
        return f"Error: {str(e)}"

def analyze_image_quality(image_data_base64):
    """
    Analyze image quality for better Serial/SKU OCR feedback
    Enhanced with Serial/SKU specific quality metrics
    """
    try:
        # Decode base64 image
        image_data = base64.b64decode(image_data_base64.split(',')[1])
        image = Image.open(io.BytesIO(image_data))
        img_array = np.array(image)
        
        if len(img_array.shape) == 3:
            gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)
        else:
            gray = img_array
            
        # Calculate enhanced metrics for Serial/SKU processing
        brightness = np.mean(gray)
        contrast = np.std(gray)
        sharpness = cv2.Laplacian(gray, cv2.CV_64F).var()
        
        # Serial/SKU specific quality metrics
        edges = cv2.Canny(gray, 50, 150)
        edge_density = np.sum(edges > 0) / edges.size
        
        # Text region analysis for Serial/SKU
        text_regions = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)
        text_density = np.sum(text_regions == 0) / text_regions.size
        
        # Quality assessment optimized for Serial/SKU
        quality = {
            'brightness': float(brightness),
            'contrast': float(contrast),
            'sharpness': float(sharpness),
            'edge_density': float(edge_density),
            'text_density': float(text_density),
            'overall': 'good'
        }
        
        # Enhanced quality thresholds for Serial/SKU processing
        if brightness < 45:
            quality['overall'] = 'too_dark'
        elif brightness > 210:
            quality['overall'] = 'too_bright'
        elif contrast < 25:
            quality['overall'] = 'low_contrast'
        elif sharpness < 80:
            quality['overall'] = 'blurry'
        elif edge_density < 0.02:
            quality['overall'] = 'insufficient_detail'
        elif text_density < 0.05:
            quality['overall'] = 'no_text_detected'
            
        return quality
        
    except Exception as e:
        return {'error': str(e)}

def extract_serial_sku_patterns(text):
    """
    Advanced Serial/SKU pattern extraction and validation
    Optimized for Apple products and various SKU formats
    """
    try:
        # Clean the input text
        cleaned_text = re.sub(r'[^A-Z0-9\-_]', '', text.upper())
        
        # Enhanced Serial/SKU patterns
        patterns = {
            'apple_serial': r'[A-Z0-9]{10,12}',  # Apple serial format
            'sku_standard': r'S[A-Z0-9]{8,12}',  # Standard SKU with S prefix
            'sku_numeric': r'\d{8,12}',          # Numeric SKU
            'mixed_pattern': r'[A-Z]{2,4}\d{6,10}',  # Mixed letter-number
            'barcode_pattern': r'\d{12,14}',     # Barcode patterns
        }
        
        extracted = {}
        for pattern_name, pattern in patterns.items():
            matches = re.findall(pattern, cleaned_text)
            if matches:
                extracted[pattern_name] = matches
        
        # Score patterns based on likelihood for Serial/SKU
        scored_results = []
        for pattern_name, matches in extracted.items():
            for match in matches:
                score = calculate_serial_sku_score(match, pattern_name)
                scored_results.append({
                    'text': match,
                    'pattern': pattern_name,
                    'score': score,
                    'length': len(match)
                })
        
        # Sort by score descending
        scored_results.sort(key=lambda x: x['score'], reverse=True)
        
        return {
            'best_matches': scored_results[:3],  # Top 3 matches
            'all_patterns': extracted,
            'original_text': text,
            'cleaned_text': cleaned_text
        }
        
    except Exception as e:
        return {'error': str(e)}

def calculate_serial_sku_score(text, pattern_type):
    """
    Calculate confidence score for Serial/SKU matches
    """
    score = 0
    
    # Base score by pattern type
    pattern_scores = {
        'apple_serial': 90,
        'sku_standard': 85,
        'mixed_pattern': 70,
        'sku_numeric': 60,
        'barcode_pattern': 50
    }
    score += pattern_scores.get(pattern_type, 30)
    
    # Length scoring (optimal lengths for Serial/SKU)
    length = len(text)
    if 8 <= length <= 12:
        score += 20
    elif 6 <= length <= 14:
        score += 10
    else:
        score -= 10
    
    # Character composition scoring
    letters = sum(1 for c in text if c.isalpha())
    digits = sum(1 for c in text if c.isdigit())
    
    # Prefer mixed alphanumeric for serials
    if letters > 0 and digits > 0:
        score += 15
    
    # Apple serial specific patterns
    if pattern_type == 'apple_serial':
        if letters >= 3 and digits >= 6:
            score += 25
        if not any(char in text for char in ['O', 'I']):  # Apple avoids O, I
            score += 10
    
    # SKU specific patterns
    if 'sku' in pattern_type:
        if text.startswith('S') and len(text) >= 9:
            score += 20
        if digits >= length * 0.6:  # SKUs often numeric-heavy
            score += 10
    
    return min(score, 100)  # Cap at 100
                    `);
                      pyodideReady = true;
                      } catch (error) {
                    // Silent error handling for production
                }
            }            
            // === Floating Scanner Functions ===
            function initializeFloatingScanner() {
                floatingScanner = document.getElementById('floating-scanner');
                
                // Make header draggable with enhanced responsiveness
                const header = document.getElementById('scanner-header');
                let isDragging = false;
                let currentX = 0;
                let currentY = 0;
                let initialX = 0;
                let initialY = 0;
                let xOffset = 0;
                let yOffset = 0;
                
                function dragStart(e) {
                    // Only drag if clicking on the header itself, not buttons
                    if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                        return;
                    }
                    
                    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                    
                    initialX = clientX - xOffset;
                    initialY = clientY - yOffset;
                    isDragging = true;
                    
                    // Enhanced visual feedback
                    floatingScanner.style.cursor = 'grabbing';
                    floatingScanner.style.userSelect = 'none';
                    floatingScanner.style.transition = 'none'; // Disable transition during drag
                    header.style.transform = 'scale(0.98)'; // Subtle scale effect
                }
                  function drag(e) {
                    if (isDragging) {
                        e.preventDefault();
                        
                        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                        
                        const newX = clientX - initialX;
                        const newY = clientY - initialY;
                        
                        // Only update if position actually changed (performance optimization)
                        if (Math.abs(newX - currentX) > 1 || Math.abs(newY - currentY) > 1) {
                            currentX = newX;
                            currentY = newY;
                            
                            xOffset = currentX;
                            yOffset = currentY;
                            
                            // Constrain to viewport bounds
                            const rect = floatingScanner.getBoundingClientRect();
                            const maxX = window.innerWidth - rect.width;
                            const maxY = window.innerHeight - rect.height;
                            
                            currentX = Math.max(0, Math.min(currentX, maxX));
                            currentY = Math.max(0, Math.min(currentY, maxY));
                            
                            // Smooth transform with GPU acceleration
                            requestAnimationFrame(() => {
                                floatingScanner.style.transform = `translate3d(${currentX}px, ${currentY}px, 0)`;
                            });
                        }
                    }
                }
                
                function dragEnd() {
                    if (isDragging) {
                        initialX = currentX;
                        initialY = currentY;
                        isDragging = false;
                        
                        // Restore visual feedback
                        floatingScanner.style.cursor = '';
                        floatingScanner.style.userSelect = '';
                        floatingScanner.style.transition = 'transform 0.3s ease-in-out, visibility 0.3s ease-in-out, opacity 0.3s ease-in-out';
                        header.style.transform = 'scale(1)';
                    }
                }
                
                // Enhanced event listeners for both mouse and touch
                header.addEventListener('mousedown', dragStart);
                header.addEventListener('touchstart', dragStart, { passive: false });
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('touchmove', drag, { passive: false });
                
                document.addEventListener('mouseup', dragEnd);
                document.addEventListener('touchend', dragEnd);
                  // Initialize event listeners
                setupFloatingTabSwitching();
                setupFloatingControls();
            }

            function setupFloatingTabSwitching() {
                const barcodeTab = document.getElementById('floating-barcode-tab');
                const textTab = document.getElementById('floating-text-tab');
                const barcodeView = document.getElementById('floating-barcode-view');
                const textView = document.getElementById('floating-text-view');
                
                barcodeTab.addEventListener('click', () => switchFloatingTab('barcode'));
                textTab.addEventListener('click', () => switchFloatingTab('text'));
                  function switchFloatingTab(mode) {
                    currentScannerMode = mode;
                    const ocrControls = document.getElementById('floating-ocr-controls');
                    const ocrPreview = document.getElementById('floating-ocr-preview');
                    
                    if (mode === 'barcode') {
                        barcodeTab.classList.add('active');
                        textTab.classList.remove('active');
                        barcodeView.classList.remove('hidden');
                        textView.classList.add('hidden');
                        ocrControls.classList.add('hidden');
                        ocrPreview.classList.add('hidden');
                        
                        stopFloatingTextScanner();
                        stopFloatingOcrStreaming();
                        startFloatingBarcodeScanner();
                    } else {
                        textTab.classList.add('active');
                        barcodeTab.classList.remove('active');
                        textView.classList.remove('hidden');
                        barcodeView.classList.add('hidden');
                        ocrControls.classList.remove('hidden');
                        
                        stopFloatingBarcodeScanner();
                        startFloatingTextScanner();
                        setTimeout(startFloatingOcrStreaming, 800);
                    }
                }
            }

            function setupFloatingControls() {
                // Confidence slider
                const confidenceSlider = document.getElementById('floating-confidence-slider');
                const confidenceValue = document.getElementById('floating-confidence-value');
                
                confidenceSlider.addEventListener('input', (e) => {
                    floatingOcrSettings.confidence = parseInt(e.target.value);
                    confidenceValue.textContent = e.target.value + '%';
                });
                  // Preprocessing select
                const preprocessingSelect = document.getElementById('floating-preprocessing-select');
                preprocessingSelect.addEventListener('change', (e) => {
                    floatingOcrSettings.preprocessing = e.target.value;
                });
                  // Close button
                const closeBtn = document.getElementById('close-floating-scanner');
                closeBtn.addEventListener('click', closeFloatingScanner);
            }            async function startFloatingTextScanner() {
                try {
                    if (floatingStream) {
                        floatingStream.getTracks().forEach(track => track.stop());
                    }
                    
                    const constraints = {
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 1920, max: 1920 },
                            height: { ideal: 1080, max: 1080 },
                            frameRate: { ideal: 30, max: 30 }
                        }
                    };
                    
                    floatingStream = await navigator.mediaDevices.getUserMedia(constraints);
                    const video = document.getElementById('floating-text-video');                    
                    video.srcObject = floatingStream;
                    video.play();
                } catch (err) {
                    updateFloatingResults(`<p class="text-red-500">Camera error: ${err.message}</p>`);
                }
            }

            function stopFloatingTextScanner() {
                const video = document.getElementById('floating-text-video');
                if (video && video.srcObject) {
                    const tracks = video.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    video.srcObject = null;
                }
                floatingStream = null;
            }

            function startFloatingBarcodeScanner() {
                const barcodeView = document.getElementById('floating-barcode-view');
                
                Quagga.init({
                    inputStream: {
                        name: "Live",
                        type: "LiveStream",
                        target: barcodeView,
                        constraints: { facingMode: "environment" }
                    },
                    decoder: {
                        readers: [
                            "code_128_reader", "ean_reader", "ean_8_reader",
                            "code_39_reader", "upc_reader", "upc_e_reader"
                        ]
                    },
                    locate: true
                }, (err) => {
                    if (err) {
                        updateFloatingResults(`<p class="text-red-500">Barcode scanner error: ${err.message}</p>`);
                        return;
                    }
                    Quagga.start();
                });
                
                Quagga.onDetected(onFloatingBarcodeDetected);
            }

            function stopFloatingBarcodeScanner() {
                if (typeof Quagga !== 'undefined' && Quagga.running) {
                    Quagga.offDetected(onFloatingBarcodeDetected);
                    Quagga.stop();
                }
                
                const quaggaVideo = document.querySelector('#floating-barcode-view video');
                if (quaggaVideo && quaggaVideo.srcObject) {
                    quaggaVideo.srcObject.getTracks().forEach(track => track.stop());
                    quaggaVideo.srcObject = null;
                }
            }

            function startFloatingOcrStreaming() {
                if (floatingOcrStreaming) return;
                floatingOcrStreaming = true;
                updateFloatingResults('<p class="text-blue-500">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πÅ‡∏Å‡∏ô‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏•‡πÑ‡∏ó‡∏°‡πå...</p>');
                floatingOcrStreamInterval = setInterval(processFloatingOcrFrame, floatingOcrSettings.speed);
            }

            function stopFloatingOcrStreaming() {
                floatingOcrStreaming = false;
                if (floatingOcrStreamInterval) {
                    clearInterval(floatingOcrStreamInterval);
                    floatingOcrStreamInterval = null;
                }
            }

            async function processFloatingOcrFrame() {
                if (!floatingOcrStreaming || !floatingStream || !cvReady) return;
                  const video = document.getElementById('floating-text-video');
                if (video.readyState < 2) return;
                
                const startTime = performance.now();
                
                const canvas = document.createElement('canvas');
                
                // Enhanced crop settings for Apple products
                const cropY = video.videoHeight * 0.45;
                const cropHeight = video.videoHeight * 0.18;
                const cropX = video.videoWidth * 0.05;
                const cropWidth = video.videoWidth * 0.90;
                
                canvas.width = cropWidth;
                canvas.height = cropHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

                // Show preview
                const preview = document.getElementById('floating-ocr-preview');
                if (preview) {
                    preview.classList.remove('hidden');
                    preview.width = canvas.width;
                    preview.height = canvas.height;
                    preview.getContext('2d').drawImage(canvas, 0, 0);
                }

                try {
                    let processedImageData;
                      if (pyodideReady) {
                        // Use Pyodide for enhanced Serial/SKU processing
                        const imageDataURL = canvas.toDataURL('image/png');
                        
                        // Analyze image quality first
                        const quality = pyodide.runPython(`analyze_image_quality("""${imageDataURL}""")`);
                        const qualityObj = quality.toJs();
                        
                        if (qualityObj.error) {
                            throw new Error(qualityObj.error);
                        }
                          // Provide enhanced quality feedback for Serial/SKU
                        if (qualityObj.overall === 'too_dark') {
                            updateFloatingResults(`<p class="text-yellow-600">‡∏†‡∏≤‡∏û‡∏°‡∏∑‡∏î‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏™‡∏á‡∏™‡∏ß‡πà‡∏≤‡∏á (${qualityObj.brightness.toFixed(0)})</p>`);
                            return;
                        } else if (qualityObj.overall === 'too_bright') {
                            updateFloatingResults(`<p class="text-yellow-600">‡∏†‡∏≤‡∏û‡∏™‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏î‡πÅ‡∏™‡∏á‡∏™‡∏ß‡πà‡∏≤‡∏á (${qualityObj.brightness.toFixed(0)})</p>`);
                            return;
                        } else if (qualityObj.overall === 'low_contrast') {
                            updateFloatingResults(`<p class="text-yellow-600">‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏õ‡∏£‡∏±‡∏ö‡πÇ‡∏ü‡∏Å‡∏±‡∏™ (‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ä‡∏±‡∏î: ${qualityObj.contrast.toFixed(0)})</p>`);
                            return;
                        } else if (qualityObj.overall === 'blurry') {
                            updateFloatingResults(`<p class="text-yellow-600">‡∏†‡∏≤‡∏û‡πÄ‡∏ö‡∏•‡∏≠ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏õ‡∏£‡∏±‡∏ö‡πÇ‡∏ü‡∏Å‡∏±‡∏™ (‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Ñ‡∏°: ${qualityObj.sharpness.toFixed(0)})</p>`);
                            return;
                        } else if (qualityObj.overall === 'insufficient_detail') {
                            updateFloatingResults(`<p class="text-yellow-600">‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÑ‡∏°‡πà‡πÄ‡∏û‡∏µ‡∏¢‡∏á‡∏û‡∏≠ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏Å‡∏•‡πâ‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°</p>`);
                            return;
                        } else if (qualityObj.overall === 'no_text_detected') {
                            updateFloatingResults(`<p class="text-yellow-600">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏° ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏à‡∏±‡∏î‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á</p>`);
                            return;
                        }
                        
                        // Process image with Pyodide enhanced Serial/SKU processing
                        processedImageData = pyodide.runPython(`process_image_enhanced("""${imageDataURL}""", "${floatingOcrSettings.preprocessing}")`);
                        
                        if (processedImageData.startsWith('Error:')) {
                            throw new Error(processedImageData);
                        }
                        
                        // Convert processed image back to canvas
                        const img = new Image();
                        img.onload = async () => {
                            const processedCanvas = document.createElement('canvas');
                            processedCanvas.width = img.width;
                            processedCanvas.height = img.height;
                            const processedCtx = processedCanvas.getContext('2d');
                            processedCtx.drawImage(img, 0, 0);
                            
                            await performOCRRecognition(processedCanvas, startTime);
                        };
                        img.src = processedImageData;
                        
                    } else {
                        // Fallback to OpenCV processing
                        await performOpenCVProcessing(canvas, startTime);
                    }
                      } catch (err) {
                    updateFloatingResults(`<p class="text-red-500">Processing error: ${err.message}</p>`);
                }
            }

            async function performOpenCVProcessing(canvas, startTime) {
                if (!cvReady) return;
                
                let src = cv.imread(canvas);
                let dst = new cv.Mat();
                
                // Apply OpenCV preprocessing based on settings
                if (floatingOcrSettings.preprocessing === 'basic') {
                    cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);
                    const sharpKernel = cv.matFromArray(3, 3, cv.CV_32FC1, [0, -1, 0, -1, 5, -1, 0, -1, 0]);
                    cv.filter2D(dst, dst, -1, sharpKernel);
                    sharpKernel.delete();
                    cv.threshold(dst, dst, 0, 255, cv.THRESH_OTSU | cv.THRESH_BINARY_INV);
                } else if (floatingOcrSettings.preprocessing === 'enhanced') {
                    cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);
                    const clahe = new cv.CLAHE(2.0, new cv.Size(8, 8));
                    clahe.apply(dst, dst);
                    clahe.delete();
                    cv.bilateralFilter(dst, dst, 9, 75, 75);
                    const blurred = new cv.Mat();
                    cv.GaussianBlur(dst, blurred, new cv.Size(3, 3), 0, 0, cv.BORDER_DEFAULT);
                    cv.addWeighted(dst, 1.5, blurred, -0.5, 0, dst);
                    blurred.delete();
                    cv.threshold(dst, dst, 0, 255, cv.THRESH_OTSU | cv.THRESH_BINARY_INV);
                }
                
                cv.imshow(canvas, dst);
                src.delete();
                dst.delete();
                
                await performOCRRecognition(canvas, startTime);
            }

            async function performOCRRecognition(canvas, startTime) {
                if (!tesseractWorker) {
                    await initTesseract('eng', true);
                }
                
                const result = await tesseractWorker.recognize(canvas);
                const processingTime = performance.now() - startTime;
                
                let text = result.data.text.replace(/\s/g, '').toUpperCase();
                let confidence = result.data.confidence;
                  // Enhanced Serial/SKU processing with Pyodide
                if (pyodideReady) {
                    try {
                        // Use Pyodide for advanced Serial/SKU pattern extraction
                        const extractionResult = pyodide.runPython(`extract_serial_sku_patterns("""${text}""")`);
                        const patterns = extractionResult.toJs();
                        
                        if (patterns.error) {
                            throw new Error(patterns.error);
                        }
                        
                        // Check if we have high-confidence Serial/SKU matches
                        if (patterns.best_matches && patterns.best_matches.length > 0) {
                            const bestMatch = patterns.best_matches[0];
                            
                            // Validate confidence and score thresholds
                            if (bestMatch.score >= 70 && confidence >= floatingOcrSettings.confidence) {
                                const finalText = bestMatch.text;
                                const patternType = bestMatch.pattern;
                                
                                updateFloatingResults(`
                                    <div class="text-left space-y-1">
                                        <p><strong>${patternType.includes('serial') ? 'Serial' : 'SKU'}:</strong> <span class="font-mono text-blue-600">${finalText}</span></p>
                                        <div class="flex justify-between text-xs text-gray-500">
                                            <span>Score: ${bestMatch.score}%</span>
                                            <span>OCR: ${confidence.toFixed(1)}%</span>
                                        </div>
                                        <p class="text-xs text-green-600">Pattern: ${patternType}</p>
                                    </div>
                                `);
                                
                                processFloatingScannedCode(finalText, 'DEMO-Enhanced Text Scan');
                                stopFloatingOcrStreaming();
                                return;
                            }
                        }
                        
                        // Show scanning progress with pattern information
                        const patternCount = Object.keys(patterns.all_patterns || {}).length;
                        updateFloatingResults(`
                            <div class="text-center space-y-1">
                                <p class="text-blue-500">Scanning Serial/SKU...</p>
                                <div class="flex justify-between text-xs text-gray-500">
                                    <span>OCR: ${confidence.toFixed(1)}%</span>
                                    <span>Patterns: ${patternCount}</span>
                                </div>
                                <p class="text-xs text-gray-400">${patterns.cleaned_text.substring(0, 20)}${patterns.cleaned_text.length > 20 ? '...' : ''}</p>
                            </div>
                        `);
                        
                    } catch (pyodideError) {
                        // Pyodide pattern extraction failed, falling back to basic processing
                        // Fallback to basic processing
                        performBasicSerialSKUProcessing(text, confidence);
                    }
                } else {
                    // Fallback when Pyodide is not ready
                    performBasicSerialSKUProcessing(text, confidence);
                }
            }
            
            function performBasicSerialSKUProcessing(text, confidence) {
                // Apple-specific text post-processing (fallback)
                text = text.replace(/[|]/g, 'I')
                           .replace(/[0]/g, 'O')
                           .replace(/[8]/g, 'B')
                           .replace(/[5]/g, 'S')
                           .replace(/[1]/g, 'I')
                           .replace(/[\.]/g, '')
                           .replace(/[,]/g, '')
                           .replace(/[\s]/g, '');
                
                // Enhanced Apple serial validation
                const appleSerialMatch = text.match(/[A-Z0-9\-]{8,}/);
                const isValidAppleSerial = appleSerialMatch && (
                    text.length >= 8 && text.length <= 14 &&
                    /[A-Z]/.test(text) &&
                    /[0-9]/.test(text) &&
                    !/[^A-Z0-9\-]/.test(text)
                );
                  if (isValidAppleSerial && confidence >= floatingOcrSettings.confidence) {
                    const finalText = appleSerialMatch[0];
                    updateFloatingResults(`<p>Serial/SKU: <b>${finalText}</b></p>`);
                    processFloatingScannedCode(finalText, 'DEMO-Text Scan');
                    stopFloatingOcrStreaming();
                } else {
                    updateFloatingResults(`<p class='text-blue-500'>Scanning... (${confidence.toFixed(1)}%)</p>`);
                }
            }

            async function captureAndRecognizeFloating() {
                if (!floatingStream || !cvReady) {
                    updateFloatingResults(`<p class="text-red-500">Camera or OpenCV not ready</p>`);
                    return;
                }
                
                updateFloatingResults(`<p class="text-blue-500">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£...</p>`);
                const captureBtn = document.getElementById('floating-capture-btn');
                captureBtn.disabled = true;
                
                try {
                    const video = document.getElementById('floating-text-video');
                    const canvas = document.createElement('canvas');
                    
                    const cropHeightPercentage = 0.15;
                    const cropWidthPercentage = 0.70;
                    const sWidth = video.videoWidth * cropWidthPercentage;
                    const sHeight = video.videoHeight * cropHeightPercentage;
                    const sx = video.videoWidth * (1 - cropWidthPercentage) / 2;
                    const sy = video.videoHeight * 0.45;
                    
                    canvas.width = sWidth;
                    canvas.height = sHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
                    
                    await performOCRRecognition(canvas, performance.now());
                    
                } catch (err) {
                    updateFloatingResults(`<p class="text-red-500">Capture error: ${err.message}</p>`);
                } finally {
                    captureBtn.disabled = false;
                }
            }            
            
            function processFloatingScannedCode(code, reason) {
                const scannedText = code.toUpperCase();
                // Store latest scanned text and add to history
                lastScannedText = scannedText;
                scanHistory.unshift({ text: scannedText, timestamp: new Date().toLocaleTimeString(), reason });
                if (scanHistory.length > 10) scanHistory.pop(); // Keep last 10 scans
                
                let item = null;
                
                // Determine which dataset to search based on context
                const searchData = currentScannerContext === 'demo' ? state.demoMaster : state.reconciledData;
                  if (!searchData || searchData.length === 0) {
                    playSound('error');
                    updateFloatingResults(`<div class="text-center w-full"><p class="font-bold text-red-600">No data available</p><p class="text-sm text-slate-500">Scanned: ${scannedText}</p><p class="text-xs text-slate-400">Latest scan stored</p></div>`);
                    return;
                }
                
                // Use shared matching function
                item = findItemByScannedText(searchData, scannedText);
                
                if (item) {
                    playSound('success');
                    
                    if (currentScannerContext === 'demo') {
                        // Update demo count
                        let currentCount = typeof item.counted === 'number' ? item.counted : 0;
                        item.counted = currentCount + 1;
                        state.demoCounts[item.SKU] = { qty: item.counted, reason: reason };
                        applyDemoView();
                        
                        const diff = item.counted - item.SOH;
                        let statusText = (diff === 0) ? 'Matched' : (diff > 0) ? 'Overage' : 'Shortage';
                        let statusColor = (diff === 0) ? 'text-green-600' : (diff > 0) ? 'text-yellow-600' : 'text-blue-600';
                        
                        updateFloatingResults(`<div class="text-left w-full space-y-1"><p class="font-medium text-slate-800">${item.Description}</p><p class="text-sm text-slate-500">SKU: ${item.SKU}</p><div class="flex justify-between items-baseline pt-1"><span class="text-lg font-bold text-slate-700">Count: <span class="text-blue-600">${item.counted}</span> / ${item.SOH}</span><span class="text-lg font-bold ${statusColor}">${statusText}</span></div><p class="text-xs text-green-600 mt-1">‚úì Match found for: ${scannedText}</p></div>`);
                    } else {
                        // Final report context - just highlight the found item
                        updateFloatingResults(`<div class="text-left w-full space-y-1"><p class="font-medium text-slate-800">${item.Description}</p><p class="text-sm text-slate-500">SKU: ${item.SKU}</p><div class="flex justify-between items-baseline pt-1"><span class="text-lg font-bold text-slate-700">Counted: <span class="text-blue-600">${item.Recount}</span> / ${item.SOH}</span><span class="text-lg font-bold">${item.FinalDiff === 0 ? '<span class="text-green-600">Matched</span>' : item.FinalDiff > 0 ? '<span class="text-yellow-600">Overage</span>' : '<span class="text-blue-600">Shortage</span>'}</span></div><p class="text-xs text-green-600 mt-1">‚úì Match found for: ${scannedText}</p></div>`);
                    }
                    
                    // Scroll to item in table
                    const tableContainer = currentScannerContext === 'demo' ? 
                        document.getElementById('demo-count-container') : 
                        document.getElementById('final-report-table-container');
                        
                    const row = tableContainer.querySelector(`tr[data-sku="${item.SKU}"]`);
                    if (row) {
                        row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        row.classList.add('ring-2', 'ring-offset-2', 'ring-green-500');
                        setTimeout(() => row.classList.remove('ring-2', 'ring-offset-2', 'ring-green-500'), 800);
                    }                } else {
                    playSound('error');
                    // Show scanned text even when no match found
                    updateFloatingResults(`<div class="text-center w-full"><p class="font-bold text-red-600">SKU Not Found</p><p class="text-sm text-slate-700 font-medium">Scanned: ${scannedText}</p><p class="text-xs text-slate-400 mt-1">Latest scan stored ‚Ä¢ No matching SKU in ${currentScannerContext} data</p></div>`);
                }
            }

            const floatingScanCooldown = {};
            function onFloatingBarcodeDetected(result) {
                const code = result.codeResult.code.trim();
                const now = Date.now();
                if (floatingScanCooldown[code] && now - floatingScanCooldown[code] < 2000) return;
                floatingScanCooldown[code] = now;
                processFloatingScannedCode(code, 'DEMO-Barcode');
            }            
            function openFloatingScanner(context = 'demo') {
                currentScannerContext = context;
                currentScannerMode = 'barcode';
                  // Reset scanner state
                document.getElementById('floating-barcode-tab').classList.add('active');
                document.getElementById('floating-text-tab').classList.remove('active');
                document.getElementById('floating-barcode-view').classList.remove('hidden');
                document.getElementById('floating-text-view').classList.add('hidden');
                document.getElementById('floating-ocr-preview').classList.add('hidden');
                document.getElementById('floating-ocr-controls').classList.add('hidden');
                
                // Ensure proper display and visibility
                floatingScanner.style.display = 'block';
                floatingScanner.style.visibility = 'visible';
                floatingScanner.style.opacity = '1';
                
                // Show scanner with animation
                floatingScanner.classList.add('active');
                
                // Start with barcode scanner
                setTimeout(() => {
                    startFloatingBarcodeScanner();
                }, 300);
                
                // Initialize Pyodide if not already done
                if (!pyodideReady) {
                    initializePyodide();
                }
                  updateFloatingResults('<p class="text-blue-500">Scanner ready</p>');
            }
            function closeFloatingScanner() {                
                if (!floatingScanner) return;
                // Stop all scanner activities first
                stopFloatingTextScanner();
                stopFloatingBarcodeScanner();
                stopFloatingOcrStreaming();
                
                // Clear all video streams
                const video = document.getElementById('floating-text-video');
                if (video && video.srcObject) {                    
                    const tracks = video.srcObject.getTracks();
                    tracks.forEach(track => {
                        track.stop();
                    });
                    video.srcObject = null;
                }
                
                // Force stop Quagga barcode scanner
                if (typeof Quagga !== 'undefined' && Quagga.running) {                    
                    try {
                        Quagga.offDetected(onFloatingBarcodeDetected);
                        Quagga.stop();                    
                    } catch (err) {
                        // Silent error handling for production
                    }
                }
                
                // Clear barcode scanner video
                const barcodeView = document.getElementById('floating-barcode-view');
                const quaggaVideo = barcodeView.querySelector('video');
                if (quaggaVideo && quaggaVideo.srcObject) {
                    const tracks = quaggaVideo.srcObject.getTracks();                
                    tracks.forEach(track => track.stop());
                    quaggaVideo.srcObject = null;
                }
                
                // Reset any custom transform on scanner
                floatingScanner.style.transform = '';
                
                // Ensure proper transition is enabled
                floatingScanner.style.transition = 'transform 0.3s ease-in-out, visibility 0.3s ease-in-out, opacity 0.3s ease-in-out';
                
                // Hide scanner completely with proper CSS states
                floatingScanner.classList.remove('active');
                  // Force complete hiding after animation
                setTimeout(() => {
                    if (!floatingScanner.classList.contains('active')) {
                        floatingScanner.style.display = 'none';
                        floatingScanner.style.visibility = 'hidden';
                        floatingScanner.style.opacity = '0';
                    }
                }, 350); // Wait for CSS transition to complete
                
                // Reset tab states for next opening
                setTimeout(() => {
                    document.getElementById('floating-barcode-tab').classList.add('active');
                    document.getElementById('floating-text-tab').classList.remove('active');
                    document.getElementById('floating-barcode-view').classList.remove('hidden');
                    document.getElementById('floating-text-view').classList.add('hidden');
                    document.getElementById('floating-ocr-preview').classList.add('hidden');
                    document.getElementById('floating-ocr-controls').classList.add('hidden');
                      // Clear results when scanner is closed
                    updateFloatingResults('<p class="text-gray-400">Click scan to start</p>');
                    
                    currentScannerMode = 'barcode';
                }, 400); // Wait for animation to complete
            }

            function updateFloatingResults(html) {
                const resultsEl = document.getElementById('floating-scanner-results');
                if (resultsEl) {
                    resultsEl.innerHTML = html;
                }            }

            // === OCR Enhancement Variables ===
            let tesseractWorker = null;            // === OCR Variables (simplified) ===
            let ocrSettings = {
                demo: { confidence: 60, language: 'eng', preprocessing: 'enhanced', speed: 800 },
                final: { confidence: 60, language: 'eng', preprocessing: 'enhanced', speed: 800 }
            };

            // === OCR Enhancement Functions ===
            async function initTesseract(language = 'eng', isDemo = true) {
                const worker = isDemo ? tesseractWorker : finalTesseractWorker;
                if (worker) {
                    await worker.terminate();
                }
                
                const newWorker = await Tesseract.createWorker(language);
                
                // Enhanced OCR parameters for Apple product serial numbers
                await newWorker.setParameters({
                    // Character whitelist optimized for Apple serials
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_',
                    // Single line mode for serial numbers
                    tessedit_pageseg_mode: Tesseract.PSM.SINGLE_LINE,
                    // Improved OCR engine mode for better accuracy
                    tessedit_ocr_engine_mode: Tesseract.OEM.LSTM_ONLY,
                    // Enable dictionary for better word recognition
                    tessedit_enable_dict_correction: 1,
                    // Numeric mode for better digit recognition
                    tessedit_enable_numeric_mode: 1,
                    // Improve recognition of similar characters
                    tessedit_char_unblacklist: '',
                    // Better handling of mixed alphanumeric content
                    preserve_interword_spaces: 0,
                    // Optimize for Apple's typical serial number patterns
                    user_defined_dpi: 300,
                    // Better edge detection for clear text
                    edges_use_image_gradients: 1
                });
                  if (isDemo) {
                    tesseractWorker = newWorker;
                } else {
                    finalTesseractWorker = newWorker;
                }
                
                return newWorker;
            }

            function generateCacheKey(imageData, settings) {
                const canvas = document.createElement('canvas');
                canvas.width = 50;
                canvas.height = 20;
                const ctx = canvas.getContext('2d');
                ctx.putImageData(imageData, 0, 0);
                const hash = btoa(canvas.toDataURL()).slice(0, 16);
                return `${hash}-${settings.language}-${settings.preprocessing}-${settings.confidence}`;
            }            function learnSuccessPattern(text, confidence, processingTime, isDemo = true) {
                const pattern = text.substring(0, 3); // First 3 characters as pattern
                const patternMap = isDemo ? ocrPatternLearning : finalOcrPatternLearning;
                
                if (!patternMap.has(pattern)) {
                    patternMap.set(pattern, { count: 0, avgConfidence: 0, avgTime: 0 });
                }
                const existing = patternMap.get(pattern);
                existing.count++;
                existing.avgConfidence = (existing.avgConfidence + confidence) / 2;
                existing.avgTime = (existing.avgTime + processingTime) / 2;
            }            function boostConfidenceForKnownPatterns(text, confidence, isDemo = true) {
                const pattern = text.substring(0, 3);
                const patternMap = isDemo ? ocrPatternLearning : finalOcrPatternLearning;
                const learned = patternMap.get(pattern);
                if (learned && learned.count > 2) {
                    return Math.min(confidence + (learned.avgConfidence * 0.1), 100);
                }
                return confidence;
            }            // Error recovery functions
            function handleOcrError(error, isDemo = true) {
                const errorMsg = error.message || 'Unknown OCR error';
                // OCR error handled silently for production
                
                // Handle error processing
                if (isDemo) {
                } else {
                }
                  // Attempt recovery based on error type
                if (errorMsg.includes('Worker')) {
                    // Worker-related error - reinitialize
                    setTimeout(() => {
                        initTesseract(isDemo ? ocrSettings.demo.language : ocrSettings.final.language, isDemo);
                    }, 1000);
                } else if (errorMsg.includes('canvas') || errorMsg.includes('image')) {
                    // Image processing error - skip frame
                } else if (errorMsg.includes('memory')) {                    // Memory issue - clear cache and restart
                    cleanupOcrCache();
                    setTimeout(() => {
                        initTesseract(isDemo ? ocrSettings.demo.language : ocrSettings.final.language, isDemo);
                    }, 2000);
                }
                
                return false; // Indicate error was handled
            }

            function validateOcrResult(result, confidence, expectedPattern = /[A-Z0-9\-]{8,}/) {
                if (!result || !result.data) return false;
                
                const text = result.data.text.replace(/\s/g, '').toUpperCase();
                const hasValidPattern = expectedPattern.test(text);
                const hasValidConfidence = confidence >= 30; // Minimum threshold
                
                return hasValidPattern && hasValidConfidence;
            }

            function adaptiveOcrSettings(performance, isDemo = true) {
                const settings = isDemo ? ocrSettings.demo : ocrSettings.final;
                const recentPerformance = (isDemo ? ocrPerformanceHistory : finalOcrPerformanceHistory).slice(-10);
                
                if (recentPerformance.length < 5) return; // Not enough data
                
                const avgConfidence = recentPerformance.reduce((sum, p) => sum + p.confidence, 0) / recentPerformance.length;
                const successRate = recentPerformance.filter(p => p.success).length / recentPerformance.length;
                  // Adapt preprocessing based on performance
                if (successRate < 0.3 && avgConfidence < 70) {
                    // Poor performance - increase preprocessing
                    if (settings.preprocessing === 'basic') {
                        settings.preprocessing = 'enhanced';
                    } else if (settings.preprocessing === 'enhanced') {
                        settings.preprocessing = 'aggressive';
                    }
                } else if (successRate > 0.8 && avgConfidence > 85) {
                    // Great performance - reduce preprocessing for speed
                    if (settings.preprocessing === 'aggressive') {
                        settings.preprocessing = 'enhanced';
                    } else if (settings.preprocessing === 'enhanced') {
                        settings.preprocessing = 'basic';
                    }
                }
                
                // Update UI if needed
                const selectElement = document.getElementById(isDemo ? 'ocr-preprocessing-select' : 'final-ocr-preprocessing-select');
                if (selectElement && selectElement.value !== settings.preprocessing) {
                    selectElement.value = settings.preprocessing;
                }            }

            // Cache management functions
            function cleanupOcrCache() {
                const now = Date.now();
                const maxAge = 5 * 60 * 1000; // 5 minutes
                
                // Clean demo cache
                for (const [key, value] of ocrResultsCache.entries()) {
                    if (now - value.timestamp > maxAge) {
                        ocrResultsCache.delete(key);
                    }
                }
                
                // Clean final cache
                for (const [key, value] of finalOcrResultsCache.entries()) {
                    if (now - value.timestamp > maxAge) {
                        finalOcrResultsCache.delete(key);
                    }
                }
                
                // Limit cache size
                const maxCacheSize = 100;
                if (ocrResultsCache.size > maxCacheSize) {
                    const entries = Array.from(ocrResultsCache.entries());
                    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
                    const toDelete = entries.slice(0, entries.length - maxCacheSize);
                    toDelete.forEach(([key]) => ocrResultsCache.delete(key));
                }
                
                if (finalOcrResultsCache.size > maxCacheSize) {
                    const entries = Array.from(finalOcrResultsCache.entries());
                    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
                    const toDelete = entries.slice(0, entries.length - maxCacheSize);
                    toDelete.forEach(([key]) => finalOcrResultsCache.delete(key));                
                }
            }
            
            function resetOcrStats() {
                ocrSuccessCount = 0;
                ocrTotalAttempts = 0;
                ocrCacheHits = 0;
                ocrPerformanceHistory.length = 0;
                ocrResultsCache.clear();
                ocrPatternLearning.clear();
                  finalOcrSuccessCount = 0;
                finalOcrTotalAttempts = 0;
                finalOcrCacheHits = 0;
                finalOcrPerformanceHistory.length = 0;
                finalOcrResultsCache.clear();
                finalOcrPatternLearning.clear();
            }            // Auto-cleanup cache every 2 minutes
            setInterval(cleanupOcrCache, 2 * 60 * 1000);

            // === Shared SKU Matching Functions ===
            function getMatchingAlgorithms() {
                return [
                    // Algorithm 1: Direct SKU contained in scanned text
                    (sku, scanned) => scanned.includes(sku),
                    // Algorithm 2: SKU with S prefix contained in scanned text
                    (sku, scanned) => scanned.includes(sku.slice(1)),
                    // Algorithm 3: SKU without S prefix (if SKU starts with S)
                    (sku, scanned) => sku.startsWith('S') && scanned.includes(sku.slice(1)),
                    // Algorithm 4: Scanned text with S prefix matches SKU
                    (sku, scanned) => ('S' + scanned) === sku,
                    // Algorithm 5: Last 5 characters pattern match
                    (sku, scanned) => {
                        if (sku.length >= 5) {
                            const skuLast5 = sku.slice(-5);
                            return scanned.includes(skuLast5);
                        }
                        return false;
                    },
                    // Algorithm 6: First 5 characters pattern match
                    (sku, scanned) => {
                        if (sku.length >= 5) {
                            const skuFirst5 = sku.slice(0, 5);
                            return scanned.includes(skuFirst5);
                        }
                        return false;
                    },
                    // Algorithm 7: Middle pattern match (removes first and last char)
                    (sku, scanned) => {
                        if (sku.length >= 6) {
                            const skuMiddle = sku.slice(1, -1);
                            return scanned.includes(skuMiddle);
                        }
                        return false;
                    },
                    // Algorithm 8: Fuzzy match for Apple serial patterns
                    (sku, scanned) => {
                        const cleanSku = sku.replace(/^S?/, '').replace(/[-_].*$/, '');
                        const cleanScanned = scanned.replace(/[-_].*$/, '');
                        return cleanSku.length >= 4 && cleanScanned.includes(cleanSku);
                    },
                    // Algorithm 9: CS prefix matching
                    (sku, scanned) => sku.includes('CS' + scanned),
                    // Algorithm 10: cs prefix matching
                    (sku, scanned) => sku.includes('cs' + scanned),
                    // Algorithm 11: 0 prefix matching
                    (sku, scanned) => sku.includes('0' + scanned),
                    // Algorithm 12: SKU without CS prefix (if SKU starts with CS)
                    (sku, scanned) => sku.startsWith('CS') && scanned.includes(sku.slice(2)),
                    // Algorithm 13: SKU without cs prefix (if SKU starts with cs)
                    (sku, scanned) => sku.startsWith('cs') && scanned.includes(sku.slice(2)),
                    // Algorithm 14: SKU without 0 prefix (if SKU starts with 0)
                    (sku, scanned) => sku.startsWith('0') && scanned.includes(sku.slice(1))
                ];
            }

            function findItemByScannedText(items, scannedText) {
                // Try direct matches first
                let item = items.find(i => i.SKU === scannedText) ||
                          items.find(i => i.SKU === 'S' + scannedText) ||
                          items.find(i => i.SKU === 'CS' + scannedText) ||
                          items.find(i => i.SKU === 'cs' + scannedText) ||
                          items.find(i => i.SKU === '0' + scannedText);

                // If not found, try advanced matching algorithms
                if (!item) {
                    const matchingAlgorithms = getMatchingAlgorithms();
                    for (const dataItem of items) {
                        for (const algorithm of matchingAlgorithms) {
                            if (algorithm(dataItem.SKU, scannedText)) {
                                item = dataItem;
                                break;
                            }
                        }
                        if (item) break;
                    }
                }

                return item;
            }            function getInitialState() {
                return {
                    sohData: [], sohLookup: {}, scannerMaster: [], demoMaster: [],
                    demoCounts: {}, demoSort: { column: 'SKU', direction: 'asc' },
                    netDiffData: [], reconciledData: [], finalReportSort: { column: 'SKU', direction: 'asc' },
                    charts: { cost: null, qty: null, category: null },
                    branchName: null, branchCode: null, countDate: null,
                    sohUpdatedSkus: new Set(), // Track SKUs that had SOH updated
                };
            }
            
            const formatNumber = (num) => (num ?? 0).toLocaleString('en-US');

            function showLoader(message = "Processing...") { 
                getEl('loader-message').textContent = message;
                getEl('loader-overlay').classList.remove('hidden'); 
            }
            function hideLoader() { getEl('loader-overlay').classList.add('hidden'); }
            
            function showModal(title, message, options = {}) {
                getEl('modal-title').textContent = title;
                getEl('modal-message').innerHTML = message;
                const confirmBtn = getEl('modal-confirm-btn');
                const cancelBtn = getEl('modal-cancel-btn');
                confirmBtn.textContent = options.confirmText || 'OK';
                confirmBtn.onclick = () => { hideModal(); if (options.onConfirm) options.onConfirm(); };
                cancelBtn.classList.toggle('hidden', !options.onCancel);
                if (options.onCancel) {
                    cancelBtn.textContent = options.cancelText || 'Cancel';
                    cancelBtn.onclick = () => { hideModal(); options.onCancel(); };
                }
                getEl('modal-container').classList.remove('hidden');
                setTimeout(() => getEl('modal-box').classList.add('scale-100', 'opacity-100'), 10);
            }

            function hideModal() {
                getEl('modal-box').classList.add('scale-95', 'opacity-0');
                setTimeout(() => getEl('modal-container').classList.add('hidden'), 200);
            }

            let saveStatusTimeout;
            function showSaveStatus(message, isWarning) {
                const statusEl = getEl('save-status');
                clearTimeout(saveStatusTimeout);
                statusEl.textContent = message;
                statusEl.className = `text-left text-sm font-semibold opacity-100 ${isWarning ? 'text-red-600' : 'text-green-600'}`;
                if (!isWarning) {
                    saveStatusTimeout = setTimeout(() => statusEl.classList.add('opacity-0'), 3000);
                }
            }
            function updateInfoBox() {
                if (state.branchName) {
                    getEl('info-branch-code').textContent = state.branchCode || '';
                    getEl('info-branch-name').textContent = state.branchName;
                    getEl('info-count-date').textContent = state.countDate;
                    getEl('info-box-container').classList.remove('hidden');
                } else {
                    getEl('info-box-container').classList.add('hidden');
                }
            }
            function resetAppState() {
                // Destroy existing charts
                Object.values(state.charts).forEach(chart => chart?.destroy());
                
                // Reset application state
                state = getInitialState();
                hasUnsavedChanges = false;
                finalSummaryData = {};
                
                // Reset scanner-related variables
                lastScannedText = null;
                scanHistory = [];
                currentScannerMode = 'barcode';
                currentScannerContext = 'demo';
                floatingOcrStreaming = false;
                
                // Clear OCR streaming if active
                if (floatingOcrStreamInterval) {
                    clearInterval(floatingOcrStreamInterval);
                    floatingOcrStreamInterval = null;
                }
                
                // Reset floating scanner settings
                floatingOcrSettings = {
                    confidence: 60,
                    preprocessing: 'enhanced',
                    speed: 800
                };
            }
            function resetUI() {
                // Hide/show main containers
                getEl('workspace-container').classList.add('hidden');
                getEl('final-report-container').classList.add('hidden');
                getEl('upload-container').classList.remove('hidden');
                  // Clear all file inputs
                ['initialSohFile', 'firstScanLogfile', 'secondScanLogfile', 'latestSohFile', 'salesDataFile', 'firstMasterFile', 'secondMasterFile'].forEach(id => {
                    const el = getEl(id);
                    if (el) el.value = '';
                });
                
                // Reset file name displays
                getEl('initialSohFileName').textContent = '(.xlsx, .csv)';
                getEl('latestSohFileName').textContent = '';
                
                // Hide info box and result containers
                getEl('info-box-container').classList.add('hidden');
                getEl('step2-results').classList.add('hidden');
                getEl('sales-processing-results').classList.add('hidden');                // Clear result container contents
                getEl('netdiff-summary-container').innerHTML = '';
                getEl('demo-count-container').innerHTML = '';
                getEl('demo-summary').innerHTML = '';
                getEl('final-report-table-container').innerHTML = '';
                getEl('final-summary').innerHTML = '';
                
                // Clear floating scanner results
                const floatingResults = getEl('floating-scanner-results');
                if (floatingResults) floatingResults.innerHTML = '';
                
                // Close floating scanner if open
                const floatingScanner = getEl('floating-scanner');
                if (floatingScanner && floatingScanner.classList.contains('active')) {
                    closeFloatingScanner();
                }
                
                // Reset button states
                getEl('downloadMasterForScan').disabled = true;
                getEl('processFirstCount').disabled = true;
                getEl('finalizeFromFirstCount').disabled = true;
                getEl('generateRecountMasterFile').disabled = true;                
                getEl('processSecondCount').disabled = true;
                getEl('processSalesData').disabled = true;
                getEl('latestSohFile').disabled = true;
                
                // Reset search inputs
                const demoSearchInput = getEl('demoSearchInput');
                if (demoSearchInput) demoSearchInput.value = '';
                const finalSearchInput = getEl('finalSearchInput');
                if (finalSearchInput) finalSearchInput.value = '';
                
                // Reset filter selects
                const demoFilterSelect = getEl('demoFilterSelect');
                if (demoFilterSelect) demoFilterSelect.value = 'all';
                const finalFilterSelect = getEl('finalFilterSelect');
                if (finalFilterSelect) finalFilterSelect.value = 'all';
                
                // Reset main tabs to demo view
                const demoTab = getEl('main-tab-demo');
                const workflowTab = getEl('main-tab-workflow');
                if (demoTab && workflowTab) {
                    demoTab.classList.add('active');
                    workflowTab.classList.remove('active');
                    getEl('main-panel-demo').classList.remove('hidden');
                    getEl('main-panel-workflow').classList.add('hidden');
                }
                  // Reset workflow step tabs to step 1
                document.querySelectorAll('#wf-step-tabs .tab-button').forEach(btn => btn.classList.remove('active'));
                getEl('wf-tab-btn-1').classList.add('active');
                document.querySelectorAll('.workflow-step').forEach(div => div.classList.add('hidden'));
                getEl('wf-step1').classList.remove('hidden');
                
                // Reset OCR controls to default values
                const confidenceSlider = getEl('floating-confidence-slider');
                const confidenceValue = getEl('floating-confidence-value');
                const preprocessingSelect = getEl('floating-preprocessing-select');
                if (confidenceSlider) {
                    confidenceSlider.value = '60';
                    if (confidenceValue) confidenceValue.textContent = '60%';
                }
                if (preprocessingSelect) {
                    preprocessingSelect.value = 'enhanced';
                }
            }
            
            function setUnsavedChanges(status){
                hasUnsavedChanges = status;
                if (status) {
                    showSaveStatus("Unsaved changes", true);
                }
            }
            
            function startNewJob() {
                showModal('Start New Job?', 'Are you sure? All unsaved progress will be lost.', {
                    confirmText: 'Yes, Start New Job',
                    onConfirm: () => {
                        resetAppState();
                        resetUI();
                        getEl('save-status').classList.add('opacity-0');
                    },
                    onCancel: ()=> {},
                    cancelText: 'Cancel'
                });
            }
            async function handleSohFileUpload(e) {
                const file = e.target.files[0];
                if (!file) return;
                getEl('initialSohFileName').textContent = file.name;
                showLoader();
                try {
                    resetAppState();
                    const data = await parseExcelFile(file);
                    if (!data?.length) throw new Error("File is empty or invalid.");
                    if (!data[0]?.BRANCH_NAME) throw new Error("'BRANCH_NAME' column is missing.");
                    
                    // Extract branch information
                    state.branchName = data[0].BRANCH_NAME;
                    
                    // Extract BRANCH_CODE if available
                    if (data[0]?.BRANCH_CODE) {
                        state.branchCode = data[0].BRANCH_CODE;
                    } else {
                        // If BRANCH_CODE column doesn't exist, try to extract from BRANCH_NAME
                        // Assume format like "001 - Branch Name" or similar
                        const branchNameMatch = state.branchName.match(/^(\d+)/);
                        state.branchCode = branchNameMatch ? branchNameMatch[1] : 'UNK';
                    }
                    
                    state.countDate = new Date().toLocaleDateString('en-CA');
                    const { forScan, forDemo, lookup } = processAndSeparateSoh(data);
                    if (Object.keys(lookup).length === 0) throw new Error("No valid stock items found. Check SKU/AVAILABLE_QTY columns.");
                    state.sohData = data;
                    state.sohLookup = lookup;
                    state.scannerMaster = forScan;
                    state.demoMaster = forDemo.map(item => ({ ...item, counted: null, reason: 'DEMO-Manual' }));
                    rebuildUiFromState();
                    setUnsavedChanges(true); 
                } catch (error) {
                    showModal("Error Processing File", error.message);
                    resetAppState();
                    resetUI();
                } finally {
                    hideLoader();
                }
            }            function handleSaveProgressToFile() {
                if (!state.sohData.length) {
                    return showModal("Info", "There is no progress to save.");
                }
                const stateToSave = { 
                    ...state, 
                    charts: {},
                    // Convert Set to Array for JSON serialization
                    sohUpdatedSkus: state.sohUpdatedSkus ? Array.from(state.sohUpdatedSkus) : []
                };
                const blob = new Blob([JSON.stringify(stateToSave, null, 2)], { type: 'application/json' });
                const branchInfo = state.branchCode ? `${state.branchCode}_${state.branchName.replace(/\s+/g, '_')}` : state.branchName.replace(/\s+/g, '_');
                const fileName = `${state.countDate}_stock_count_${branchInfo}.json`;
                downloadFile(blob, fileName);
                hasUnsavedChanges = false;
                showSaveStatus("Progress saved to file", false);
            }

            function handleLoadProgressFromFile(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const loadedState = JSON.parse(event.target.result);
                        if (!loadedState?.sohData?.length) throw new Error("Invalid or empty progress file.");
                        restoreState(loadedState);
                        showModal("Success", "Progress has been loaded.");
                    } catch(err) {
                        showModal("Error", "Could not parse the selected file. Please ensure it's a valid progress file.");
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            }
              function parseExcelFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const workbook = XLSX.read(e.target.result, { type: 'array' });
                            resolve(XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]]));
                        } catch (err) { reject(err); }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            }            function parseSalesExcelFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const workbook = XLSX.read(e.target.result, { 
                                type: 'array',
                                cellStyles: false,
                                cellNF: false,
                                cellDates: false
                            });
                            
                            const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                            
                            // Step 1: Unmerge all cells by expanding merged cell values
                            // Get the range of the worksheet
                            const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1:A1');
                            
                            // Process merged cells if they exist
                            if (worksheet['!merges']) {
                                worksheet['!merges'].forEach(merge => {
                                    // Get the value from the top-left cell of the merged range
                                    const topLeftCell = XLSX.utils.encode_cell({r: merge.s.r, c: merge.s.c});
                                    const mergedValue = worksheet[topLeftCell] ? worksheet[topLeftCell].v : '';
                                    
                                    // Fill all cells in the merged range with the same value
                                    for (let row = merge.s.r; row <= merge.e.r; row++) {
                                        for (let col = merge.s.c; col <= merge.e.c; col++) {
                                            const cellAddr = XLSX.utils.encode_cell({r: row, c: col});
                                            if (!worksheet[cellAddr]) {
                                                worksheet[cellAddr] = { t: 's', v: mergedValue };
                                            }
                                        }
                                    }
                                });
                                // Remove merge information
                                delete worksheet['!merges'];
                            }
                            
                            // Step 2: Convert to JSON array (this gives us all rows)
                            const jsonData = XLSX.utils.sheet_to_json(worksheet, { 
                                header: 1, // Use array format instead of object format
                                defval: '', // Default value for empty cells
                                raw: false // Convert values to strings
                            });
                            
                            // Step 3: Remove top 5 rows
                            const dataAfterTopRemoval = jsonData.slice(5);
                            
                            // Step 4: Remove blank rows from bottom
                            // Find the last row that has meaningful content
                            let lastMeaningfulRowIndex = -1;
                            for (let i = dataAfterTopRemoval.length - 1; i >= 0; i--) {
                                const row = dataAfterTopRemoval[i];
                                if (row && row.some(cell => cell && String(cell).trim() !== '')) {
                                    lastMeaningfulRowIndex = i;
                                    break;
                                }
                            }
                            
                            // Trim the array to remove blank rows from bottom
                            const cleanedData = lastMeaningfulRowIndex >= 0 
                                ? dataAfterTopRemoval.slice(0, lastMeaningfulRowIndex + 1)
                                : [];
                            
                            resolve(cleanedData);
                        } catch (err) { 
                            reject(err); 
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            }

            function processAndSeparateSoh(sohData) {
                const forScan = [], forDemo = [], lookup = {};
                const targetWhCode = sohData.find(row => row.WH_CODE)?.WH_CODE;
                if (!targetWhCode) throw new Error("Could not determine warehouse code (WH_CODE).");                
                sohData.filter(row => row.WH_CODE === targetWhCode).forEach(row => {
                    // Extract basic info first
                    const desc = String(row.DESCRIPTION || '').toUpperCase();
                    const family = String(row.FAMILY || '').toUpperCase();
                    const originalSku = String(row.SKU || '').trim().toUpperCase();
                    
                    // DEMO detection logic - matches Excel conditions on ORIGINAL SKU column:
                    // 1. LEFT(SKU,1)="D" 
                    // 2. ISNUMBER(SEARCH("DEMO",SKU))
                    // 3. ISNUMBER(SEARCH("DEMO",Description))
                    // 4. Family="DEMO"
                    const isDemo = (
                        !originalSku.startsWith('DLCGZ') && (
                            originalSku.startsWith('D') ||           // Condition 1: First character is 'D'
                            originalSku.includes('DEMO') ||          // Condition 2: SKU contains "DEMO" anywhere
                            desc.includes('DEMO') ||                 // Condition 3: Description contains "DEMO"
                            family === 'DEMO'                       // Condition 4: Family equals "DEMO"
                        )
                    );
                    
                    // NOW do serial/SKU combination logic
                    const isSerial = !!row.SERIAL_NO;
                    const sku = String(isSerial ? row.SERIAL_NO : row.SKU || '').replace(/\./g, ' ').trim().toUpperCase();
                    if (!sku) return;
                    const isSerialControlled = row.SERIAL_CONTROL === 'Y' || isSerial;
                    const qty = parseInt(String(row.AVAILABLE_QTY ?? 0).replace(/,/g, ''), 10);                    
                    const srpRaw = row.SRP_AMT_INC_VAT;
                    const srp = srpRaw === null || srpRaw === undefined || srpRaw === '' ? 0 : parseFloat(String(srpRaw).replace(/,/g, ''));
                    if (lookup[sku] && !isSerialControlled) {
                        const existing = lookup[sku];
                        const newTotalQty = existing.SOH + qty;
                        const newTotalSrpValue = (existing.SOH * existing.Price) + (qty * srp);
                        existing.SOH = newTotalQty;
                        existing.Price = newTotalQty > 0 ? newTotalSrpValue / newTotalQty : 0;
                        // Update flags if any instance is DEMO
                        existing.isDemo = existing.isDemo || isDemo;
                    } else if (!lookup[sku]) {
                        lookup[sku] = {
                            SKU: sku,
                            Description: (row.DESCRIPTION || '').replace(/,/g, ' '),
                            SOH: qty,
                            Price: srp,
                            Age: row.AGE,
                            CLASS_NAME: row.CLASS_NAME || 'UNCATEGORIZED',
                            FAMILY: row.FAMILY || '',
                            isSerialControlled,
                            isDemo
                        };
                    }
                });
                Object.values(lookup).forEach(item => {
                    if (item.SOH > 0) (item.isDemo ? forDemo : forScan).push(item);
                });
                return { forScan, forDemo, lookup };
            }            function restoreState(loadedState) {
                resetAppState();
                state = { ...state, ...loadedState, charts: getInitialState().charts };
                
                // Handle SOH updated SKUs - convert array back to Set if needed
                if (loadedState.sohUpdatedSkus) {
                    if (Array.isArray(loadedState.sohUpdatedSkus)) {
                        state.sohUpdatedSkus = new Set(loadedState.sohUpdatedSkus);
                    } else if (loadedState.sohUpdatedSkus instanceof Set) {
                        state.sohUpdatedSkus = loadedState.sohUpdatedSkus;
                    }
                } else {
                    state.sohUpdatedSkus = new Set();
                }
                
                const { forScan, forDemo, lookup } = processAndSeparateSoh(state.sohData);
                state.sohLookup = lookup;
                state.scannerMaster = forScan;                state.demoMaster = forDemo.map(item => ({ 
                    ...item, 
                    counted: state.demoCounts[item.SKU]?.qty ?? null,
                    reason: state.demoCounts[item.SKU]?.reason ?? 'DEMO-Manual' 
                }));
                rebuildUiFromState();
            }

            function downloadFile(content, fileName) {
                const blob = (typeof content === 'string') ? new Blob([content], { type: 'text/csv;charset=utf-8;' }) : content;
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
            
            function rebuildUiFromState() {
                if (state.sohData.length > 0) {
                    getEl('workspace-container').classList.remove('hidden');
                    getEl('upload-container').classList.add('hidden');
                    getEl('downloadMasterForScan').disabled = false;
                    updateInfoBox();
                    applyDemoView();
                    if (state.netDiffData.length > 0) {
                        renderFirstCountSummary();
                        getEl('step2-results').classList.remove('hidden');
                        getEl('finalizeFromFirstCount').disabled = false;
                        getEl('generateRecountMasterFile').disabled = false;
                        getEl('latestSohFile').disabled = false;
                    }
                    if (state.reconciledData.length > 0) {
                        applyFinalReportView();
                        renderFinalReportCharts();
                        getEl('final-report-container').classList.remove('hidden');
                    }
                    switchMainTab('demo');
                } else {
                    resetUI();
                }
            }
            
            function switchMainTab(tabName) {
                const isDemo = tabName === 'demo';
                getEl('main-panel-demo').classList.toggle('hidden', !isDemo);
                getEl('main-panel-workflow').classList.toggle('hidden', isDemo);
                getEl('main-tab-demo').classList.toggle('active', isDemo);
                getEl('main-tab-workflow').classList.toggle('active', !isDemo);
            }

            function changeWorkflowTab(tabIndex) {
                document.querySelectorAll('.workflow-step').forEach(div => div.classList.add('hidden'));
                getEl(`wf-step${tabIndex}`).classList.remove('hidden');
                document.querySelectorAll('#wf-step-tabs .tab-button').forEach(btn => btn.classList.remove('active'));
                getEl(`wf-tab-btn-${tabIndex}`).classList.add('active');
            }

            function handleSort(sortKey, column, applyViewFn) {
                const sortState = state[sortKey];
                if (sortState.column === column) {
                    sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    sortState.column = column;
                    sortState.direction = 'asc';
                }
                applyViewFn();
                setUnsavedChanges(true);
            }

            function getDiffColorClass(diff) {
                if (diff < 0) return 'text-red-600 font-bold';
                if (diff > 0) return 'text-yellow-500 font-bold';
                return 'text-green-600 font-bold';
            }            
            function applyDemoView() {
                if (state.demoMaster.length === 0) {
                    getEl('demo-count-container').innerHTML = '<p class="p-6 text-center text-slate-500">No DEMO items found.</p>';
                    updateDemoSummary();
                    return;
                }
                const searchValue = getEl('demoSearchInput').value.toUpperCase();
                const filterValue = getEl('demoFilterSelect').value;
                let dataView = state.demoMaster.filter(item => {
                    if (!(item.SKU.toUpperCase().includes(searchValue) || item.Description.toUpperCase().includes(searchValue))) return false;
                    const diff = (item.counted === null) ? null : item.counted - item.SOH;
                    if (filterValue === 'uncounted') return item.counted === null;
                    if (filterValue === 'discrepancy') return diff !== null && diff !== 0;
                    if (filterValue === 'matched') return diff !== null && diff === 0;
                    return true;
                });
                const { column, direction } = state.demoSort;
                dataView.sort((a, b) => {
                    let valA, valB;
                    
                    // Handle special calculated field "diff"
                    if (column === 'diff') {
                        valA = (a.counted === null) ? null : a.counted - a.SOH;
                        valB = (b.counted === null) ? null : b.counted - b.SOH;
                    } else if (column === 'counted') {
                        valA = a.counted;
                        valB = b.counted;
                    } else {
                        valA = a[column];
                        valB = b[column];
                    }
                    
                    // Handle null/undefined values
                    if (valA === null || valA === undefined) return 1;
                    if (valB === null || valB === undefined) return -1;
                    
                    // Sort by data type
                    if (typeof valA === 'string') {
                        return direction === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                    }
                    return direction === 'asc' ? valA - valB : valB - valA;
                });
                renderDemoCountTable(dataView);
                updateDemoSummary();
            }            
            function renderDemoCountTable(data) {
                const container = getEl('demo-count-container');
                // Responsive table styling
                const headers = `<thead><tr>
                    <th class="p-3 text-center w-12">NO.</th>
                    <th class="p-3 text-left" data-sort-by="SKU">SKU<span class="sort-indicator"></span></th>
                    <th class="p-3 text-left" data-sort-by="Description">Description<span class="sort-indicator"></span></th>
                    <th class="p-3 text-center" data-sort-by="Price">SRP<span class="sort-indicator"></span></th>
                    <th class="p-3 text-center" data-sort-by="Age">Age<span class="sort-indicator"></span></th>
                    <th class="p-3 text-center" data-sort-by="SOH">SOH<span class="sort-indicator"></span></th>
                    <th class="p-3 text-center" data-sort-by="counted">Counted<span class="sort-indicator"></span></th>
                    <th class="p-3 text-center" data-sort-by="diff">Diff<span class="sort-indicator"></span></th>
                    <th class="p-3 text-center" data-sort-by="remark">Remark<span class="sort-indicator"></span></th>
                </tr></thead>`;
                const body = data.length > 0 ? data.map((item, idx) => renderDemoTableRow(item, idx)).join('') : `<tr><td colspan="9" class="text-center p-6 text-slate-500">No items match filter.</td></tr>`;
                container.innerHTML = `<table class="w-full text-sm">${headers}<tbody>${body}</tbody></table>`;
                
                // Update sort indicators with colors
                const sortingTh = container.querySelector(`th[data-sort-by="${state.demoSort.column}"]`);
                if (sortingTh) {
                    const indicator = sortingTh.querySelector('.sort-indicator');
                    indicator.textContent = state.demoSort.direction === 'asc' ? '‚ñ≤' : '‚ñº';
                    // Add color: green for ascending, red for descending
                    indicator.style.color = state.demoSort.direction === 'asc' ? '#22c55e' : '#ef4444';
                }
            }

            function renderDemoTableRow(item, idx) {
                const diff = (item.counted === null) ? null : item.counted - item.SOH;
                const diffText = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
                let { rowClass } = getRowVisuals(diff, true);
                return `<tr class="border-b border-slate-200 transition-colors duration-200 ${rowClass}" data-sku="${item.SKU}">
                    <td class="p-3 text-center">${idx + 1}</td>
                    <td class="p-3 font-medium text-slate-700">${item.SKU}</td>
                    <td class="p-3 text-slate-600">${item.Description}</td>
                    <td class="p-3 text-center text-slate-600">${item.Price ?? 0}</td>
                    <td class="p-3 text-center text-slate-600">${item.Age || 'N/A'}</td>
                    <td class="p-3 text-center text-slate-600">${item.SOH}</td>
                    <td class="p-3 text-center text-slate-600"><input type="number" value="${item.counted ?? ''}" class="w-full text-center p-1.5 border border-slate-300 rounded-md bg-white"/></td>
                    <td class="p-3 text-center font-bold diff-cell ${getDiffColorClass(diff)}">${diffText}</td>
                    <td class="p-3 text-center"><input type="text" value="${item.remark ?? ''}" class="w-full text-center p-1.5 border border-slate-300 rounded-md bg-white"/></td>
                </tr>`;
            }

            function updateDemoSummary() {
                const totalSOH = state.demoMaster.reduce((sum, item) => sum + item.SOH, 0);
                const totalSOHPrice = state.demoMaster.reduce((sum, item) => sum + (item.SOH * (item.Price ?? 0)), 0);
                const countedSKUs = Object.values(state.demoCounts).filter(c => c.qty !== null).length;
                const countedSOHValue = state.demoMaster.reduce((sum, item) => {
                    const counted = state.demoCounts[item.SKU]?.qty;
                    return sum + ((counted ?? 0) * (item.Price ?? 0));
                }, 0);
                const countedSOH = state.demoMaster.reduce((sum, item) => {
                    const counted = state.demoCounts[item.SKU]?.qty;
                    return sum + (counted ?? 0);
                }, 0);
                const diffItems = state.demoMaster.filter(item => { const countInfo = state.demoCounts[item.SKU]; return countInfo && countInfo.qty !== null && countInfo.qty !== item.SOH; }).length;
                getEl('demo-summary').innerHTML = `
                    <div class="flex justify-between gap-4"><span>Total DEMO SOH:</span><span class="font-bold">${formatNumber(totalSOH)}</span></div>
                    <div class="flex justify-between gap-4"><span>Total DEMO SOH Value:</span><span class="font-bold text-blue-600">${formatNumber(totalSOHPrice)}</span></div>
                    <div class="flex justify-between gap-4"><span>Counted DEMO SOH:</span><span class="font-bold text-green-600">${formatNumber(countedSOH)}</span></div>
                    <div class="flex justify-between gap-4"><span>Counted DEMO SOH Value:</span><span class="font-bold text-green-600">${formatNumber(countedSOHValue)}</span></div>
                    <div class="flex justify-between gap-4"><span>Total DEMO SKUs:</span><span class="font-bold">${formatNumber(state.demoMaster.length)}</span></div>
                    <div class="flex justify-between gap-4"><span>Counted SKUs:</span><span class="font-bold text-green-600">${countedSKUs}</span></div>
                    <div class="flex justify-between gap-4"><span>Discrepancies:</span><span class="font-bold text-red-600">${diffItems}</span></div>
                `;
            }

            function updateDemoCount(sku, value) {
                const item = state.demoMaster.find(i => i.SKU === sku);
                if (!item) return;
                const intValue = value === '' ? null : parseInt(value, 10);
                item.counted = isNaN(intValue) ? null : intValue;                if (intValue === null) delete state.demoCounts[sku];
                else state.demoCounts[sku] = { qty: intValue, reason: 'DEMO-Manual' };
                if (state.reconciledData.length > 0) {
                    const reportItem = state.reconciledData.find(i => i.SKU === sku);
                    if (reportItem) {
                        const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(sku);
                        reportItem.Recount = intValue ?? 0;
                        reportItem.FinalDiff = reportItem.Recount - reportItem.SOH;
                        reportItem.ReasonFinal = wasSohUpdated ? 'SOHupdated-DEMO-Manual' : 'DEMO-Manual';
                        applyFinalReportView();
                        renderFinalReportCharts();
                    }
                }
                const row = getEl('demo-count-container').querySelector(`tr[data-sku="${sku}"]`);
                if (row) {
                    const diff = item.counted === null ? null : item.counted - item.SOH;
                    row.querySelector('.diff-cell').textContent = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
                    row.querySelector('.diff-cell').className = `p-3 text-center font-bold diff-cell ${getDiffColorClass(diff)}`;
                    updateTableRowVisuals(row, diff, true);
                }
                updateDemoSummary();
                updateFinalReportSummary();
                setUnsavedChanges(true);
            }
              function exportDemoTable() {
                const dataToExport = state.demoMaster.map((item, idx) => ({ 
                    NO: idx + 1, 
                    SKU: item.SKU, 
                    Description: item.Description, 
                    SRP: item.Price, 
                    Age: item.Age, 
                    SOH: item.SOH, 
                    Counted: item.counted, 
                    Diff: item.counted === null ? '' : item.counted - item.SOH,
                    Flag: item.isDemo ? 'DEMO' : 'NONE'
                }));
                const csv = Papa.unparse(dataToExport, { header: true });
                const branchInfo = state.branchCode ? `${state.branchCode}_${state.branchName.replace(/\s+/g, '_')}` : state.branchName.replace(/\s+/g, '_');
                downloadFile(csv, `${state.countDate}_DEMO_Count_${branchInfo}.csv`);
            }
            function downloadMasterForScan() {
                // Exclude DEMO items using processed flags
                const scanRows = Object.values(state.sohLookup).filter(item => !item.isDemo && item.SOH > 0);
                const rowsForCsv = scanRows.map(item => [item.SKU, item.Description, item.Price, item.Age, item.SOH]);
                
                // Use new file naming convention: Master_branchcode_date.csv
                const branchInfo = state.branchCode ? `${state.branchCode}_${state.countDate}` : `${state.branchName.replace(/\s+/g, '_')}_${state.countDate}`;
                const fileName = `Master_${branchInfo}.csv`;
                downloadFile(Papa.unparse(rowsForCsv, { header: false }), fileName);
            }
            
            async function processFirstCount() {
                showLoader('Processing First Count...');
                try {
                    const logFiles = getEl('firstScanLogfile').files;
                    const masterFile = getEl('firstMasterFile').files[0];
                    
                    if (!logFiles.length && !masterFile) {
                        throw new Error("Please upload at least one file (Logfile or Master.csv) for the first count.");
                    }
                    
                    if (!state.sohData.length) {
                        throw new Error("Please upload SOH data first.");
                    }
                    
                    let scanCounts = [];
                    
                    // Process Logfile(s) if uploaded
                    if (logFiles.length > 0) {
                        const logfileData = await (async function(files){ 
                            const p = Array.from(files).map(f => new Promise((res, rej) => { 
                                Papa.parse(f, { 
                                    skipEmptyLines: true, 
                                    complete: r => { 
                                        const d = r.data.map(row => { 
                                            if(!row || row.length < 3 || !row[2]) return null; 
                                            const sku = String(row[2]).trim(); 
                                            const qty = parseInt(String(row[4] ?? 1).replace(/,/g,''), 10); 
                                            return {sku, qty: isNaN(qty) ? 1: qty};
                                        }).filter(Boolean); 
                                        res(d); 
                                    }, 
                                    error: rej
                                }); 
                            })); 
                            return Promise.all(p).then(r => r.flat()); 
                        })(logFiles);
                        scanCounts = scanCounts.concat(logfileData);
                    }
                    
                    // Process Master.csv if uploaded
                    if (masterFile) {
                        const masterData = await new Promise((resolve, reject) => {
                            Papa.parse(masterFile, {
                                skipEmptyLines: true,
                                complete: result => {
                                    try {
                                        const data = result.data.map(row => {
                                            if (!row || row.length < 6 || !row[0]) return null;
                                            const sku = String(row[0]).trim(); // Column 1: Part No.
                                            const qty = parseInt(String(row[5] || '0').replace(/,/g, ''), 10); // Column 6: Actual Qty
                                            // Only include items that were actually counted (qty > 0)
                                            if (isNaN(qty) || qty <= 0) return null;
                                            return { sku, qty };
                                        }).filter(Boolean);
                                        resolve(data);
                                    } catch (error) {
                                        reject(error);
                                    }
                                },
                                error: reject
                            });
                        });
                        scanCounts = scanCounts.concat(masterData);
                    }                    const processedCounts = {};
                    for(const item of scanCounts){ 
                        const {sku, qty} = item; 
                        const isSerial = state.sohLookup[sku] ? state.sohLookup[sku].isSerialControlled : false; 
                        if(isSerial){ 
                            if(!processedCounts[sku]) processedCounts[sku] = {qty: 1, reason: 'Scan'};
                        } else { 
                            const currentQty = processedCounts[sku] ? processedCounts[sku].qty : 0; 
                            processedCounts[sku] = {qty: currentQty + qty, reason: 'Scan'};
                        }
                    }
                    const combinedCounts = { ...processedCounts, ...state.demoCounts };
                    const netDiffMap = new Map(Object.values(state.sohLookup).filter(item => item.SOH > 0).map(item => [item.SKU, { ...item, Scan1: 0, Reason1: '' }]));
                    for (const [sku, data] of Object.entries(combinedCounts)) {
                        const entry = netDiffMap.get(sku);
                        if (entry) { entry.Scan1 = data.qty; entry.Reason1 = data.reason; }
                    }                    state.netDiffData = Array.from(netDiffMap.values()).map(item => {
                        // Check if this item already has sales data in reconciledData
                        const existingReconciledItem = state.reconciledData.find(r => r.SKU === item.SKU);
                        const hasSalesData = existingReconciledItem && 
                            existingReconciledItem.ReasonFinal && 
                            existingReconciledItem.ReasonFinal.includes('Sales:');
                        
                        if (hasSalesData) {
                            // Preserve sales data and add first count on top
                            const salesMatch = existingReconciledItem.ReasonFinal.match(/Sales: (\d+) units added/);
                            const salesQty = salesMatch ? parseInt(salesMatch[1], 10) : 0;
                            
                            return {
                                ...item, 
                                Counted1: item.Scan1,
                                Diff1: item.Scan1 - item.SOH, 
                                Recount: item.Scan1 + salesQty, 
                                FinalDiff: (item.Scan1 + salesQty) - item.SOH, 
                                ReasonFinal: item.Reason1 ? `${item.Reason1} + ${existingReconciledItem.ReasonFinal}` : existingReconciledItem.ReasonFinal, 
                                Remark: existingReconciledItem.Remark || ''
                            };
                        } else {
                            // Normal processing without existing sales data
                            return {
                                ...item, 
                                Counted1: item.Scan1,
                                Diff1: item.Scan1 - item.SOH, 
                                Recount: item.Scan1, 
                                FinalDiff: item.Scan1 - item.SOH, 
                                ReasonFinal: item.Reason1, 
                                Remark: '' 
                            };
                        }
                    });
                    renderFirstCountSummary();
                    getEl('step2-results').classList.remove('hidden');
                    getEl('finalizeFromFirstCount').disabled = false;
                    getEl('generateRecountMasterFile').disabled = false;
                    getEl('latestSohFile').disabled = false;
                    setUnsavedChanges(true);
                    
                    // Generate success message showing what files were processed
                    let processedFiles = [];
                    if (logFiles.length > 0) processedFiles.push(`${logFiles.length} Logfile(s)`);
                    if (masterFile) processedFiles.push('Master.csv');
                    const message = `First count processed successfully using: ${processedFiles.join(' and ')}.`;
                    
                    showModal("Success", message);
                } catch (error) {
                    showModal("Error", `Processing failed: ${error.message}`);
                } finally {
                    hideLoader();
                }
            }
            
            function renderFirstCountSummary() {
                const summary = state.netDiffData.reduce((acc, item) => { acc.totalSOH += item.SOH; if (item.Scan1 !== 0 || item.Reason1) acc.countedSOH += item.SOH; return acc; }, { totalSOH: 0, countedSOH: 0 });
                const uncountedSOH = summary.totalSOH - summary.countedSOH;
                getEl('netdiff-summary-container').innerHTML = `<div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center"><div class="p-4 bg-blue-100 rounded-lg"><p class="font-medium text-blue-800">Total SOH</p><p class="text-3xl font-bold text-blue-600 mt-1">${formatNumber(summary.totalSOH)}</p></div><div class="p-4 bg-green-100 rounded-lg"><p class="font-medium text-green-800">Counted SOH</p><p class="text-3xl font-bold text-green-600 mt-1">${formatNumber(summary.countedSOH)}</p></div><div class="p-4 bg-red-100 rounded-lg"><p class="font-medium text-red-800">Uncounted SOH</p><p class="text-3xl font-bold text-red-600 mt-1">${formatNumber(uncountedSOH)}</p></div></div>`;
            }            
            function finalizeFromFirstCount() {
                if (!state.netDiffData.length) return showModal("Warning", "Please process the first count (Step 2).");
                // --- Patch: Sync latest DEMO counts before finalizing ---
                state.netDiffData.forEach(item => {
                    if (item.isDemo) {
                        // Check if item has been manually edited in final table
                        const existingReconciledItem = state.reconciledData.find(r => r.SKU === item.SKU);
                        const hasManualEdit = existingReconciledItem && existingReconciledItem.ReasonFinal === 'Manual Edit';
                        
                        if (hasManualEdit) {
                            // Skip updating - preserve manual edit
                            return;
                        }                        
                        const demoCount = state.demoCounts[item.SKU];
                        const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(item.SKU);                        if (demoCount && typeof demoCount.qty === 'number') {
                            item.Recount = demoCount.qty;
                            item.FinalDiff = demoCount.qty - item.SOH;
                            const baseReason = demoCount.reason || 'DEMO-Manual';
                            item.ReasonFinal = wasSohUpdated ? `SOHupdated-${baseReason}` : baseReason;                        } else {
                            item.Recount = 0;
                            item.FinalDiff = -item.SOH;
                            item.ReasonFinal = wasSohUpdated ? 'SOHupdated-DEMO-N/A' : 'DEMO-N/A';
                        }
                    }
                });
                state.reconciledData = state.netDiffData.map(item => {
                    // Check if item already has sales data in reconciledData
                    const existingReconciledItem = state.reconciledData.find(r => r.SKU === item.SKU);
                    const hasSalesData = existingReconciledItem && 
                        existingReconciledItem.ReasonFinal && 
                        existingReconciledItem.ReasonFinal.includes('Sales:');
                    
                    if (hasSalesData) {
                        // Preserve sales data from existing reconciledData
                        return {
                            ...item,
                            Recount: existingReconciledItem.Recount,
                            FinalDiff: existingReconciledItem.FinalDiff,
                            ReasonFinal: item.ReasonFinal ? `${item.ReasonFinal} + ${existingReconciledItem.ReasonFinal}` : existingReconciledItem.ReasonFinal,
                            Remark: existingReconciledItem.Remark || ''
                        };
                    } else {
                        // No existing sales data - use item as is
                        return {...item};
                    }
                });
                applyFinalReportView();
                renderFinalReportCharts();
                getEl('final-report-container').classList.remove('hidden');
                getEl('final-report-container').scrollIntoView({ behavior: 'smooth' });
                setUnsavedChanges(true);
            }            async function processSalesData() {
                showLoader('Processing Sales Data...');
                try {
                    const salesFile = getEl('salesDataFile').files[0];
                    if (!salesFile) throw new Error("Please select a sales data file.");

                    const salesData = await parseSalesExcelFile(salesFile);
                    if (!salesData?.length) throw new Error("Sales data file is empty or invalid after processing.");                    // Filter out completely empty rows (already cleaned by parseSalesExcelFile)
                    const cleanedData = salesData.filter(row => {
                        // Row is now an array, check if it has meaningful data
                        return Array.isArray(row) && row.some(cell => cell && String(cell).trim() !== '');
                    });

                    if (!cleanedData.length) throw new Error("No valid sales data found after cleaning.");

                    // Process sales data - extract relevant columns
                    const processedSales = [];
                    const salesMap = new Map(); // For aggregating by SKU
                      cleanedData.forEach((row, index) => {
                        try {
                            // Row is now an array, access columns directly by index (0-based)
                            const serial = row[53] || null; // Column 54 (Serial) -> index 53
                            const productName = row[19] || null; // Column 20 (Product Name) -> index 19
                            const qty = row[26] || null; // Column 27 (QTY) -> index 26
                            const billNo = row[9] || null; // Column 10 (Bill No) -> index 9

                            if (serial && qty && !isNaN(parseFloat(qty))) {
                                // Apply the same SKU transformation as SOH processing
                                const sku = String(serial).replace(/\./g, ' ').trim().toUpperCase();
                                const quantity = Math.abs(parseFloat(qty)); // Use absolute value
                                const product = String(productName || '').trim();
                                const bill = String(billNo || '').trim();

                                // Use enhanced matching to find the item in sohLookup
                                const allSohItems = Object.values(state.sohLookup);
                                const matchedItem = findItemByScannedText(allSohItems, sku);
                                
                                // Use the matched SKU if found, otherwise use the original
                                const finalSku = matchedItem ? matchedItem.SKU : sku;

                                if (salesMap.has(finalSku)) {
                                    const existing = salesMap.get(finalSku);
                                    existing.totalQty += quantity;
                                    existing.bills.push(bill);
                                } else {
                                    salesMap.set(finalSku, {
                                        sku: finalSku,
                                        productName: product,
                                        totalQty: quantity,
                                        bills: [bill],
                                        originalSerial: sku, // Keep track of original for debugging
                                        matched: !!matchedItem
                                    });
                                }
                            }
                        } catch (rowError) {
                            // Skip problematic rows silently
                        }
                    });

                    const salesSummary = Array.from(salesMap.values());

                    // Calculate matching statistics for debugging
                    const matchedCount = salesSummary.filter(sale => sale.matched).length;
                    const unmatchedCount = salesSummary.length - matchedCount;                    // Apply sales data to tracking - simplified approach
                    let adjustedItems = 0;
                    if (state.sohLookup && Object.keys(state.sohLookup).length > 0) {
                        salesSummary.forEach(sale => {
                            if (state.sohLookup[sale.sku]) {
                                adjustedItems++;
                                // Note: We no longer track SalesDuringCount in sohLookup 
                                // as sales are directly added to final count in the processing above
                            }
                        });                          // Update netDiffData if it exists - enhanced sales integration with new conditions
                        if (state.netDiffData.length > 0) {
                            state.netDiffData.forEach(item => {
                                const sale = salesSummary.find(s => s.sku === item.SKU);
                                if (sale) {
                                    const billNumbers = sale.bills.filter(bill => bill.trim() !== '').join(', ');
                                      // Check if this item already has any count (manual, first count, or recount)
                                    const hasExistingCount = (
                                        // Has been manually counted
                                        (item.ReasonFinal && (item.ReasonFinal.includes('Manual') || item.ReasonFinal.includes('Re-Scan') || item.ReasonFinal.includes('Scan'))) ||
                                        // Has been counted in first count (Scan1 > 0 or has Reason1)
                                        (item.Scan1 > 0 || (item.Reason1 && item.Reason1.trim() !== '')) ||
                                        // Has been recounted (Recount different from initial and not due to previous sales)
                                        (item.Recount !== item.Scan1 && !item.ReasonFinal?.includes('Sales:')) ||
                                        // Has any counting reason that's not sales-related (excluding uncounted items)
                                        (item.ReasonFinal && !item.ReasonFinal.includes('Sales:') && item.ReasonFinal.trim() !== '' && item.ReasonFinal !== 'DEMO-N/A' && !item.ReasonFinal.includes('N/A'))
                                    );
                                    
                                    if (hasExistingCount) {
                                        // Skip updating count, only add "sold now" to remark
                                        const soldNowText = `Sold now: ${billNumbers}`;
                                        if (item.Remark && item.Remark.trim() !== '') {
                                            // Remove any previous "sold now" entries before adding new one
                                            item.Remark = item.Remark.replace(/\s*\|\s*Sold now:[^|]*/g, '');
                                            item.Remark += ` | ${soldNowText}`;
                                        } else {
                                            item.Remark = soldNowText;
                                        }
                                    } else {
                                        // Check if this is a re-processing of sales data (overwrite mode)
                                        const hasPreviousSales = item.ReasonFinal && item.ReasonFinal.includes('Sales:');
                                        
                                        if (hasPreviousSales) {
                                            // Overwrite previous sales data instead of adding up
                                            // First, remove previous sales count addition
                                            const previousSalesMatch = item.ReasonFinal.match(/Sales: (\d+) units added/);
                                            if (previousSalesMatch) {
                                                const previousSalesQty = parseInt(previousSalesMatch[1], 10);
                                                item.Recount = Math.max(0, item.Recount - previousSalesQty);
                                            }
                                            
                                            // Remove previous sales bill numbers from remarks
                                            if (item.Remark) {
                                                item.Remark = item.Remark.replace(/\s*\|\s*Bills:[^|]*/g, '');
                                                item.Remark = item.Remark.replace(/^Bills:[^|]*\s*\|\s*/, '');
                                                item.Remark = item.Remark.replace(/^Bills:[^|]*$/, '');
                                            }
                                        }
                                          // Apply new sales data
                                        item.Recount = (item.Recount || 0) + sale.totalQty;
                                        item.FinalDiff = item.Recount - item.SOH;
                                        
                                        // Update reason to indicate sales during count with SOH tracking
                                        const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(item.SKU);
                                        const salesReason = `Sales: ${sale.totalQty} units added`;
                                        item.ReasonFinal = wasSohUpdated ? `SOHupdated-${salesReason}` : salesReason;
                                        
                                        // Add bill numbers to remarks
                                        if (billNumbers) {
                                            if (item.Remark && item.Remark.trim() !== '') {
                                                item.Remark += ` | Bills: ${billNumbers}`;
                                            } else {
                                                item.Remark = `Bills: ${billNumbers}`;
                                            }
                                        }
                                    }
                                }
                            });                        
                        }                        // Update reconciledData if it exists - enhanced sales integration with same conditions
                        if (state.reconciledData.length > 0) {
                            state.reconciledData.forEach(item => {
                                const sale = salesSummary.find(s => s.sku === item.SKU);
                                if (sale) {
                                    const billNumbers = sale.bills.filter(bill => bill.trim() !== '').join(', ');
                                    
                                    // Check if this item already has any count (manual, first count, or recount)
                                    const hasExistingCount = (
                                        // Has been manually counted
                                        (item.ReasonFinal && (item.ReasonFinal.includes('Manual') || item.ReasonFinal.includes('Re-Scan') || item.ReasonFinal.includes('Scan'))) ||
                                        // Has been counted in first count (Scan1 > 0 or has Reason1)
                                        (item.Scan1 > 0 || (item.Reason1 && item.Reason1.trim() !== '')) ||
                                        // Has been recounted (Recount different from initial and not due to previous sales)
                                        (item.Recount !== item.Scan1 && !item.ReasonFinal?.includes('Sales:')) ||
                                        // Has any counting reason that's not sales-related (excluding uncounted items)
                                        (item.ReasonFinal && !item.ReasonFinal.includes('Sales:') && item.ReasonFinal.trim() !== '' && item.ReasonFinal !== 'DEMO-N/A' && !item.ReasonFinal.includes('N/A'))
                                    );
                                    
                                    if (hasExistingCount) {
                                        // Skip updating count, only add "sold now" to remark
                                        const soldNowText = `Sold now: ${billNumbers}`;
                                        if (item.Remark && item.Remark.trim() !== '') {
                                            // Remove any previous "sold now" entries before adding new one
                                            item.Remark = item.Remark.replace(/\s*\|\s*Sold now:[^|]*/g, '');
                                            item.Remark += ` | ${soldNowText}`;
                                        } else {
                                            item.Remark = soldNowText;
                                        }
                                    } else {
                                        // Check if this is a re-processing of sales data (overwrite mode)
                                        const hasPreviousSales = item.ReasonFinal && item.ReasonFinal.includes('Sales:');
                                        
                                        if (hasPreviousSales) {
                                            // Overwrite previous sales data instead of adding up
                                            // First, remove previous sales count addition
                                            const previousSalesMatch = item.ReasonFinal.match(/Sales: (\d+) units added/);
                                            if (previousSalesMatch) {
                                                const previousSalesQty = parseInt(previousSalesMatch[1], 10);
                                                item.Recount = Math.max(0, item.Recount - previousSalesQty);
                                            }
                                            
                                            // Remove previous sales bill numbers from remarks
                                            if (item.Remark) {
                                                item.Remark = item.Remark.replace(/\s*\|\s*Bills:[^|]*/g, '');
                                                item.Remark = item.Remark.replace(/^Bills:[^|]*\s*\|\s*/, '');
                                                item.Remark = item.Remark.replace(/^Bills:[^|]*$/, '');
                                            }
                                        }
                                          // Add sales count directly to final count (not reducing SOH)
                                        item.Recount = (item.Recount || 0) + sale.totalQty;
                                        item.FinalDiff = item.Recount - item.SOH;
                                          // Update reason to indicate sales during count with SOH tracking
                                        const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(item.SKU);
                                        const salesReason = `Sales: ${sale.totalQty} units added`;
                                        item.ReasonFinal = wasSohUpdated ? `SOHupdated-${salesReason}` : salesReason;
                                        
                                        // Add bill numbers to remarks
                                        if (billNumbers) {
                                            if (item.Remark && item.Remark.trim() !== '') {
                                                item.Remark += ` | Bills: ${billNumbers}`;
                                            } else {
                                                item.Remark = `Bills: ${billNumbers}`;
                                            }
                                        }
                                    }
                                }
                            });
                            applyFinalReportView();
                            renderFinalReportCharts();
                        }
                    }                    
                    // Display results
                    const resultsEl = getEl('sales-processing-results');
                    
                    // Create matched sales table
                    const matchedSales = salesSummary.filter(sale => sale.matched);
                    const matchedSalesTable = matchedSales.length > 0 ? `
                        <div class="mt-4">
                            <h5 class="font-medium text-slate-700 mb-2">üìã Matched Sales Records</h5>
                            <div class="max-h-64 overflow-y-auto border border-slate-200 rounded-lg">
                                <table class="w-full text-xs">
                                    <thead class="bg-slate-50 sticky top-0">
                                        <tr>
                                            <th class="p-2 text-left font-medium text-slate-600">SKU</th>
                                            <th class="p-2 text-center font-medium text-slate-600">Qty</th>
                                            <th class="p-2 text-left font-medium text-slate-600">Bill Numbers</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${matchedSales.map(sale => `
                                            <tr class="border-b border-slate-100 hover:bg-slate-50">
                                                <td class="p-2 font-mono text-slate-700">${sale.sku}</td>
                                                <td class="p-2 text-center text-orange-600 font-medium">${sale.totalQty}</td>
                                                <td class="p-2 text-slate-600 text-xs">${sale.bills.filter(bill => bill.trim() !== '').join(', ') || 'N/A'}</td>
                                            </tr>
                                        `).join('')}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    ` : '';
                    
                    resultsEl.innerHTML = `
                        <div class="space-y-2">
                            <div class="flex justify-between">
                                <span>üìä Total Sales Records:</span>
                                <span class="font-bold text-blue-600">${salesSummary.length}</span>
                            </div>
                            <div class="flex justify-between">
                                <span>‚úÖ SKUs Matched:</span>
                                <span class="font-bold text-green-600">${matchedCount}</span>
                            </div>
                            <div class="flex justify-between">
                                <span>‚ùå SKUs Not Matched:</span>
                                <span class="font-bold text-orange-600">${unmatchedCount}</span>
                            </div>
                            <div class="flex justify-between">
                                <span>üîÑ Items with Sales Data:</span>
                                <span class="font-bold text-green-600">${adjustedItems}</span>
                            </div>
                            ${matchedSalesTable}
                            ${unmatchedCount > 0 ? `
                            <div class="mt-3 text-xs text-slate-600">
                                <details class="cursor-pointer">
                                    <summary class="font-medium text-orange-600">Debug: Unmatched SKUs (Top 5)</summary>
                                    <div class="mt-2 space-y-1 max-h-32 overflow-y-auto">
                                        ${salesSummary.filter(sale => !sale.matched).slice(0, 5).map(sale => 
                                            `<div class="text-xs text-orange-600">
                                                <div>Original: "${sale.originalSerial}"</div>
                                                <div>Processed: "${sale.sku}"</div>
                                                <div class="text-slate-400 mb-1">---</div>
                                            </div>`
                                        ).join('')}
                                    </div>
                                </details>
                            </div>
                            ` : ''}
                        </div>
                    `;
                    resultsEl.classList.remove('hidden');

                    setUnsavedChanges(true);
                    showModal("Success", `Sales data processed successfully. ${adjustedItems} items now have sales tracking data and bill number references added to remarks.`);
                } catch (error) {
                    showModal("Error", `Sales data processing failed: ${error.message}`);
                } finally {
                    hideLoader();
                }
            }
              function generateRecountMasterFile() {
                // Include items that need recounting:
                // 1. Items with discrepancies (Diff1 !== 0)
                // 2. Items that were never counted (Scan1 === 0 && !Reason1)
                // 3. Exclude DEMO items (!isDemo)
                const itemsToRecount = state.netDiffData.filter(item => 
                    !item.isDemo && (item.Diff1 !== 0 || (item.Scan1 === 0 && !item.Reason1))
                );
                
                if (!itemsToRecount.length) {
                    return showModal("Info", "No non-DEMO items require a recount.");
                }
                
                // Show preview of what will be included
                const discrepancyCount = itemsToRecount.filter(item => item.Diff1 !== 0).length;
                const uncountedCount = itemsToRecount.filter(item => item.Scan1 === 0 && !item.Reason1).length;
                const totalSOH = itemsToRecount.reduce((sum, item) => sum + item.SOH, 0);
                
                const previewMessage = `
                    <div class="text-left">
                        <p class="mb-2"><strong>Items to be included in recount:</strong></p>
                        <ul class="list-disc pl-5 space-y-1">
                            <li>Items with discrepancies: <span class="font-medium text-blue-600">${discrepancyCount}</span></li>
                            <li>Items not counted: <span class="font-medium text-red-600">${uncountedCount}</span></li>
                            <li><strong>Total items: <span class="text-green-600">${itemsToRecount.length}</span></strong></li>
                            <li><strong>Total SOH: <span class="text-purple-600">${formatNumber(totalSOH)}</span></strong></li>
                        </ul>
                    </div>
                `;
                showModal("Generate Recount Master File", previewMessage, {
                    onConfirm: () => {
                        // Use new file naming convention: Master_ReCount_branchcode_date.csv
                        const branchInfo = state.branchCode ? `${state.branchCode}_${state.countDate}` : `${state.branchName.replace(/\s+/g, '_')}_${state.countDate}`;
                        const fileName = `Master_ReCount_${branchInfo}.csv`;
                        
                        const rowsForCsv = itemsToRecount.map(item => [item.SKU, item.Description, item.Price, item.Age, item.SOH]);
                        downloadFile(Papa.unparse(rowsForCsv, { header: false }), fileName);
                        showModal("Success", `Recount master file generated with ${itemsToRecount.length} items.`);
                    },
                    onCancel: () => {},
                    confirmText: "Generate File",
                    cancelText: "Cancel"
                });
            }            async function handleLatestSohUpload(e) {
                const file = e.target.files[0]; if (!file) return;
                getEl('latestSohFileName').textContent = file.name;
                showLoader("Updating SOH...");
                try {
                    const latestSohRaw = await parseExcelFile(file);
                    if (!latestSohRaw?.length) throw new Error("Latest SOH file is empty or invalid.");
                    const { lookup: latestSohProcessedLookup } = processAndSeparateSoh(latestSohRaw);
                    if (Object.keys(latestSohProcessedLookup).length === 0) throw new Error("No valid stock items found in the latest SOH file.");
                    
                    // Track SKUs with updated SOH
                    const sohUpdatedSkus = new Set();
                    let updatedCount = 0;
                    
                    state.netDiffData.forEach(item => {
                        if (latestSohProcessedLookup[item.SKU] !== undefined) {
                            const oldSoh = item.SOH;
                            const newSoh = latestSohProcessedLookup[item.SKU].SOH;
                            if (oldSoh !== newSoh) { 
                                item.SOH = newSoh; 
                                item.Diff1 = item.Scan1 - item.SOH; 
                                sohUpdatedSkus.add(item.SKU);
                                updatedCount++; 
                            }
                        }
                    });
                    Object.values(state.sohLookup).forEach(item => {
                        if (latestSohProcessedLookup[item.SKU] !== undefined) {
                            const oldSoh = item.SOH;
                            const newSoh = latestSohProcessedLookup[item.SKU].SOH;
                            if (oldSoh !== newSoh) {
                                item.SOH = newSoh;
                                sohUpdatedSkus.add(item.SKU);
                            }
                        }
                    });
                    if (state.reconciledData.length > 0) {
                        state.reconciledData.forEach(item => {
                            if (latestSohProcessedLookup[item.SKU] !== undefined) { 
                                const oldSoh = item.SOH;
                                const newSoh = latestSohProcessedLookup[item.SKU].SOH;
                                if (oldSoh !== newSoh) {
                                    item.SOH = newSoh; 
                                    item.FinalDiff = item.Recount - item.SOH;
                                    sohUpdatedSkus.add(item.SKU);
                                      // Update reason to include SOHupdated
                                    if (!item.ReasonFinal || item.ReasonFinal === 'DEMO-N/A' || item.ReasonFinal === 'N/A Re-Scan') {
                                        item.ReasonFinal = 'SOHupdated';
                                    } else if (!item.ReasonFinal.includes('SOHupdated')) {
                                        item.ReasonFinal = `SOHupdated-${item.ReasonFinal}`;
                                    }
                                } else {
                                    item.SOH = newSoh; 
                                    item.FinalDiff = item.Recount - item.SOH;
                                }
                            }
                        });
                        applyFinalReportView(); renderFinalReportCharts();
                    }
                    
                    // Store SOH updated SKUs for future reference
                    if (!state.sohUpdatedSkus) state.sohUpdatedSkus = new Set();
                    sohUpdatedSkus.forEach(sku => state.sohUpdatedSkus.add(sku));
                    
                    showModal("Success", `SOH updated for ${updatedCount} items. You can now generate a new recount file or finalize the report.`);
                    setUnsavedChanges(true);
                } catch (error) { showModal("Error Updating SOH", error.message);
                } finally { hideLoader(); e.target.value = ''; getEl('latestSohFileName').textContent = ''; }
            }
            
            async function processSecondCount() {
                showLoader('Processing Recount...');
                try {
                    const logFiles = getEl('secondScanLogfile').files;
                    const masterFile = getEl('secondMasterFile').files[0];
                    
                    if (!logFiles.length && !masterFile) {
                        throw new Error("Please upload at least one file (Logfile or Master.csv) for the recount.");
                    }
                    
                    let recountData = [];
                    
                    // Process Logfile(s) if uploaded
                    if (logFiles.length > 0) {
                        const logfileData = await (async function(files){ 
                            const p = Array.from(files).map(f => new Promise((res, rej) => { 
                                Papa.parse(f, { 
                                    skipEmptyLines: true, 
                                    complete: r => { 
                                        const d = r.data.map(row => { 
                                            if(!row || row.length < 3 || !row[2]) return null; 
                                            const sku = String(row[2]).trim(); 
                                            const qty = parseInt(String(row[4] ?? 1).replace(/,/g,''), 10); 
                                            return {sku, qty: isNaN(qty) ? 1: qty};
                                        }).filter(Boolean); 
                                        res(d); 
                                    }, 
                                    error: rej
                                }); 
                            })); 
                            return Promise.all(p).then(r => r.flat()); 
                        })(logFiles);
                        recountData = recountData.concat(logfileData);
                    }
                    
                    // Process Master.csv if uploaded
                    if (masterFile) {
                        const masterData = await new Promise((resolve, reject) => {
                            Papa.parse(masterFile, {
                                skipEmptyLines: true,
                                complete: result => {
                                    try {
                                        const data = result.data.map(row => {
                                            if (!row || row.length < 6 || !row[0]) return null;
                                            const sku = String(row[0]).trim(); // Column 1: Part No.
                                            const qty = parseInt(String(row[5] || '0').replace(/,/g, ''), 10); // Column 6: Actual Qty
                                            // Only include items that were actually counted (qty > 0)
                                            if (isNaN(qty) || qty <= 0) return null;
                                            return { sku, qty };
                                        }).filter(Boolean);
                                        resolve(data);
                                    } catch (error) {
                                        reject(error);
                                    }
                                },
                                error: reject
                            });
                        });
                        recountData = recountData.concat(masterData);
                    }
                    
                    // Convert recount data array to SKU-keyed object for easier lookup
                    const recountCounts = {};
                    recountData.forEach(item => {
                        if (recountCounts[item.sku]) {
                            recountCounts[item.sku] += item.qty; // Sum if same SKU appears multiple times
                        } else {
                            recountCounts[item.sku] = item.qty;
                        }
                    });                    state.reconciledData = state.netDiffData.map(item => {
                        const newItem = {...item};
                        
                        // Check if item has been manually edited in final table
                        const existingReconciledItem = state.reconciledData.find(r => r.SKU === item.SKU);
                        const hasManualEdit = existingReconciledItem && (
                            existingReconciledItem.ReasonFinal === 'Manual Edit' ||
                            existingReconciledItem.ReasonFinal === 'SOHupdated-Manual Edit'
                        );
                        
                        if (hasManualEdit) {
                            // Skip updating - preserve manual edit
                            return existingReconciledItem;
                        }
                        
                        // Check if item has existing sales data that should be preserved
                        const hasSalesData = existingReconciledItem && 
                            existingReconciledItem.ReasonFinal && 
                            existingReconciledItem.ReasonFinal.includes('Sales:');
                        
                        if (hasSalesData) {
                            // Preserve existing sales data and only update if this item was recounted
                            if (recountCounts[newItem.SKU] !== undefined) {
                                // Item was recounted - add recount data to existing sales count
                                const salesMatch = existingReconciledItem.ReasonFinal.match(/Sales: (\d+) units added/);
                                const salesQty = salesMatch ? parseInt(salesMatch[1], 10) : 0;
                                
                                // Set base count from recount, then add sales on top
                                newItem.Recount = recountCounts[newItem.SKU] + salesQty;
                                newItem.FinalDiff = newItem.Recount - newItem.SOH;
                                
                                // Update reason to combine recount and sales info
                                const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(newItem.SKU);
                                const baseRecountReason = wasSohUpdated ? 'SOHupdated-Re-Scan' : 'Re-Scan';
                                newItem.ReasonFinal = `${baseRecountReason} + ${existingReconciledItem.ReasonFinal}`;
                                
                                // Preserve existing remarks (which contain bill numbers)
                                newItem.Remark = existingReconciledItem.Remark || '';
                            } else {
                                // Item was not recounted - preserve all existing sales data
                                return existingReconciledItem;
                            }
                        } else {
                            // No existing sales data - proceed with normal recount logic
                            // Initialize Recount and ReasonFinal for all items
                            if (!newItem.isDemo && newItem.Diff1 !== 0) {
                                // Items that need recounting
                                const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(newItem.SKU);                            
                                if (recountCounts[newItem.SKU] !== undefined) { 
                                    newItem.Recount = recountCounts[newItem.SKU]; 
                                    newItem.ReasonFinal = wasSohUpdated ? 'SOHupdated-Re-Scan' : 'Re-Scan';                            
                                } else { 
                                    newItem.Recount = 0; 
                                    newItem.ReasonFinal = wasSohUpdated ? 'SOHupdated-N/A Re-Scan' : 'N/A Re-Scan'; 
                                }
                            } else if (newItem.isDemo) {
                                // Demo items: get current count from demo panel
                                const demoCount = state.demoCounts[newItem.SKU];
                                const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(newItem.SKU);                            
                                if (demoCount && typeof demoCount.qty === 'number') {
                                    newItem.Recount = demoCount.qty;
                                    const baseReason = demoCount.reason || 'DEMO-Manual';
                                    newItem.ReasonFinal = wasSohUpdated ? `SOHupdated-${baseReason}` : baseReason;                            
                                } else {
                                    const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(newItem.SKU);
                                    newItem.Recount = 0;
                                    newItem.ReasonFinal = wasSohUpdated ? 'SOHupdated-DEMO-N/A' : 'DEMO-N/A';
                                }} else {
                                // Items that don't need recounting (items with no difference)
                                newItem.Recount = newItem.Counted1 || 0;
                                // Keep the original reason for items that don't need recounting
                                // Don't change to "No Recount Needed" - preserve the original counting reason
                            }
                            
                            newItem.FinalDiff = newItem.Recount - newItem.SOH;
                        }
                        
                        return newItem;
                    });

                    applyFinalReportView(); 
                    renderFinalReportCharts();
                    getEl('final-report-container').classList.remove('hidden');
                    getEl('final-report-container').scrollIntoView({ behavior: 'smooth' });
                    setUnsavedChanges(true);
                    
                    // Generate success message showing what files were processed
                    let processedFiles = [];
                    if (logFiles.length > 0) processedFiles.push(`${logFiles.length} Logfile(s)`);
                    if (masterFile) processedFiles.push('Master.csv');
                    const message = `Recount processed successfully using: ${processedFiles.join(' and ')}. Final report is now available.`;
                    
                    showModal("Success", message);
                } catch (error) { 
                    showModal("Error", "Recount processing failed: " + error.message);
                } finally { 
                    hideLoader(); 
                }
            }

            function applyFinalReportView() {
                if (!state.reconciledData.length) return;
                const searchValue = getEl('finalSearchInput').value.toUpperCase();
                const filterValue = getEl('finalFilterSelect').value;
                let dataView = state.reconciledData.filter(item => {
                    if (!(item.SKU.toUpperCase().includes(searchValue) || item.Description.toUpperCase().includes(searchValue))) return false;
                    if (filterValue === 'discrepancy') return item.FinalDiff !== 0;
                    if (filterValue === 'demo') return item.isDemo;
                    if (filterValue === 'normal') return !item.isDemo;
                    return true;
                });                const { column, direction } = state.finalReportSort;                dataView.sort((a, b) => {
                    let valA = column === 'FinalDiff' ? Math.abs(a[column]) : a[column];
                    let valB = column === 'FinalDiff' ? Math.abs(b[column]) : b[column];
                    
                    // Handle field name mapping for certain columns
                    if (column === 'SRP') {
                        valA = a.Price || 0;
                        valB = b.Price || 0;
                    } else if (column === 'FinalCount') {
                        valA = a.Recount || 0;
                        valB = b.Recount || 0;
                    }
                    
                    // Handle null/undefined values for string columns
                    if (column === 'ReasonFinal' || column === 'Remark') {
                        valA = valA || '';
                        valB = valB || '';
                    }
                    
                    if (typeof valA === 'string') return direction === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                    return direction === 'asc' ? valA - valB : valB - valA;
                });
                renderFinalReportTable(dataView);
                updateFinalReportSummary();
            }            function renderFinalReportTable(data) {
                const container = getEl('final-report-table-container');
                if (!data.length) { container.innerHTML = '<p class="text-center p-10 text-slate-500">No data matches the current filter.</p>'; return; }
                const headers = `<thead><tr><th class="p-3 text-center w-12">NO.</th><th class="p-3 text-left" data-sort-by="SKU">SKU<span class="sort-indicator"></span></th><th class="p-3 text-left" data-sort-by="Description">Description<span class="sort-indicator"></span></th><th class="p-3 text-center" data-sort-by="SRP">SRP<span class="sort-indicator"></span></th><th class="p-3 text-center" data-sort-by="Age">Age<span class="sort-indicator"></span></th><th class="p-3 text-center" data-sort-by="SOH">SOH<span class="sort-indicator"></span></th><th class="p-3 text-center" data-sort-by="FinalCount">Final Count<span class="sort-indicator"></span></th><th class="p-3 text-center" data-sort-by="FinalDiff">Final Diff<span class="sort-indicator"></span></th><th class="p-3 text-left" data-sort-by="ReasonFinal">Reason<span class="sort-indicator"></span></th><th class="p-3 text-left" data-sort-by="Remark">Remark<span class="sort-indicator"></span></th></tr></thead>`;
                const body = `<tbody>${data.map((item, idx) => renderFinalReportRow(item, idx)).join('')}</tbody>`;
                container.innerHTML = `<table class="w-full text-sm">${headers}${body}</tbody></table>`;
                
                // Update sort indicators with colors
                const sortingTh = container.querySelector(`th[data-sort-by="${state.finalReportSort.column}"]`);
                if (sortingTh) { 
                    const indicator = sortingTh.querySelector('.sort-indicator');
                    indicator.textContent = state.finalReportSort.direction === 'asc' ? '‚ñ≤' : '‚ñº'; 
                    // Add color: green for ascending, red for descending
                    indicator.style.color = state.finalReportSort.direction === 'asc' ? '#22c55e' : '#ef4444';
                }
            }
            function renderFinalReportRow(item, idx) {
                const { rowClass, statusDotColor } = getRowVisuals(item.FinalDiff, item.isDemo);
                return `<tr class="border-b border-slate-200 ${rowClass}" data-sku="${item.SKU}">
                    <td class="p-3 text-center">${idx + 1}</td>
                    <td class="p-3 font-medium text-slate-800">${item.SKU}</td>
                    <td class="p-3 text-slate-600">${item.Description}</td>
                    <td class="p-3 text-center">${item.Price ?? 0}</td>
                    <td class="p-3 text-center text-slate-600">${item.Age || 'N/A'}</td>
                    <td class="p-3 text-center">${item.SOH}</td>
                    <td class="p-3 text-center w-24"><input type="number" value="${item.Recount}" class="w-full text-center p-1.5 border border-slate-300 rounded-md"/></td>
                    <td class="p-3 font-bold text-center ${getDiffColorClass(item.FinalDiff)}">${item.FinalDiff > 0 ? '+' : ''}${item.FinalDiff}</td>
                    <td class="p-3 text-slate-600">${item.ReasonFinal || 'N/A'}</td>
                    <td class="p-3 w-40"><input type="text" value="${item.Remark || ''}" class="w-full p-1.5 border border-slate-300 rounded-md"/></td>
                </tr>`;
            }

            function getRowVisuals(diff, isDemo = false) {
                if (diff === 0) return { rowClass: isDemo ? 'bg-sky-50' : 'bg-green-50', statusDotColor: isDemo ? 'bg-sky-500' : 'bg-green-500' };
                if (diff !== null) return { rowClass: diff > 0 ? 'bg-yellow-50' : 'bg-red-50', statusDotColor: 'bg-red-500' };
                return { rowClass: 'bg-white', statusDotColor: 'bg-gray-400' };
            }            function updateTableRowVisuals(row, diff, isDemo = false) {
                const { rowClass } = getRowVisuals(diff, isDemo);
                row.className = `border-b border-slate-200 ${rowClass}`;
                // Note: .status-dot element doesn't exist in table rows, so no need to update it
            }              function updateFinalCount(sku, value) {
                const item = state.reconciledData.find(i => i.SKU === sku); if (!item) return;
                const newCount = value === '' ? 0 : parseInt(value, 10);
                item.Recount = isNaN(newCount) ? 0 : newCount;
                item.FinalDiff = item.Recount - item.SOH; 
                
                // Handle SOH updated reason tracking
                const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(sku);
                if (wasSohUpdated) {
                    item.ReasonFinal = 'SOHupdated-Manual Edit';
                } else {
                    item.ReasonFinal = 'Manual Edit';
                }
                const row = getEl('final-report-table-container').querySelector(`tr[data-sku="${sku}"]`);                
                  if(row) {
                    // Update Final Count column (index 6) with the new count value
                    row.cells[6].querySelector('input[type="number"]').value = item.Recount;
                    // Update Final Diff column (index 7) with the calculated difference
                    row.cells[7].textContent = item.FinalDiff > 0 ? `+${item.FinalDiff}` : item.FinalDiff;
                    row.cells[7].className = `p-3 font-bold text-center ${getDiffColorClass(item.FinalDiff)}`;
                    // Update Reason column (index 8)
                    row.cells[8].textContent = item.ReasonFinal;
                    updateTableRowVisuals(row, item.FinalDiff, item.isDemo);
                }
                updateFinalReportSummary();
                updateDemoSummary();
                renderFinalReportCharts();
                setUnsavedChanges(true);
            }            
            function updateRemark(sku, value) {
                const item = state.reconciledData.find(i => i.SKU === sku); if (item) { 
                    item.Remark = value; setUnsavedChanges(true); 
                }
            }

            function updateDemoRemark(sku, value) {
                const item = state.demoMaster.find(i => i.SKU === sku);
                if (item) {
                    item.remark = value;
                    setUnsavedChanges(true);
                }
            }

            function updateFinalReportSummary() {
                const summaryEl = getEl('final-summary');
                if (!state.reconciledData.length) {
                    summaryEl.innerHTML = ''; return; 
                }
                const summary = state.reconciledData.reduce((acc, item) => {
                    const diffCost = item.FinalDiff * item.Price;
                    if (item.FinalDiff > 0) {
                        acc.overQty += item.FinalDiff; acc.overCost += diffCost; 
                    } 
                    else if (item.FinalDiff < 0) {
                        acc.shortQty += item.FinalDiff; acc.shortCost += diffCost; 
                    }
                    acc.totalCountedQty += item.Recount; acc.totalCountedCost += item.Recount * item.Price;
                    acc.totalSOHPrice += item.SOH * (item.Price ?? 0);
                    acc.totalSOHQty += item.SOH;
                    return acc;
                }, { 
                    overQty: 0, overCost: 0, shortQty: 0, shortCost: 0, totalCountedQty: 0, totalCountedCost: 0, totalSOHPrice: 0, totalSOHQty: 0 
                });
                finalSummaryData = summary; // Save for JSON export
                finalSummaryData.netDiffCost = summary.overCost + summary.shortCost;

                summaryEl.innerHTML = `<h4 class="font-semibold text-center mb-1 text-slate-700">Report Summary</h4><div class="grid grid-cols-2 gap-x-4">
                    <div class="text-green-600"><strong>Over Qty:</strong> ${formatNumber(summary.overQty)}</div>
                    <div class="text-green-600"><strong>Over Cost:</strong> ${formatNumber(summary.overCost)}</div>
                    <div class="text-red-600"><strong>Short Qty:</strong> ${formatNumber(summary.shortQty)}</div>
                    <div class="text-red-600"><strong>Short Cost:</strong> ${formatNumber(summary.shortCost)}</div>
                    <div class="col-span-2 border-t pt-1 mt-1"></div>
                    <div class="text-blue-600"><strong>Total SOH Qty:</strong> ${formatNumber(summary.totalSOHQty)}</div>
                    <div class="text-blue-600"><strong>Total SOH Value:</strong> ${formatNumber(summary.totalSOHPrice)}</div>
                    <div class="text-blue-600"><strong>Total Counted Qty:</strong> ${formatNumber(summary.totalCountedQty)}</div>
                    <div class="text-blue-600"><strong>Total Counted Cost:</strong> ${formatNumber(summary.totalCountedCost)}</div>
                    <div class="font-bold col-span-2 border-t pt-1 mt-1"></div>
                    <div class="font-bold"><strong>Net Diff Qty:</strong> ${formatNumber(summary.overQty + summary.shortQty)}</div>
                    <div class="font-bold"><strong>Net Diff Cost:</strong> ${formatNumber(finalSummaryData.netDiffCost)}</div>
                </div>`;
            }

            function renderFinalReportCharts() {
                if (!state.reconciledData.length) return;
                Object.values(state.charts).forEach(chart => chart?.destroy());
                const summary = state.reconciledData.reduce((acc, item) => {
                    if (item.FinalDiff > 0) {
                        acc.overCost += item.FinalDiff * item.Price; acc.overQty += item.FinalDiff; 
                    } 
                    else if (item.FinalDiff < 0) {
                        acc.shortCost += Math.abs(item.FinalDiff * item.Price); acc.shortQty += Math.abs(item.FinalDiff); 
                    }
                    if (item.FinalDiff !== 0) {
                        const cat = item.CLASS_NAME || 'UNCATEGORIZED'; acc.byCategory[cat] = (acc.byCategory[cat] || 0) + item.FinalDiff; 
                    }
                    return acc;
                }, { 
                    overCost: 0, shortCost: 0, overQty: 0, shortQty: 0, byCategory: {} 
                   });
                const chartOptions = { 
                    responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'top' } } 
                };
                state.charts.cost = new Chart(getEl('costChart'), { type: 'doughnut', data: { labels: ['Over', 'Short'], datasets: [{ data: [summary.overCost, summary.shortCost], backgroundColor: ['#22c55e', '#ef4444'] }] }, options: chartOptions });
                state.charts.qty = new Chart(getEl('qtyChart'), { type: 'doughnut', data: { labels: ['Over', 'Short'], datasets: [{ data: [summary.overQty, summary.shortQty], backgroundColor: ['#22c55e', '#ef4444'] }] }, options: chartOptions });
                const categoryData = Object.entries(summary.byCategory).sort(([,a],[,b]) => Math.abs(b) - Math.abs(a)).slice(0, 15);
                state.charts.category = new Chart(getEl('categoryChart'), { type: 'bar', data: { labels: categoryData.map(([name]) => name.substring(0, 15)), datasets: [{ label: 'Net Qty Difference', data: categoryData.map(([, qty]) => qty), backgroundColor: categoryData.map(([, qty]) => qty > 0 ? 'rgba(34, 197, 94, 0.7)' : 'rgba(239, 68, 68, 0.7)'), }] }, options: { ...chartOptions, indexAxis: 'y', scales: { y: { beginAtZero: true } } } });
            }
              function exportFinalReport() {
                if (!state.reconciledData.length) return showModal("Info", "No data to export.");
                const dataToExport = state.reconciledData.map((item, idx) => ({
                    NO: idx + 1, 
                    SKU: item.SKU, 
                    Description: item.Description, 
                    SRP: item.Price, 
                    Age: item.Age, 
                    SOH: item.SOH, 
                    Scan: item.Scan1, 
                    Recount: item.Recount, 
                    FinalDiff: item.FinalDiff, 
                    Remark: item.Remark || '', 
                    Reason: item.ReasonFinal,
                    Flag: item.isDemo ? 'DEMO' : 'NONE'
                }));
                const branchInfo = state.branchCode ? `${state.branchCode}_${state.branchName.replace(/\s+/g, '_')}` : state.branchName.replace(/\s+/g, '_');
                downloadFile(Papa.unparse(dataToExport, { header: true }), `${state.countDate}_Report_${branchInfo}.csv`);
            }
            function exportStockCountToJSON() {
                if (!state.reconciledData.length) {
                    alert('‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÉ‡∏´‡πâ‡∏ñ‡∏∂‡∏á‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡∏≠‡∏ô‡∏™‡∏∏‡∏î‡∏ó‡πâ‡∏≤‡∏¢‡∏Å‡πà‡∏≠‡∏ô‡∏ó‡∏≥‡∏Å‡∏≤‡∏£ Export');
                    return;
                }
                const exportData = {
                    tool: 'stock-count',
                    details: {
                        branch: state.branchName,
                        branchCode: state.branchCode,
                        date: state.countDate,
                    },
                    summary: finalSummaryData,
                    data: state.reconciledData.filter(item => item.FinalDiff !== 0)
                };
                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const branchInfo = state.branchCode ? `${state.branchCode}_${state.branchName.replace(/\s+/g, '_')}` : state.branchName.replace(/\s+/g, '_');
                a.download = `${state.countDate}_Stock-Count_${branchInfo}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
              function handlePrintReport() {
                // Prepare input values for printing by copying them to parent cell data attributes
                const inputs = document.querySelectorAll('#final-report-table-container input, #demo-count-container input');
                
                // Store original data-print-value attributes from parent cells
                const originalValues = new Map();
                
                inputs.forEach(input => {
                    const parentCell = input.closest('td');
                    if (parentCell) {
                        // Store original value if exists
                        if (parentCell.hasAttribute('data-print-value')) {
                            originalValues.set(parentCell, parentCell.getAttribute('data-print-value'));
                        }
                        
                        // Set current input value to parent cell's data-print-value for printing
                        const value = input.value || '';
                        if (value.trim() !== '') {
                            parentCell.setAttribute('data-print-value', value);
                        } else {
                            parentCell.setAttribute('data-print-value', '-');
                        }
                    }
                });
                
                // Print the document
                window.print();
                
                // Clean up: restore original data-print-value attributes
                setTimeout(() => {
                    originalValues.forEach((originalValue, parentCell) => {
                        parentCell.setAttribute('data-print-value', originalValue);
                    });
                    
                    // Remove data-print-value from cells that didn't have it originally
                    inputs.forEach(input => {
                        const parentCell = input.closest('td');
                        if (parentCell && !originalValues.has(parentCell)) {
                            parentCell.removeAttribute('data-print-value');
                        }
                    });
                }, 500); // Small delay to ensure print dialog has opened
            }
            
            let audioCtx;
            function playSound(type) {
                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if (!audioCtx) return;
                const oscillator = audioCtx.createOscillator(); const gainNode = audioCtx.createGain();
                oscillator.connect(gainNode); gainNode.connect(audioCtx.destination);                if (type === 'success') { oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(600, audioCtx.currentTime); gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime); oscillator.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.05); } 
                else { oscillator.type = 'square'; oscillator.frequency.setValueAtTime(200, audioCtx.currentTime); gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime); oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1); }
                oscillator.start(audioCtx.currentTime); oscillator.stop(audioCtx.currentTime + 0.15);
            }

            let currentScanner = 'barcode'; // Legacy - kept for compatibility
            
            const startTextScanner = async () => {
                try {
                    if (activeStream) {
                        activeStream.getTracks().forEach(track => track.stop());
                    }
                    
                    // Enhanced camera constraints for iPad Gen10 and Apple product scanning
                    const cameraConstraints = {
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 1920, max: 1920 },
                            height: { ideal: 1080, max: 1080 },
                            frameRate: { ideal: 30, max: 30 },
                            focusMode: 'continuous',
                            exposureMode: 'continuous',
                            whiteBalanceMode: 'continuous'
                        }
                    };
                    
                    activeStream = await navigator.mediaDevices.getUserMedia(cameraConstraints);
                    textScannerVideo.srcObject = activeStream;
                    textScannerVideo.play();
                } catch (err) {
                    scannerResultsEl.innerHTML = `<p class="text-red-500">Camera error: ${err.message}</p>`;
                }
            };
            
            function stopTextScanner() {
                // Stop all video tracks from the video element, not just activeStream
                const video = document.getElementById('text-scanner-video');
                if (video && video.srcObject) {
                    const tracks = video.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    video.srcObject = null;
                }
                activeStream = null;
            }
            
            const captureAndRecognize = async () => {
                if (!activeStream || !cvReady) {
                    scannerResultsEl.innerHTML = `<p class="text-red-500">Camera or OpenCV is not ready.</p>`;
                    return;
                }
                scannerResultsEl.innerHTML = `<p class="text-blue-500">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£...</p>`;
                captureBtn.disabled = true;

                const video = textScannerVideo;
                const canvas = document.createElement('canvas');

                // Crop a very narrow, focused region (centered)
                const cropHeightPercentage = 0.10; // Even narrower band (10% of height)
                const cropWidthPercentage = 0.55;  // Focus on center 55% of width
                const sWidth = video.videoWidth * cropWidthPercentage;
                const sHeight = video.videoHeight * cropHeightPercentage;
                const sx = video.videoWidth * (1 - cropWidthPercentage) / 2;
                const sy = video.videoHeight * 0.45; // Centered vertically

                canvas.width = sWidth;
                canvas.height = sHeight;

                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);

                // OpenCV preprocessing: grayscale, contrast, denoise, adaptive threshold
                let src = cv.imread(canvas);
                let gray = new cv.Mat();
                let denoised = new cv.Mat();
                let thresh = new cv.Mat();

                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                cv.equalizeHist(gray, gray); // Contrast
                cv.GaussianBlur(gray, denoised, new cv.Size(3, 3), 0, 0, cv.BORDER_DEFAULT); // Denoise
                cv.adaptiveThreshold(
                    denoised, thresh, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 15, 8
                );

                cv.imshow(canvas, thresh);

                src.delete();
                gray.delete();
                denoised.delete();
                thresh.delete();

                try {
                    const result = await Tesseract.recognize(canvas, 'eng', {
                        logger: m => {
                            if (m.status === 'recognizing text') {
                                scannerResultsEl.innerHTML = `<p class="text-blue-500">${m.status} (${(m.progress * 100).toFixed(0)}%)...</p>`;
                            }
                        },
                        tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-',
                    });

                    // Post-process: Remove spaces, filter by length/pattern
                    let recognizedText = result.data.text.replace(/\s/g, '').toUpperCase();
                    // Accept only if matches expected pattern (8+ alphanum, adjust as needed)
                    const match = recognizedText.match(/[A-Z0-9\-]{8,}/);
                    if (match) {
                        recognizedText = match[0];
                        scannerResultsEl.innerHTML = `<p>Found text: ${recognizedText}</p>`;
                        processScannedCode(recognizedText, 'DEMO-Text Scan');
                    } else {
                        scannerResultsEl.innerHTML = `<p class="text-red-500">‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ï‡∏±‡∏ß‡∏≠‡∏±‡∏Å‡∏©‡∏£‡∏ó‡∏µ‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô</p>`;
                    }
                } catch (err) {
                    scannerResultsEl.innerHTML = `<p class="text-red-500">OCR Error: ${err.message}</p>`;
                } finally {
                    captureBtn.disabled = false;
                }
            };

            const startOcrStreaming = () => {
                if (ocrStreaming) return;
                ocrStreaming = true;
                scannerResultsEl.innerHTML = '<p class="text-blue-500">‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏™‡πÅ‡∏Å‡∏ô‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏•‡πÑ‡∏ó‡∏°‡πå...</p>';
                ocrStreamInterval = setInterval(processOcrFrame, 700); // every 700ms
            };

            const stopOcrStreaming = () => {
                ocrStreaming = false;
                if (ocrStreamInterval) clearInterval(ocrStreamInterval);
                ocrStreamInterval = null;
            };            const processOcrFrame = async () => {
                if (!ocrStreaming || !activeStream || !cvReady) return;
                const video = textScannerVideo;
                if (video.readyState < 2) return;
                
                const startTime = performance.now();
                ocrTotalAttempts++;
                
                const canvas = document.createElement('canvas');
                
                // --- Enhanced Crop Settings for Apple Products ---
                // Optimized crop for Apple serial numbers typically found on back/bottom
                const cropY = video.videoHeight * 0.45;        // Higher up for better Apple serial scanning
                const cropHeight = video.videoHeight * 0.18;   // Taller crop for better text capture
                const cropX = video.videoWidth * 0.05;         // Slight left margin for better frame
                const cropWidth = video.videoWidth * 0.90;     // Wider crop for better coverage
                
                canvas.width = cropWidth;
                canvas.height = cropHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

                // Show cropped preview
                const preview = document.getElementById('ocr-crop-preview');
                if (preview) {
                    preview.width = canvas.width;
                    preview.height = canvas.height;
                    preview.getContext('2d').drawImage(canvas, 0, 0);
                }

                // Check cache first
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const cacheKey = generateCacheKey(imageData, ocrSettings.demo);
                if (ocrResultsCache.has(cacheKey)) {
                    ocrCacheHits++;
                    const cachedResult = ocrResultsCache.get(cacheKey);
                    
                    if (cachedResult.text && cachedResult.text.match(/[A-Z0-9\-]{8,}/)) {
                        scannerResultsEl.innerHTML = `<p>Serial Number: <b>${cachedResult.text}</b> (cached)</p>`;
                        processScannedCode(cachedResult.text, 'DEMO-Text Scan');
                        stopOcrStreaming();
                        return;
                    }
                }

                // --- Enhanced Lighting Detection for Apple Products ---
                let total = 0;
                let pixelCount = 0;
                let contrastSum = 0;
                let prevPixel = 0;
                
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const pixel = (imageData.data[i] + imageData.data[i+1] + imageData.data[i+2]) / 3;
                    total += pixel;
                    pixelCount++;
                    
                    // Calculate contrast for better lighting assessment
                    if (pixelCount > 1) {
                        contrastSum += Math.abs(pixel - prevPixel);
                    }
                    prevPixel = pixel;
                }
                
                const avgBrightness = total / pixelCount;
                const avgContrast = contrastSum / (pixelCount - 1);
                
                // Enhanced lighting feedback for Apple products
                if (avgBrightness < 55) {
                    scannerResultsEl.innerHTML = `<p class="text-yellow-600">‡∏†‡∏≤‡∏û‡∏°‡∏∑‡∏î‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÅ‡∏™‡∏á‡∏™‡∏ß‡πà‡∏≤‡∏á (${avgBrightness.toFixed(0)})</p>`;
                    return;
                } else if (avgBrightness > 220) {
                    scannerResultsEl.innerHTML = `<p class="text-yellow-600">‡∏†‡∏≤‡∏û‡∏™‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏•‡∏î‡πÅ‡∏™‡∏á‡∏™‡∏ß‡πà‡∏≤‡∏á (${avgBrightness.toFixed(0)})</p>`;
                    return;
                } else if (avgContrast < 15) {
                    scannerResultsEl.innerHTML = `<p class="text-yellow-600">‡∏†‡∏≤‡∏û‡πÑ‡∏°‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏õ‡∏£‡∏±‡∏ö‡πÇ‡∏ü‡∏Å‡∏±‡∏™ (${avgContrast.toFixed(0)})</p>`;
                    return;
                }

                // --- Enhanced Preprocessing Algorithms for Apple Products ---
                let src = cv.imread(canvas);
                let dst = new cv.Mat();
                
                if (ocrSettings.demo.preprocessing === 'basic') {
                    // Basic Apple-optimized preprocessing
                    cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);
                    
                    // Apply mild sharpening for Apple serial text
                    const sharpKernel = cv.matFromArray(3, 3, cv.CV_32FC1, [0, -1, 0, -1, 5, -1, 0, -1, 0]);
                    cv.filter2D(dst, dst, -1, sharpKernel);
                    sharpKernel.delete();
                    
                    cv.threshold(dst, dst, 0, 255, cv.THRESH_OTSU | cv.THRESH_BINARY_INV);
                } else if (ocrSettings.demo.preprocessing === 'enhanced') {
                    // Enhanced Apple-optimized preprocessing
                    cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);
                    
                    // CLAHE for better contrast on Apple products
                    const clahe = new cv.CLAHE(2.0, new cv.Size(8, 8));
                    clahe.apply(dst, dst);
                    clahe.delete();
                    
                    // Bilateral filter for noise reduction while preserving edges
                    cv.bilateralFilter(dst, dst, 9, 75, 75);
                    
                    // Unsharp masking for Apple text enhancement
                    const blurred = new cv.Mat();
                    cv.GaussianBlur(dst, blurred, new cv.Size(3, 3), 0, 0, cv.BORDER_DEFAULT);
                    cv.addWeighted(dst, 1.5, blurred, -0.5, 0, dst);
                    blurred.delete();
                    
                    cv.threshold(dst, dst, 0, 255, cv.THRESH_OTSU | cv.THRESH_BINARY_INV);
                } else if (ocrSettings.demo.preprocessing === 'aggressive') {
                    // Aggressive Apple-optimized preprocessing
                    cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);
                    
                    // Advanced CLAHE for difficult lighting
                    const clahe = new cv.CLAHE(3.0, new cv.Size(6, 6));
                    clahe.apply(dst, dst);
                    clahe.delete();
                    
                    // Multiple denoising passes for Apple products
                    cv.fastNlMeansDenoising(dst, dst, 10, 7, 21);
                    
                    // Adaptive bilateral filtering
                    cv.bilateralFilter(dst, dst, 11, 80, 80);
                    
                    // Multi-scale sharpening for Apple text
                    const sharp1 = new cv.Mat();
                    const sharp2 = new cv.Mat();
                    cv.GaussianBlur(dst, sharp1, new cv.Size(3, 3), 0, 0, cv.BORDER_DEFAULT);
                    cv.GaussianBlur(dst, sharp2, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);
                    cv.addWeighted(dst, 2.0, sharp1, -0.5, 0, dst);
                    cv.addWeighted(dst, 1.0, sharp2, -0.5, 0, dst);
                    sharp1.delete();
                    sharp2.delete();
                    
                    // Adaptive thresholding with morphological operations
                    cv.adaptiveThreshold(dst, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 6);
                    
                    // Morphological operations optimized for Apple text
                    const kernel1 = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2, 2));
                    const kernel2 = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 1));
                    cv.morphologyEx(dst, dst, cv.MORPH_CLOSE, kernel1);
                    cv.morphologyEx(dst, dst, cv.MORPH_OPEN, kernel2);
                    kernel1.delete();
                    kernel2.delete();
                }
                  cv.imshow(canvas, dst);
                src.delete();
                dst.delete();
                
                try {
                    if (!tesseractWorker) {
                        await initTesseract(ocrSettings.demo.language, true);
                    }
                    
                    // --- Enhanced OCR Processing for Apple Products ---
                    const result = await tesseractWorker.recognize(canvas);
                    const processingTime = performance.now() - startTime;
                    
                    let text = result.data.text.replace(/\s/g, '').toUpperCase();
                    let confidence = result.data.confidence;
                    
                    // --- Apple-specific Text Post-processing ---
                    // Remove common OCR artifacts for Apple serials
                    text = text.replace(/[|]/g, 'I')      // Common OCR mistake
                             .replace(/[0]/g, 'O')       // Zero to O confusion
                             .replace(/[8]/g, 'B')       // Eight to B confusion
                             .replace(/[5]/g, 'S')       // Five to S confusion
                             .replace(/[1]/g, 'I')       // One to I confusion
                    
                    // Update performance tracking
                    ocrPerformanceHistory.push({ time: processingTime, confidence, success: false });
                    if (ocrPerformanceHistory.length > 50) ocrPerformanceHistory.shift();
                    
                    // Process validation results
                    
                    // --- Enhanced Apple Serial Validation ---
                    const appleSerialMatch = text.match(/[A-Z0-9\-]{8,}/);
                    const isValidAppleSerial = appleSerialMatch && (
                        text.length >= 8 && text.length <= 14 &&
                        /[A-Z]/.test(text) &&      // Must contain letters
                        /[0-9]/.test(text) &&      // Must contain numbers
                        !/[^A-Z0-9\-]/.test(text)  // Only valid characters
                    );
                    
                    if (isValidAppleSerial && confidence >= ocrSettings.demo.confidence) {
                        const finalText = appleSerialMatch[0];
                        
                        // Cache successful result
                        ocrResultsCache.set(cacheKey, { text: finalText, confidence, timestamp: Date.now() });
                        
                        // Learn successful pattern
                        learnSuccessPattern(finalText, confidence, processingTime);
                        
                        // Update success tracking
                        ocrSuccessCount++;
                        ocrPerformanceHistory[ocrPerformanceHistory.length - 1].success = true;
                        
                        
                        scannerResultsEl.innerHTML = `<p>Apple Serial: <b>${finalText}</b></p>`;
                        processScannedCode(finalText, 'DEMO-Text Scan');
                        stopOcrStreaming();
                    } else {
                        scannerResultsEl.innerHTML = `<p class='text-blue-500'>Scanning Apple products... (${confidence.toFixed(1)}%)</p>`;
                    }
                    
                    // Adaptive settings based on performance
                    if (ocrPerformanceHistory.length > 0 && ocrPerformanceHistory.length % 10 === 0) {
                        adaptiveOcrSettings(ocrPerformanceHistory, true);
                    }
                } catch (err) {
                    handleOcrError(err, true);
                    scannerResultsEl.innerHTML = `<p class='text-red-500'>Apple OCR Error: ${err.message}</p>`;
                }
            };

            const startBarcodeScanner = () => {
                 Quagga.init({ inputStream: { name: "Live", type: "LiveStream", target: getEl('qr-reader'), constraints: { facingMode: "environment" } }, decoder: { readers: [ "code_128_reader", "ean_reader", "ean_8_reader", "code_39_reader", "upc_reader", "upc_e_reader" ] }, locate: true }, (err) => { if (err) { scannerResultsEl.innerHTML = `<p class="text-red-500">Camera error: ${err.message}</p>`; return; } Quagga.start(); });
                 Quagga.onDetected(onBarcodeDetected);
            };
            
            function stopBarcodeScanner() {
                if (typeof Quagga !== 'undefined' && Quagga.running) {
                    Quagga.offDetected(onBarcodeDetected);
                    Quagga.stop();
                }
                // Extra cleanup: stop video tracks from Quagga's video element
                const quaggaVideo = document.querySelector('#qr-reader video');
                if (quaggaVideo && quaggaVideo.srcObject) {
                    quaggaVideo.srcObject.getTracks().forEach(track => track.stop());
                    quaggaVideo.srcObject = null;
                }
            }
              const openScannerModal = () => {
                openFloatingScanner('demo');
            };            const closeScannerModal = () => {
                // Legacy function - now handled by floating scanner
                closeFloatingScanner();
            };const processScannedCode = (code, reason) => {
                const scannedText = code.toUpperCase();
                
                // Use shared matching function for enhanced Apple product matching
                let item = findItemByScannedText(state.demoMaster, scannedText);

                if (item) {
                    playSound('success');
                    let currentCount = typeof item.counted === 'number' ? item.counted : 0;
                    item.counted = currentCount + 1;
                    state.demoCounts[item.SKU] = { qty: item.counted, reason: reason };
                    applyDemoView();
                    const row = getEl('demo-count-container').querySelector(`tr[data-sku="${item.SKU}"]`);
                    if (row) {
                        row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        row.classList.add('ring-2', 'ring-offset-2', 'ring-green-500');
                        setTimeout(() => row.classList.remove('ring-2', 'ring-offset-2', 'ring-green-500'), 800);
                    }
                    const diff = item.counted - item.SOH;
                    let statusText = (diff === 0) ? 'Matched' : (diff > 0) ? 'Overage' : 'Shortage';
                    let statusColor = (diff === 0) ? 'text-green-600' : (diff > 0) ? 'text-yellow-600' : 'text-blue-600';
                    scannerResultsEl.innerHTML = `<div class="text-left w-full space-y-1"><p class="font-medium text-slate-800">${item.Description}</p><p class="text-sm text-slate-500">SKU: ${item.SKU}</p><div class="flex justify-between items-baseline pt-1"><span class="text-lg font-bold text-slate-700">Count: <span class="text-blue-600">${item.counted}</span> / ${item.SOH}</span><span class="text-lg font-bold ${statusColor}">${statusText}</span></div></div>`;
                } else {
                    playSound('error');
                    scannerResultsEl.innerHTML = `<div class="text-center w-full"><p class="font-bold text-red-600">SKU Not Found</p><p class="text-sm text-slate-500">${scannedText}</p></div>`;
                }
            };
            
            const scanCooldown = {};
            const onBarcodeDetected = (result) => {
                const code = result.codeResult.code.trim();
                const now = Date.now(); if (scanCooldown[code] && now - scanCooldown[code] < 10000) return;
                scanCooldown[code] = now;
                processScannedCode(code, 'DEMO-Barcode');
            };
              function initializeAppListeners() {
                function addListener(id, event, handler) {
                    const el = getEl(id);
                    if (el) {
                        el.addEventListener(event, handler);
                    }
                }

                // Export SOH Excel functionality
                function exportSohExcel() {
                    try {
                        // Use the same processed data as the app (sohLookup)
                        const allItems = Object.values(state.sohLookup).filter(item => item.SOH > 0);
                          if (allItems.length === 0) {
                            showModal("Warning", "No SOH data available to export");
                            return;
                        }

                        // Sort by SKU for consistency
                        allItems.sort((a, b) => a.SKU.localeCompare(b.SKU));
                          // Prepare data for export - use existing isDemo flag
                        const rows = allItems.map(item => {
                            return {
                                SKU: item.SKU,
                                Description: item.Description,
                                SRP: item.Price,
                                Age: item.Age,
                                SOH: item.SOH,
                                FAMILY: item.isDemo ? 'DEMO' : 'NONE'
                            };
                        });
                        const ws = XLSX.utils.json_to_sheet(rows);
                        const wb = XLSX.utils.book_new();
                        XLSX.utils.book_append_sheet(wb, ws, "SOH Export");
                        
                        // Use new file naming convention: countdate_function_branchcode_branchname
                        const branchInfo = state.branchCode ? `${state.branchCode}_${state.branchName.replace(/\s+/g, '_')}` : state.branchName.replace(/\s+/g, '_');
                        const filename = `${state.countDate || new Date().toISOString().split('T')[0]}_SOH_Export_${branchInfo}.xlsx`;
                        XLSX.writeFile(wb, filename);
                          showModal("Success", `Successfully exported ${allItems.length} items to ${filename}`);
                    } catch (error) {
                        // Export SOH Excel error handled silently for production
                        showModal("Error", "Failed to export SOH Excel file");
                    }
                }
                
                addListener('newJobButton', 'click', startNewJob);
                addListener('save-progress-button', 'click', handleSaveProgressToFile);
                addListener('main-tab-demo', 'click', () => switchMainTab('demo'));
                addListener('main-tab-workflow', 'click', () => switchMainTab('workflow'));
                addListener('downloadMasterForScan', 'click', downloadMasterForScan);
                addListener('processFirstCount', 'click', processFirstCount);
                addListener('finalizeFromFirstCount', 'click', finalizeFromFirstCount);
                addListener('generateRecountMasterFile', 'click', generateRecountMasterFile);
                addListener('processSecondCount', 'click', processSecondCount);
                addListener('exportCsvButton', 'click', exportFinalReport);
                addListener('exportJsonButton', 'click', exportStockCountToJSON);
                addListener('refreshChartsButton', 'click', renderFinalReportCharts);
                addListener('exportDemoCsvButton', 'click', exportDemoTable);
                addListener('exportSohExcelBtn', 'click', exportSohExcel);
                addListener('openScannerBtn', 'click', openScannerModal);
                addListener('final-openScannerBtn', 'click', finalOpenScannerModal);
                // closeScannerBtn removed - handled by floating scanner
                addListener('print-final-report-btn', 'click', handlePrintReport);
                // Scanner tab switching removed - handled by floating scanner
                // Capture button removed - handled by floating scanner

                addListener('demoSearchInput', 'keyup', applyDemoView);
                addListener('demoFilterSelect', 'change', applyDemoView);
                addListener('finalSearchInput', 'keyup', applyFinalReportView);
                addListener('finalFilterSelect', 'change', applyFinalReportView);
                addListener('load-progress-file', 'change', handleLoadProgressFromFile);                
                addListener('initialSohFile', 'change', handleSohFileUpload);                
                addListener('firstScanLogfile', 'change', () => updateFirstCountButton());
                addListener('firstMasterFile', 'change', () => updateFirstCountButton());
                addListener('salesDataFile', 'change', () => getEl('processSalesData').disabled = getEl('salesDataFile').files.length === 0);
                addListener('processSalesData', 'click', processSalesData);
                addListener('latestSohFile', 'change', handleLatestSohUpload);                
                addListener('secondScanLogfile', 'change', () => updateSecondCountButton());
                addListener('secondMasterFile', 'change', () => updateSecondCountButton());

                function updateSecondCountButton() {
                    const logFiles = getEl('secondScanLogfile').files.length > 0;
                    const masterFile = getEl('secondMasterFile').files.length > 0;
                    
                    // Enable button if at least one file type is uploaded
                    getEl('processSecondCount').disabled = !(logFiles || masterFile);
                }                function updateFirstCountButton() {
                    const logFiles = getEl('firstScanLogfile').files.length > 0;
                    const masterFile = getEl('firstMasterFile').files.length > 0;
                      // Enable button if at least one file type is uploaded
                    getEl('processFirstCount').disabled = !(logFiles || masterFile);
                }

                addListener('wf-step-tabs', 'click', e => { if (e.target.id.startsWith('wf-tab-btn-')) changeWorkflowTab(e.target.id.slice(-1)); });
                addListener('demo-count-container', 'click', e => { const header = e.target.closest('th[data-sort-by]'); if (header) handleSort('demoSort', header.dataset.sortBy, applyDemoView); });
                addListener('demo-count-container', 'input', e => { const { target: input } = e; const sku = input.closest('tr').dataset.sku; if (input.matches('input[type="number"]')) updateDemoCount(sku, input.value); else if (input.matches('input[type="text"]')) updateDemoRemark(sku, input.value); });
                addListener('final-report-table-container', 'click', e => { const header = e.target.closest('th[data-sort-by]'); if (header) handleSort('finalReportSort', header.dataset.sortBy, applyFinalReportView); });
                addListener('final-report-table-container', 'input', e => { const { target: input } = e; const sku = input.closest('tr').dataset.sku; if (input.matches('input[type="number"]')) updateFinalCount(sku, input.value); else if (input.matches('input[type="text"]')) updateRemark(sku, input.value); });
                  const handleEnter = (event) => { if (event.key === 'Enter') { const allInputs = Array.from(event.currentTarget.querySelectorAll('input[type="number"], input[type="text"]')); const currentIndex = allInputs.indexOf(event.target); if (currentIndex > -1 && currentIndex < allInputs.length - 1) allInputs[currentIndex + 1].focus(); } };
                addListener('demo-count-container', 'keydown', handleEnter);
                addListener('final-report-table-container', 'keydown', handleEnter);

                // === OCR Enhancement Event Listeners ===
                // Demo scanner OCR controls
                addListener('ocr-confidence-slider', 'input', (e) => {
                    ocrSettings.demo.confidence = parseInt(e.target.value);
                    document.getElementById('ocr-confidence-value').textContent = e.target.value + '%';
                });
                addListener('ocr-speed-select', 'change', (e) => {
                    ocrSettings.demo.speed = parseInt(e.target.value);
                    if (ocrStreamInterval) {
                        clearInterval(ocrStreamInterval);
                        ocrStreamInterval = setInterval(processOcrFrame, ocrSettings.demo.speed);
                    }
                });
                addListener('ocr-language-select', 'change', async (e) => {
                    ocrSettings.demo.language = e.target.value;
                    if (tesseractWorker) {
                        await initTesseract(ocrSettings.demo.language, true);
                    }
                });                addListener('ocr-preprocessing-select', 'change', (e) => {
                    ocrSettings.demo.preprocessing = e.target.value;
                });

                // Final scanner OCR controls
                addListener('final-ocr-confidence-slider', 'input', (e) => {
                    ocrSettings.final.confidence = parseInt(e.target.value);
                    document.getElementById('final-ocr-confidence-value').textContent = e.target.value + '%';
                });                addListener('final-ocr-speed-select', 'change', (e) => {
                    ocrSettings.final.speed = parseInt(e.target.value);
                    if (finalOcrStreaming) {
                        clearInterval(finalOcrStreamInterval);
                        finalOcrStreamInterval = setInterval(finalProcessOcrFrame, ocrSettings.final.speed);
                    }
                });
                addListener('final-ocr-language-select', 'change', async (e) => {
                    ocrSettings.final.language = e.target.value;
                    if (finalTesseractWorker) {
                        await initTesseract(ocrSettings.final.language, false);
                    }                });
                
                addListener('final-ocr-preprocessing-select', 'change', (e) => {
                    ocrSettings.final.preprocessing = e.target.value;
                });

                window.addEventListener('beforeunload', (e) => { if (hasUnsavedChanges) e.preventDefault(); });
            }
            
            initializeAppListeners();
            
            // === Initialize Floating Scanner ===
            
            function setupFloatingScanner() {
                floatingScanner = document.getElementById('floating-scanner');
                if (floatingScanner) {
                    // Call the actual initialization function
                    initializeFloatingScanner();
                } else {
                    // Floating scanner element not found - handled silently for production
                    // Retry after a short delay in case DOM is still loading
                    setTimeout(() => {
                        floatingScanner = document.getElementById('floating-scanner');
                        if (floatingScanner) {
                            initializeFloatingScanner();
                        }
                    }, 100);                }
            }
            
            // Initialize floating scanner after DOM is ready
            setupFloatingScanner();            // --- Final Report Scanner Logic ---
              function finalOpenScannerModal() {
                openFloatingScanner('final');
            }

            function finalCloseScannerModal() {
                // Legacy function - now handled by floating scanner
                closeFloatingScanner();
            }

            const finalScanCooldown = {};
            function finalOnBarcodeDetected(result) {
                const code = result.codeResult.code.trim();
                const now = Date.now();
                if (finalScanCooldown[code] && now - finalScanCooldown[code] < 10000) return;
                finalScanCooldown[code] = now;
                processFinalScannedCode(code, 'Barcode');
            }            function processFinalScannedCode(code, reason) {
                const scannedText = code.toUpperCase();
                
                // Use shared matching function for enhanced Apple product matching
                let item = findItemByScannedText(state.reconciledData, scannedText);

                if (item) {
                    playSound('success');
                    finalScannerResultsEl.innerHTML = `<div class="text-left w-full space-y-1"><p class="font-medium text-slate-800">${item.Description}</p><p class="text-sm text-slate-500">SKU: ${item.SKU}</p><div class="flex justify-between items-baseline pt-1"><span class="text-lg font-bold text-slate-700">Counted: <span class="text-blue-600">${item.Recount}</span> / ${item.SOH}</span><span class="text-lg font-bold">${item.FinalDiff === 0 ? '<span class="text-green-600">Matched</span>' : item.FinalDiff > 0 ? '<span class="text-yellow-600">Overage</span>' : '<span class="text-blue-600">Shortage</span>'}</span></div></div>`;
                    const row = document.querySelector(`#final-report-table-container tr[data-sku="${item.SKU}"]`);
                    if (row) {
                        row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        row.classList.add('ring-2', 'ring-offset-2', 'ring-green-500');
                        setTimeout(() => row.classList.remove('ring-2', 'ring-offset-2', 'ring-green-500'), 800);
                    }                } else {
                    playSound('error');
                    finalScannerResultsEl.innerHTML = `<div class="text-center w-full"><p class="font-bold text-red-600">SKU Not Found</p><p class="text-sm text-slate-500">${scannedText}</p></div>`;
                }
            }
        });

        // Initialize dev tools protection
        SPViAuth.setupDevToolsProtection();
    </script>
</body>
</html>
