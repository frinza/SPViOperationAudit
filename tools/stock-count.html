<!DOCTYPE html>
<html lang="en">
<head>    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ตรวจนับสินค้าสาขา</title><script src="https://cdn.tailwindcss.com"></script>
      <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-auth-compat.js"></script>
      <!-- Configuration Manager -->
    <script src="../config.js"></script>
    
    <!-- Session Manager -->
    <script src="../session-manager.js"></script>
    
    <!-- Firebase Auth System -->
    <script src="../firebase-auth.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/html5-qrcode"></script>    <script src="https://unpkg.com/@ericblade/quagga2@1.2.6/dist/quagga.min.js"></script>
    <!-- OCR Libraries with Pyodide -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>
    
    <!-- PDF Generation Libraries -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Thai:wght@400;500;700&display=swap" rel="stylesheet">    
    <!-- Main Stylesheet -->
    <link rel="stylesheet" href="../styles/spvi-main.css">
    <!-- Global Print Legal Section -->
    <link rel="stylesheet" href="../styles/print-legal.css">
    <!-- Global Print Header -->
    <link rel="stylesheet" href="../styles/print-header.css">      
    <style>        
    body {
            font-family: 'Sarabun', sans-serif;
            /* Safe area support for devices with notches */
            padding-left: env(safe-area-inset-left);
            padding-right: env(safe-area-inset-right);
        }        
        /* ===== FILTER LAYOUT RESPONSIVE BREAKPOINT ===== */
        /* Custom breakpoint at 1100px for filter layouts */
        .filter-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }        
        @media (min-width: 1101px) {
            .filter-container {
                flex-direction: row;
            }
            
            /* Override Tailwind's md:w-auto at our custom breakpoint */
            .w-full.md\:w-auto {
                width: auto;
            }
        }
        
        /* ===== MOBILE TAB NAVIGATION ENHANCEMENTS ===== */
        .scrollbar-hide {
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        
        .scrollbar-hide::-webkit-scrollbar {
            display: none;
        }
        @media (max-width: 1100px) {
            /* Enhanced mobile tab styling */
            .tab-button {
                background-color: transparent;
                border: none;
                cursor: pointer;
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
                position: relative;
                margin-bottom: -1px;
                min-height: 44px; /* iOS minimum touch target */
            }
            
            .tab-button.active {
                color: #1e40af !important;
                background-color: rgba(59, 130, 246, 0.05);
                border-bottom: 2px solid #1e40af;
            }
            
            .tab-button:not(.active):hover {
                background-color: rgba(148, 163, 184, 0.1);
            }
            
            /* Smooth scrolling for tab navigation */
            nav[class*="overflow-x-auto"] {
                scroll-behavior: smooth;
                -webkit-overflow-scrolling: touch;
                scrollbar-width: none;
                -ms-overflow-style: none;
                scroll-snap-type: x proximity;
            }
            
            nav[class*="overflow-x-auto"] .tab-button {
                scroll-snap-align: start;
            }
            
            nav[class*="overflow-x-auto"]::-webkit-scrollbar {
                display: none;
            }
              /* Improve mobile button spacing and touch targets */
            .btn, button:not(#spvi-user-info button):not(.spvi-nav-toggle):not(.spvi-logout-btn) {
                min-height: 44px;
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
            }
            
            /* Better mobile form inputs */
            input:not(#spvi-user-info input), select:not(#spvi-user-info select), textarea:not(#spvi-user-info textarea) {
                font-size: 16px; /* Prevent iOS zoom */
                min-height: 44px;
            }
        }            
        /* ===== MOBILE RESPONSIVE TABLE ENHANCEMENTS ===== */
        @media (max-width: 1100px) {
            /* Hide traditional table structure on mobile */
            .mobile-hidden {
                display: none !important;
            }
            
            /* Card-based layout for mobile */
            .mobile-card-view {
                display: block !important;
            }
              /* COMPACT MOBILE CARDS */
            .stock-card {
                background: white;
                border-radius: 0.5rem;
                border: 1px solid #e2e8f0;
                margin-bottom: 0.5rem;
                padding: 0.5rem;
                box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
                transition: all 0.2s ease;
                position: relative;
            }
            
            .stock-card:hover {
                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.12);
                transform: translateY(-1px);
            }
              .stock-card.diff-positive {
                border-left: 3px solid #f59e0b;
                background-color: #fefce8;
            }
            
            .stock-card.diff-negative {
                border-left: 3px solid #ef4444;
                background-color: #fef2f2;
            }
            
            .stock-card.diff-zero {
                border-left: 3px solid #22c55e;
                background-color: #f0fdf4;
            }
            
            .stock-card.diff-null {
                border-left: 3px solid #e5e7eb;
                background-color: white;
            }
            
            /* Compact header with inline elements */
            .stock-card-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0.375rem;
                gap: 0.375rem;
            }
            
            .stock-card-number {
                background: #e5e7eb;
                color: #374151;
                padding: 0.125rem 0.25rem;
                border-radius: 0.25rem;
                font-size: 0.65rem;
                font-weight: 600;
                min-width: fit-content;
            }
            
            .stock-card-sku {
                font-weight: 700;
                color: #1f2937;
                flex: 1;
                font-size: 0.85rem;
                line-height: 1.2;
            }
              /* Ultra compact description */
            .stock-card-description {
                color: #4b5563;
                margin-bottom: 0.375rem;
                line-height: 1.3;
                font-size: 0.75rem;
                display: -webkit-box;
                -webkit-line-clamp: 1;
                line-clamp: 1;
                -webkit-box-orient: vertical;
                overflow: hidden;
            }
            
            /* Horizontal layout for all data - single row */
            .stock-card-meta {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 0.375rem;
                gap: 0.25rem;
                flex-wrap: wrap;
            }
            
            .stock-card-field {
                display: flex;
                flex-direction: column;
                align-items: center;
                gap: 0.125rem;
                min-width: 0;
                flex: 1;
            }
            
            .stock-card-field label {
                font-size: 0.6rem;
                font-weight: 600;
                color: #6b7280;
                text-transform: uppercase;
                letter-spacing: 0.05em;
                white-space: nowrap;
            }
            
            .stock-card-value {
                font-size: 0.75rem;
                font-weight: 600;
                color: #374151;
                text-align: center;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
                max-width: 100%;
            }
            
            /* Compact controls in horizontal layout */
            .stock-card-controls {
                display: flex;
                gap: 0.375rem;
            }
            
            .stock-card-controls .stock-card-field {
                flex: 1;
                align-items: stretch;
            }            .stock-card-input {
                width: 100%;
                padding: 0.25rem;
                border: 1px solid #d1d5db;
                border-radius: 0.25rem;
                font-size: 0.75rem;
                background: white;
                transition: all 0.2s ease;
                min-height: 32px;
                max-height: 32px;
                height: 32px;
                text-align: center;
                line-height: 1.2;
                box-sizing: border-box;
            }
            
            /* Ensure all input fields in mobile cards have consistent sizing */
            .mobile-card-view input[type="number"],
            .mobile-card-view input[type="text"] {
                min-height: 32px;
                max-height: 32px;
                height: 32px;
                box-sizing: border-box;
            }
            
            .stock-card-input:focus {
                outline: none;
                border-color: #3b82f6;
                box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.1);
            }
            
            /* Compact actions */
            .stock-card-actions {
                display: flex;
                justify-content: flex-end;
                gap: 0.5rem;
                padding-top: 0.5rem;
                border-top: 1px solid #e5e7eb;
            }
            
            .stock-card-btn {
                padding: 0.5rem 0.75rem;
                border-radius: 0.375rem;
                font-size: 0.75rem;
                font-weight: 600;
                border: none;
                cursor: pointer;
                transition: all 0.2s ease;
                min-height: 36px;
                display: flex;
                align-items: center;
                justify-content: center;
                gap: 0.25rem;
            }
            
            .stock-card-btn-scan {
                background: #3b82f6;
                color: white;
                min-width: 80px;
            }
            
            .stock-card-btn-scan:hover {
                background: #2563eb;
                transform: translateY(-1px);
            }            
            /* Ensure search icon is visible and prevent text collision */
            .relative .absolute.left-3 {
                z-index: 10;
                pointer-events: none;
            }
            /* Search input specific styling - only apply padding to search inputs with icon */
            input[id*="SearchInput"] {
                padding-left: 3.5rem !important;
            }
            
            /* Hide placeholder text in search inputs on mobile, show only icon */
            input[id*="SearchInput"]::placeholder {
                color: transparent !important;
            }
            
            /* Mobile-specific improvements */
            .container {
                padding-left: 0.75rem !important;
                padding-right: 0.75rem !important;
            }
            
            header h1 {
                font-size: 1.75rem !important;
                line-height: 1.2 !important;
            }
            
            header p {
                font-size: 0.8rem !important;
                margin-top: 0.5rem !important;
            }
            
            /* Improve button and input layout on mobile */
            .bg-white.p-6, .bg-white.p-8 {
                padding: 0.75rem !important;
            }
            
            .flex.flex-col.md\\:flex-row {
                flex-direction: column !important;
                gap: 0.75rem !important;
            }
            
            .floating-scanner {
                width: 95% !important;
                max-width: none !important;
            }
            
            /* Make sure scan buttons are touch-friendly */
            button[id*="openScanner"], button[id*="Scan"] {
                min-height: 44px !important;
                font-size: 0.9rem !important;
                padding: 0.5rem 0.75rem !important;
            }
            
            /* Filter controls mobile optimization */
            select, input[type="text"] {
                min-height: 44px !important;
                font-size: 0.9rem !important;
                padding: 0.5rem !important;
            }
            
            /* Compact spacing for mobile */
            .mb-6 {
                margin-bottom: 1rem !important;
            }
            
            .mb-8 {
                margin-bottom: 1.25rem !important;
            }
        }          
        /* Desktop view - ensure card view is hidden */
        @media (min-width: 1101px) {
            .mobile-card-view {
                display: none !important;
            }
        }
        
        /* Default card view is hidden */
        .mobile-card-view {
            display: none;
        }
        
        /* ===== FLOATING SCANNER STYLES ===== */
        .floating-scanner {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            border-radius: 0.75rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border: 1px solid #e2e8f0;
            z-index: 1000;
            width: 85%;
            max-width: 320px;
            display: none;
            visibility: hidden;
            opacity: 0;
            transition: transform 0.3s ease-in-out, visibility 0.3s ease-in-out, opacity 0.3s ease-in-out;
        }
        
        .floating-scanner.active {
            display: block;
            visibility: visible;
            opacity: 1;
        }
        .floating-scanner-header {
            background: linear-gradient(90deg, #1e40af, #3b82f6);
            color: white;
            padding: 0.5rem 0.75rem;
            border-radius: 0.75rem 0.75rem 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: grab;
            user-select: none;
            font-size: 0.9rem;
        }
        
        .floating-scanner-header:active {
            cursor: grabbing;
        }
          .floating-scanner-content {
            padding: 0.75rem;
        }          .scanner-viewport {
            position: relative;
            width: 100%;
            height: 160px;
            background: #f8fafc;
            border: 2px solid #e2e8f0;
            border-radius: 0.5rem;
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .scanner-viewport video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        
        /* Ensure barcode scanner video appears correctly */
        #floating-qr-reader {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        #floating-qr-reader video {
            width: 100% !important;
            height: 100% !important;
            object-fit: cover;
        }
        
        #floating-qr-reader canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        
        .scan-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 40%;
            border: 2px solid #3b82f6;
            border-radius: 0.5rem;
            pointer-events: none;
        }
        
        .barcode-line {
            position: absolute;
            top: 50%;
            left: 10%;
            right: 10%;
            height: 2px;
            background: linear-gradient(90deg, transparent, #ef4444, transparent);
            animation: scan 2s ease-in-out infinite;
        }
        
        @keyframes scan {
            0%, 100% { opacity: 0.3; }
            50% { opacity: 1; }
        }
          /* Mobile responsiveness */
        @media (max-width: 480px) {
            .floating-scanner {
                width: 90%;
                max-width: none;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
            }
            
            .scanner-viewport {
                height: 140px;
            }
            
            .floating-scanner-content {
                padding: 0.5rem;
            }
        }
    </style>
    
    <script>
        // SPP (Spare Parts Program) Functions        
        function applySppSparePartsView() {
            if (!state || !state.sppSparePartsMaster || !Array.isArray(state.sppSparePartsMaster) || state.sppSparePartsMaster.length === 0) {
                const container = getEl('spp-spare-parts-container');
                if (container) container.innerHTML = '<p class="p-6 text-center text-slate-500">No SPP Spare Parts items found.</p>';
                updateSppSparePartsSummary();
                return;
            }

            // Ensure sppSparePartsCounts is initialized
            if (!state.sppSparePartsCounts) {
                state.sppSparePartsCounts = {};
            }

            const searchValue = getEl('sppSparePartsSearchInput')?.value?.toUpperCase() || '';
            const filterValue = getEl('sppSparePartsFilterSelect')?.value || 'all';
            const groupCodeFilter = getEl('sppSparePartsGroupCodeFilter')?.value || 'all';
            const ageFilter = getEl('sppSparePartsAgeFilter')?.value || 'all';
            const subclassFilter = getEl('sppSparePartsSubclassFilter')?.value || 'all';            
            let dataView = state.sppSparePartsMaster.filter(item => {
                // Search filter
                if (searchValue && !(item.SKU.toUpperCase().includes(searchValue) || item.Description.toUpperCase().includes(searchValue))) return false;
                
                // Status filter
                const diff = (item.counted === null) ? null : item.counted - item.SOH;
                if (filterValue !== 'all') {
                    if (filterValue === 'uncounted' && item.counted !== null) return false;
                    if (filterValue === 'discrepancy' && (diff === null || diff === 0)) return false;
                    if (filterValue === 'matched' && (diff === null || diff !== 0)) return false;
                }
                
                // GROUP_CODE filter
                if (groupCodeFilter !== 'all' && item.GROUP_CODE !== groupCodeFilter) return false;
                
                // Age filter
                if (ageFilter !== 'all') {
                    const age = parseInt(item.Age) || 0;
                    if (ageFilter === 'new' && age >= 300) return false;
                    if (ageFilter === 'old' && age < 300) return false;
                }
                  // SUBCLASS filter
                if (subclassFilter !== 'all' && item.SUBCLASS_CODE !== subclassFilter) return false;
                
                return true;
            });

            const { column, direction } = state.sppSparePartsSort || { column: 'SKU', direction: 'asc' };
            dataView.sort((a, b) => {
                let valA, valB;
                
                if (column === 'diff') {
                    valA = (a.counted === null) ? null : a.counted - a.SOH;
                    valB = (b.counted === null) ? null : b.counted - b.SOH;
                } else if (column === 'counted') {
                    valA = a.counted;
                    valB = b.counted;
                } else {
                    valA = a[column];
                    valB = b[column];
                }
                
                if (valA === null || valA === undefined) return 1;
                if (valB === null || valB === undefined) return -1;
                
                if (typeof valA === 'string') {
                    return direction === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                }
                return direction === 'asc' ? valA - valB : valB - valA;
            });
            
            if (typeof renderSppSparePartsTable === 'function') {
                renderSppSparePartsTable(dataView);
            }
            updateSppSparePartsSummary();
        }          
        function renderSppSparePartsTable(data) {
            const container = getEl('spp-spare-parts-container');
            const cardsContainer = getEl('spp-spare-parts-cards');
            
            // Desktop table view
            const headers = `<thead><tr>
                <th class="p-2 text-center w-12">NO.</th>
                <th class="p-2 text-left" data-sort-by="SKU">SKU<span class="sort-indicator"></span></th>
                <th class="p-2 text-left" data-sort-by="Description">Description<span class="sort-indicator"></span></th>
                <th class="p-2 text-center" data-sort-by="Price">SRP<span class="sort-indicator"></span></th>
                <th class="p-2 text-center" data-sort-by="Age">Age<span class="sort-indicator"></span></th>
                <th class="p-2 text-center" data-sort-by="SOH">SOH<span class="sort-indicator"></span></th>
                <th class="p-2 text-center" data-sort-by="counted">Counted<span class="sort-indicator"></span></th>
                <th class="p-2 text-center" data-sort-by="diff">Diff<span class="sort-indicator"></span></th>
                <th class="p-2 text-center" data-sort-by="remark">Remark<span class="sort-indicator"></span></th>
            </tr></thead>`;
            const body = data.length > 0 ? data.map((item, idx) => renderSppSparePartsRow(item, idx)).join('') : `<tr><td colspan="9" class="text-center p-6 text-slate-500">No items match filter.</td></tr>`;
            container.innerHTML = `<table class="w-full text-sm">${headers}<tbody>${body}</tbody></table>`;
            
            // Mobile card view
            if (data.length > 0) {
                cardsContainer.innerHTML = data.map((item, idx) => renderSppSparePartsCard(item, idx)).join('');
            } else {
                cardsContainer.innerHTML = '<p class="text-center p-6 text-slate-500">No items match filter.</p>';
            }
            
            const sortingTh = container.querySelector(`th[data-sort-by="${state.sppSparePartsSort.column}"]`);
            if (sortingTh) {
                const indicator = sortingTh.querySelector('.sort-indicator');
                indicator.textContent = state.sppSparePartsSort.direction === 'asc' ? '▲' : '▼';
                indicator.style.color = state.sppSparePartsSort.direction === 'asc' ? '#22c55e' : '#ef4444';
            }
        }

        function renderSppSparePartsRow(item, idx) {
            const diff = (item.counted === null) ? null : item.counted - item.SOH;
            const diffText = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
            let { rowClass } = getRowVisuals(diff, false);
            
            const categoryBadge = getCategoryBadge(item);
            const branchTypeBadge = getBranchTypeBadge(item);
              return `<tr class="border-b border-slate-200 transition-colors duration-200 ${rowClass}" data-sku="${item.SKU}">
                <td class="p-2 text-center">${idx + 1}</td>
                <td class="p-2 font-medium text-slate-700">
                    ${item.SKU}
                    ${branchTypeBadge}
                </td>
                <td class="p-2 text-slate-600">
                    ${item.Description}
                    ${categoryBadge}
                </td>                <td class="p-2 text-center text-slate-600">${item.Price ?? 0}</td>
                <td class="p-2 text-center text-slate-600">${item.Age || 'N/A'}</td>                <td class="p-2 text-center text-slate-600">${item.SOH}</td>
                <td class="p-2 text-center text-slate-600"><input type="number" value="${item.counted ?? 0}" class="w-full text-center p-1.5 border border-slate-300 rounded-md bg-white"/></td>
                <td class="p-2 text-center font-bold diff-cell ${getDiffColorClass(diff)}">${diffText}</td>
                <td class="p-2 text-center"><input type="text" value="${item.remark ?? ''}" class="w-full text-center p-1.5 border border-slate-300 rounded-md bg-white"/></td>
            </tr>`;
        }        function renderSppSparePartsCard(item, idx) {
            const diff = (item.counted === null) ? null : item.counted - item.SOH;
            const diffText = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
            const diffClass = diff === null ? 'diff-null' : diff > 0 ? 'diff-positive' : diff < 0 ? 'diff-negative' : 'diff-zero';
            
            const categoryBadge = getCategoryBadge(item);
            const branchTypeBadge = getBranchTypeBadge(item);
            
            return `
                <div class="stock-card ${diffClass}" data-sku="${item.SKU}">
                    <div class="stock-card-header">
                        <span class="stock-card-number">#${idx + 1}</span>
                        <span class="stock-card-sku">${item.SKU}</span>
                        ${branchTypeBadge}
                    </div>
                    
                    <div class="stock-card-description">
                        ${item.Description}
                    </div>
                    
                    <div class="stock-card-meta">
                        <div class="stock-card-field">
                            <label>SRP</label>
                            <span class="stock-card-value">${item.Price ?? 0}</span>
                        </div>
                        <div class="stock-card-field">
                            <label>Age</label>
                            <span class="stock-card-value">${item.Age || 'N/A'}</span>
                        </div>
                        <div class="stock-card-field">
                            <label>SOH</label>
                            <span class="stock-card-value">${item.SOH}</span>
                        </div>
                        <div class="stock-card-field">
                            <label>Diff</label>
                            <span class="stock-card-value font-bold ${getDiffColorClass(diff)}">${diffText}</span>
                        </div>
                    </div>
                    
                    <div class="stock-card-controls">
                        <div class="stock-card-field">
                            <label>Counted</label>
                            <input type="number" value="${item.counted ?? 0}" 
                                   class="stock-card-input" 
                                   onchange="updateSppSparePartsCount('${item.SKU}', this.value)" />
                        </div>
                        <div class="stock-card-field">
                            <label>Remark</label>
                            <input type="text" value="${item.remark ?? ''}" 
                                   class="stock-card-input" 
                                   onchange="updateSppSparePartsRemark('${item.SKU}', this.value)" />
                        </div>                    </div>
                </div>
            `;
        }
          function updateSppSparePartsSummary() {
            if (!state || !state.sppSparePartsMaster || !Array.isArray(state.sppSparePartsMaster) || state.sppSparePartsMaster.length === 0) {
                // Clear summary if no data
                const summaryEl = getEl('spp-spare-parts-summary');
                if (summaryEl) summaryEl.innerHTML = '';
                return;
            }
            
            // Ensure sppSparePartsCounts is initialized
            if (!state.sppSparePartsCounts) {
                state.sppSparePartsCounts = {};
            }
            
            const totalSOH = state.sppSparePartsMaster.reduce((sum, item) => sum + (item.SOH || 0), 0);
            const totalSOHPrice = state.sppSparePartsMaster.reduce((sum, item) => sum + ((item.SOH || 0) * (item.Price || 0)), 0);
            const countedSKUs = Object.values(state.sppSparePartsCounts).filter(c => c && c.qty !== null && c.qty !== undefined).length;
            const countedSOHValue = state.sppSparePartsMaster.reduce((sum, item) => {
                const counted = state.sppSparePartsCounts[item.SKU]?.qty;
                return sum + ((counted || 0) * (item.Price || 0));
            }, 0);
            const countedSOH = state.sppSparePartsMaster.reduce((sum, item) => {
                const counted = state.sppSparePartsCounts[item.SKU]?.qty;
                return sum + (counted || 0);
            }, 0);
            const diffItems = state.sppSparePartsMaster.filter(item => { 
                const countInfo = state.sppSparePartsCounts[item.SKU]; 
                return countInfo && countInfo.qty !== null && countInfo.qty !== undefined && countInfo.qty !== (item.SOH || 0); 
            }).length;

            const summaryEl = getEl('spp-spare-parts-summary');
            if (summaryEl) {
                summaryEl.innerHTML = `
                    <div class="grid grid-cols-2 gap-x-4 gap-y-2">
                        <div class="flex justify-between gap-2"><span>Total SPP Spare Parts SOH:</span><span class="font-bold">${formatNumber(totalSOH)}</span></div>
                        <div class="flex justify-between gap-2"><span>Total SPP Spare Parts SOH Value:</span><span class="font-bold text-blue-600">${formatNumber(totalSOHPrice)}</span></div>
                        <div class="flex justify-between gap-2"><span>Counted SPP Spare Parts SOH:</span><span class="font-bold text-green-600">${formatNumber(countedSOH)}</span></div>
                        <div class="flex justify-between gap-2"><span>Counted SPP Spare Parts SOH Value:</span><span class="font-bold text-green-600">${formatNumber(countedSOHValue)}</span></div>
                        <div class="flex justify-between gap-2"><span>Total SPP Spare Parts SKUs:</span><span class="font-bold">${formatNumber(state.sppSparePartsMaster.length)}</span></div>
                        <div class="flex justify-between gap-2"><span>Counted SKUs:</span><span class="font-bold text-green-600">${countedSKUs}</span></div>
                        <div class="flex justify-between gap-2 col-span-2"><span>Discrepancies:</span><span class="font-bold text-red-600">${diffItems}</span></div>
                    </div>
                `;
            }
        }
        function updateSppSparePartsCount(sku, value, reason = 'SPP-Manual') {
            const item = state.sppSparePartsMaster.find(i => i.SKU === sku);
            if (!item) return;
            
            // Ensure sppSparePartsCounts is initialized
            if (!state.sppSparePartsCounts) {
                state.sppSparePartsCounts = {};
            }
            
            const intValue = value === '' ? null : parseInt(value, 10);
            item.counted = isNaN(intValue) ? null : intValue;
            
            if (intValue === null) {
                delete state.sppSparePartsCounts[sku];
            } else {
                state.sppSparePartsCounts[sku] = { qty: intValue, reason: reason };
            }
            
            // Update final report if it exists
            if (state.reconciledData && state.reconciledData.length > 0) {
                const reportItem = state.reconciledData.find(i => i.SKU === sku);
                if (reportItem) {
                    const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(sku);
                    reportItem.Recount = intValue ?? 0;
                    reportItem.FinalDiff = reportItem.Recount - reportItem.SOH;
                    reportItem.ReasonFinal = wasSohUpdated ? 'SOHupdated-SPP-Manual' : 'SPP-Manual';
                    if (typeof applyFinalReportView === 'function') applyFinalReportView();
                    if (typeof renderFinalReportCharts === 'function') renderFinalReportCharts();
                }
            }
            // Update table row display
            const row = getEl('spp-spare-parts-container').querySelector(`tr[data-sku="${sku}"]`);
            if (row) {
                const diff = item.counted === null ? null : item.counted - item.SOH;
                const diffCell = row.querySelector('.diff-cell');
                if (diffCell) {
                    diffCell.textContent = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
                    diffCell.className = `p-2 text-center font-bold diff-cell ${getDiffColorClass(diff)}`;
                }
                if (typeof updateTableRowVisuals === 'function') {
                    updateTableRowVisuals(row, diff, false);
                }
            }
              // Update mobile card display
            const card = getEl('spp-spare-parts-cards').querySelector(`[data-sku="${sku}"]`);
            if (card) {
                const diff = item.counted === null ? null : item.counted - item.SOH;
                const diffText = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
                const diffClass = diff === null ? 'diff-null' : diff > 0 ? 'diff-positive' : diff < 0 ? 'diff-negative' : 'diff-zero';
                
                // Update card class
                card.className = `stock-card ${diffClass}`;
                
                // Update diff value
                const diffValueEl = card.querySelector('.stock-card-field:nth-of-type(4) .stock-card-value');
                if (diffValueEl) {
                    diffValueEl.textContent = diffText;
                    diffValueEl.className = `stock-card-value font-bold ${getDiffColorClass(diff)}`;
                }
                
                // Update input value
                const countInput = card.querySelector('input[type="number"]');
                if (countInput) countInput.value = item.counted ?? 0;
            }
            
            updateSppSparePartsSummary();
            if (typeof updateFinalReportSummary === 'function') updateFinalReportSummary();
            if (typeof setUnsavedChanges === 'function') setUnsavedChanges(true);        
        }
            
            function updateSppSparePartsRemark(sku, value) {
            const item = state.sppSparePartsMaster.find(i => i.SKU === sku);
            if (item) {
                item.remark = value;
                setUnsavedChanges(true);
            }        
        }

        // SPP Glue Functions
        function applySppGlueView() {
            if (!state || !state.sppGlueMaster || !Array.isArray(state.sppGlueMaster) || state.sppGlueMaster.length === 0) {
                const container = getEl('spp-glue-container');
                if (container) container.innerHTML = '<p class="p-6 text-center text-slate-500">No SPP Glue items found.</p>';
                updateSppGlueSummary();
                return;
            }

            // Ensure sppGlueCounts is initialized
            if (!state.sppGlueCounts) {
                state.sppGlueCounts = {};
            }
            
            const searchValue = getEl('sppGlueSearchInput')?.value?.toLowerCase() || '';
            const filterValue = getEl('sppGlueFilterSelect')?.value || 'all';
            const groupCodeFilter = getEl('sppGlueGroupCodeFilter')?.value || 'all';
            const ageFilter = getEl('sppGlueAgeFilter')?.value || 'all';
            const subclassFilter = getEl('sppGlueSubclassFilter')?.value || 'all';
              let filteredData = state.sppGlueMaster.filter(item => {
                // Search filter
                if (searchValue && !(item.SKU.toLowerCase().includes(searchValue) || item.Description.toLowerCase().includes(searchValue))) return false;
                
                // Status filter
                const diff = (item.counted === null) ? null : item.counted - item.SOH;
                if (filterValue !== 'all') {
                    if (filterValue === 'uncounted' && item.counted !== null) return false;
                    if (filterValue === 'discrepancy' && (diff === null || diff === 0)) return false;
                    if (filterValue === 'matched' && (diff === null || diff !== 0)) return false;
                }
                
                // GROUP_CODE filter
                if (groupCodeFilter !== 'all' && item.GROUP_CODE !== groupCodeFilter) return false;
                
                // Age filter
                if (ageFilter !== 'all') {
                    const age = parseInt(item.Age) || 0;
                    if (ageFilter === 'new' && age >= 300) return false;
                    if (ageFilter === 'old' && age < 300) return false;
                }
                  // SUBCLASS filter
                if (subclassFilter !== 'all' && item.SUBCLASS_CODE !== subclassFilter) return false;
                
                return true;
            });
            
            // Apply sorting
            const { column, direction } = state.sppGlueSort || { column: 'SKU', direction: 'asc' };
            filteredData.sort((a, b) => {
                let valA, valB;
                
                if (column === 'diff') {
                    valA = (a.counted === null) ? null : a.counted - a.SOH;
                    valB = (b.counted === null) ? null : b.counted - b.SOH;
                } else if (column === 'counted') {
                    valA = a.counted;
                    valB = b.counted;
                } else {
                    valA = a[column];
                    valB = b[column];
                }
                
                if (valA === null || valA === undefined) return 1;
                if (valB === null || valB === undefined) return -1;
                
                if (typeof valA === 'string') {
                    return direction === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                }
                return direction === 'asc' ? valA - valB : valB - valA;
            });
              if (typeof renderSppGlueTable === 'function') {
                renderSppGlueTable(filteredData);
            }
            updateSppGlueSummary();
        }          
        function renderSppGlueTable(data) {
            const container = getEl('spp-glue-container');
            const cardsContainer = getEl('spp-glue-cards');
            
            // Desktop table view
            const headers = `<thead><tr>
                <th class="p-2 text-center w-12">NO.</th>
                <th class="p-2 text-left" data-sort-by="SKU">SKU<span class="sort-indicator"></span></th>
                <th class="p-2 text-left" data-sort-by="Description">Description<span class="sort-indicator"></span></th>
                <th class="p-2 text-center" data-sort-by="Price">SRP<span class="sort-indicator"></span></th>
                <th class="p-2 text-center" data-sort-by="Age">Age<span class="sort-indicator"></span></th>
                <th class="p-2 text-center" data-sort-by="SOH">SOH<span class="sort-indicator"></span></th>
                <th class="p-2 text-center" data-sort-by="counted">Counted<span class="sort-indicator"></span></th>
                <th class="p-2 text-center" data-sort-by="diff">Diff<span class="sort-indicator"></span></th>
                <th class="p-2 text-center" data-sort-by="remark">Remark<span class="sort-indicator"></span></th>
            </tr></thead>`;
            const body = data.length > 0 ? data.map((item, idx) => renderSppGlueRow(item, idx)).join('') : `<tr><td colspan="9" class="text-center p-6 text-slate-500">No items match filter.</td></tr>`;
            container.innerHTML = `<table class="w-full text-sm">${headers}<tbody>${body}</tbody></table>`;
            
            // Mobile card view
            if (data.length > 0) {
                cardsContainer.innerHTML = data.map((item, idx) => renderSppGlueCard(item, idx)).join('');
            } else {
                cardsContainer.innerHTML = '<p class="text-center p-6 text-slate-500">No items match filter.</p>';
            }
            
            const sortingTh = container.querySelector(`th[data-sort-by="${state.sppGlueSort.column}"]`);
            if (sortingTh) {
                const indicator = sortingTh.querySelector('.sort-indicator');                indicator.textContent = state.sppGlueSort.direction === 'asc' ? '▲' : '▼';
                indicator.style.color = state.sppGlueSort.direction === 'asc' ? '#22c55e' : '#ef4444';
            }
        }
        function renderSppGlueRow(item, idx) {
            const diff = (item.counted === null) ? null : item.counted - item.SOH;
            const diffText = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
            let { rowClass } = getRowVisuals(diff, false);
            
            const categoryBadge = getCategoryBadge(item);
            const branchTypeBadge = getBranchTypeBadge(item);
            
            return `<tr class="border-b border-slate-200 transition-colors duration-200 ${rowClass}" data-sku="${item.SKU}">
                <td class="p-2 text-center">${idx + 1}</td>
                <td class="p-2 font-medium text-slate-700">
                    ${item.SKU}
                    ${branchTypeBadge}
                </td>
                <td class="p-2 text-slate-600">
                    ${item.Description}
                    ${categoryBadge}
                </td>                <td class="p-2 text-center text-slate-600">${item.Price ?? 0}</td>
                <td class="p-2 text-center text-slate-600">${item.Age || 'N/A'}</td>
                <td class="p-2 text-center text-slate-600">${item.SOH}</td>
                <td class="p-2 text-center text-slate-600"><input type="number" value="${item.counted ?? 0}" class="w-full text-center p-1.5 border border-slate-300 rounded-md bg-white"/></td>                <td class="p-2 text-center font-bold diff-cell ${getDiffColorClass(diff)}">${diffText}</td>
                <td class="p-2 text-center"><input type="text" value="${item.remark ?? ''}" class="w-full text-center p-1.5 border border-slate-300 rounded-md bg-white"/></td>            </tr>`;
        }        function renderSppGlueCard(item, idx) {
            const diff = (item.counted === null) ? null : item.counted - item.SOH;
            const diffText = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
            const diffClass = diff === null ? 'diff-null' : diff > 0 ? 'diff-positive' : diff < 0 ? 'diff-negative' : 'diff-zero';
            
            const categoryBadge = getCategoryBadge(item);
            const branchTypeBadge = getBranchTypeBadge(item);
            
            return `
                <div class="stock-card ${diffClass}" data-sku="${item.SKU}">
                    <div class="stock-card-header">
                        <span class="stock-card-number">#${idx + 1}</span>
                        <span class="stock-card-sku">${item.SKU}</span>
                        ${branchTypeBadge}
                    </div>
                    
                    <div class="stock-card-description">
                        ${item.Description}
                    </div>
                    
                    <div class="stock-card-meta">
                        <div class="stock-card-field">
                            <label>SRP</label>
                            <span class="stock-card-value">${item.Price ?? 0}</span>
                        </div>
                        <div class="stock-card-field">
                            <label>Age</label>
                            <span class="stock-card-value">${item.Age || 'N/A'}</span>
                        </div>
                        <div class="stock-card-field">
                            <label>SOH</label>
                            <span class="stock-card-value">${item.SOH}</span>
                        </div>
                        <div class="stock-card-field">
                            <label>Diff</label>
                            <span class="stock-card-value font-bold ${getDiffColorClass(diff)}">${diffText}</span>
                        </div>
                    </div>
                    
                    <div class="stock-card-controls">
                        <div class="stock-card-field">
                            <label>Counted</label>
                            <input type="number" value="${item.counted ?? 0}" 
                                   class="stock-card-input" 
                                   onchange="updateSppGlueCount('${item.SKU}', this.value)" />
                        </div>
                        <div class="stock-card-field">
                            <label>Remark</label>
                            <input type="text" value="${item.remark ?? ''}" 
                                   class="stock-card-input" 
                                   onchange="updateSppGlueRemark('${item.SKU}', this.value)" />
                        </div>                    </div>
                </div>
            `;
        }        
        function updateSppGlueSummary() {
            if (!state || !state.sppGlueMaster || !Array.isArray(state.sppGlueMaster) || state.sppGlueMaster.length === 0) {
                const summaryEl = getEl('spp-glue-summary');
                if (summaryEl) summaryEl.innerHTML = '';
                return;
            }
            
            // Ensure sppGlueCounts is initialized
            if (!state.sppGlueCounts) {
                state.sppGlueCounts = {};
            }
            
            const totalSOH = state.sppGlueMaster.reduce((sum, item) => sum + (item.SOH || 0), 0);
            const totalSOHPrice = state.sppGlueMaster.reduce((sum, item) => sum + ((item.SOH || 0) * (item.Price || 0)), 0);
            const countedSKUs = Object.values(state.sppGlueCounts).filter(c => c && c.qty !== null && c.qty !== undefined).length;
            const countedSOHValue = state.sppGlueMaster.reduce((sum, item) => {
                const counted = state.sppGlueCounts[item.SKU]?.qty;
                return sum + ((counted || 0) * (item.Price || 0));
            }, 0);
            const countedSOH = state.sppGlueMaster.reduce((sum, item) => {
                const counted = state.sppGlueCounts[item.SKU]?.qty;
                return sum + (counted || 0);
            }, 0);
            const diffItems = state.sppGlueMaster.filter(item => { 
                const countInfo = state.sppGlueCounts[item.SKU]; 
                return countInfo && countInfo.qty !== null && countInfo.qty !== undefined && countInfo.qty !== (item.SOH || 0); 
            }).length;

            const summaryEl = getEl('spp-glue-summary');
            if (summaryEl) {
                summaryEl.innerHTML = `
                    <div class="grid grid-cols-2 gap-x-4 gap-y-2">
                        <div class="flex justify-between gap-2"><span>Total SPP Glue/Adhesive SOH:</span><span class="font-bold">${formatNumber(totalSOH)}</span></div>
                        <div class="flex justify-between gap-2"><span>Total SPP Glue/Adhesive SOH Value:</span><span class="font-bold text-blue-600">${formatNumber(totalSOHPrice)}</span></div>
                        <div class="flex justify-between gap-2"><span>Counted SPP Glue/Adhesive SOH:</span><span class="font-bold text-green-600">${formatNumber(countedSOH)}</span></div>
                        <div class="flex justify-between gap-2"><span>Counted SPP Glue/Adhesive SOH Value:</span><span class="font-bold text-green-600">${formatNumber(countedSOHValue)}</span></div>
                        <div class="flex justify-between gap-2"><span>Total SPP Glue/Adhesive SKUs:</span><span class="font-bold">${formatNumber(state.sppGlueMaster.length)}</span></div>
                        <div class="flex justify-between gap-2"><span>Counted SKUs:</span><span class="font-bold text-green-600">${countedSKUs}</span></div>
                        <div class="flex justify-between gap-2 col-span-2"><span>Discrepancies:</span><span class="font-bold text-red-600">${diffItems}</span></div>
                    </div>
                `;
            }
        }        
        function updateSppGlueCount(sku, value, reason = 'SPP-Manual') {
            const item = state.sppGlueMaster.find(i => i.SKU === sku);
            if (!item) return;
            
            // Ensure sppGlueCounts is initialized
            if (!state.sppGlueCounts) {
                state.sppGlueCounts = {};
            }
            
            const numValue = value === '' ? null : parseInt(value, 10);
            if (numValue !== null && (isNaN(numValue) || numValue < 0)) return;
            
            item.counted = numValue;
            
            if (numValue !== null) {
                state.sppGlueCounts[sku] = { qty: numValue, reason: reason };
            } else {
                delete state.sppGlueCounts[sku];
            }
            
            // Update final report if it exists
            if (state.reconciledData && state.reconciledData.length > 0) {
                const reportItem = state.reconciledData.find(i => i.SKU === sku);
                if (reportItem) {
                    const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(sku);
                    reportItem.Recount = numValue ?? 0;
                    reportItem.FinalDiff = reportItem.Recount - reportItem.SOH;
                    reportItem.ReasonFinal = wasSohUpdated ? 'SOHupdated-SPP-Manual' : 'SPP-Manual';
                    if (typeof applyFinalReportView === 'function') applyFinalReportView();
                    if (typeof renderFinalReportCharts === 'function') renderFinalReportCharts();
                }
            }
            // Update table row display immediately
            const row = getEl('spp-glue-container').querySelector(`tr[data-sku="${sku}"]`);
            if (row) {
                const diff = item.counted === null ? null : item.counted - item.SOH;
                const diffCell = row.querySelector('.diff-cell');
                if (diffCell) {
                    diffCell.textContent = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
                    diffCell.className = `p-2 text-center font-bold diff-cell ${getDiffColorClass(diff)}`;
                }
                if (typeof updateTableRowVisuals === 'function') {
                    updateTableRowVisuals(row, diff, false);
                }
            }
              // Update mobile card display
            const card = getEl('spp-glue-cards').querySelector(`[data-sku="${sku}"]`);
            if (card) {
                const diff = item.counted === null ? null : item.counted - item.SOH;
                const diffText = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
                const diffClass = diff === null ? 'diff-null' : diff > 0 ? 'diff-positive' : diff < 0 ? 'diff-negative' : 'diff-zero';
                
                // Update card class
                card.className = `stock-card ${diffClass}`;
                
                // Update diff value
                const diffValueEl = card.querySelector('.stock-card-field:nth-of-type(4) .stock-card-value');
                if (diffValueEl) {
                    diffValueEl.textContent = diffText;
                    diffValueEl.className = `stock-card-value font-bold ${getDiffColorClass(diff)}`;
                }
                
                // Update input value
                const countInput = card.querySelector('input[type="number"]');
                if (countInput) countInput.value = item.counted ?? 0;
            }
            
            updateSppGlueSummary();
            if (typeof updateFinalReportSummary === 'function') updateFinalReportSummary();
            if (typeof setUnsavedChanges === 'function') setUnsavedChanges(true);
        }

        function updateSppGlueRemark(sku, value) {
            const item = state.sppGlueMaster.find(i => i.SKU === sku);
            if (item) {
                item.remark = value;
                setUnsavedChanges(true);
            }
        }        
        // SPP Tools Functions        
        function applySppToolsView() {
            if (!state || !state.sppToolsMaster || !Array.isArray(state.sppToolsMaster) || state.sppToolsMaster.length === 0) {
                const container = getEl('spp-tools-container');
                if (container) container.innerHTML = '<p class="p-6 text-center text-slate-500">No SPP Tools items found.</p>';
                updateSppToolsSummary();
                return;
            }

            // Ensure sppToolsCounts is initialized
            if (!state.sppToolsCounts) {
                state.sppToolsCounts = {};
            }
            
            const searchValue = getEl('sppToolsSearchInput')?.value?.toLowerCase() || '';
            const filterValue = getEl('sppToolsFilterSelect')?.value || 'all';
            const groupCodeFilter = getEl('sppToolsGroupCodeFilter')?.value || 'all';
            const ageFilter = getEl('sppToolsAgeFilter')?.value || 'all';
            const subclassFilter = getEl('sppToolsSubclassFilter')?.value || 'all';
              let filteredData = state.sppToolsMaster.filter(item => {
                // Search filter
                if (searchValue && !(item.SKU.toLowerCase().includes(searchValue) || item.Description.toLowerCase().includes(searchValue))) return false;
                
                // Status filter
                const diff = (item.counted === null) ? null : item.counted - item.SOH;
                if (filterValue !== 'all') {
                    if (filterValue === 'uncounted' && item.counted !== null) return false;
                    if (filterValue === 'discrepancy' && (diff === null || diff === 0)) return false;
                    if (filterValue === 'matched' && (diff === null || diff !== 0)) return false;
                }
                
                // GROUP_CODE filter
                if (groupCodeFilter !== 'all' && item.GROUP_CODE !== groupCodeFilter) return false;
                
                // Age filter
                if (ageFilter !== 'all') {
                    const age = parseInt(item.Age) || 0;
                    if (ageFilter === 'new' && age >= 300) return false;
                    if (ageFilter === 'old' && age < 300) return false;
                }
                  // SUBCLASS filter
                if (subclassFilter !== 'all' && item.SUBCLASS_CODE !== subclassFilter) return false;
                
                return true;
            });
            // Apply sorting
            const { column, direction } = state.sppToolsSort || { column: 'SKU', direction: 'asc' };
            filteredData.sort((a, b) => {
                let valA, valB;
                
                if (column === 'diff') {
                    valA = (a.counted === null) ? null : a.counted - a.SOH;
                    valB = (b.counted === null) ? null : b.counted - b.SOH;
                } else if (column === 'counted') {
                    valA = a.counted;
                    valB = b.counted;
                } else {
                    valA = a[column];
                    valB = b[column];
                }
                
                if (valA === null || valA === undefined) return 1;
                if (valB === null || valB === undefined) return -1;
                
                if (typeof valA === 'string') {
                    return direction === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                }                
                return direction === 'asc' ? valA - valB : valB - valA;
            });
            
            if (typeof renderSppToolsTable === 'function') {
                renderSppToolsTable(filteredData);
            }
            updateSppToolsSummary();
        }          
        function renderSppToolsTable(data) {
            const container = getEl('spp-tools-container');
            const cardsContainer = getEl('spp-tools-cards');
            
            // Desktop table view
            const headers = `<thead><tr>
                <th class="p-2 text-center w-12">NO.</th>
                <th class="p-2 text-left" data-sort-by="SKU">SKU<span class="sort-indicator"></span></th>
                <th class="p-2 text-left" data-sort-by="Description">Description<span class="sort-indicator"></span></th>
                <th class="p-2 text-center" data-sort-by="Price">SRP<span class="sort-indicator"></span></th>
                <th class="p-2 text-center" data-sort-by="Age">Age<span class="sort-indicator"></span></th>
                <th class="p-2 text-center" data-sort-by="SOH">SOH<span class="sort-indicator"></span></th>
                <th class="p-2 text-center" data-sort-by="counted">Counted<span class="sort-indicator"></span></th>
                <th class="p-2 text-center" data-sort-by="diff">Diff<span class="sort-indicator"></span></th>
                <th class="p-2 text-center" data-sort-by="remark">Remark<span class="sort-indicator"></span></th>
            </tr></thead>`;
            const body = data.length > 0 ? data.map((item, idx) => renderSppToolsRow(item, idx)).join('') : `<tr><td colspan="9" class="text-center p-6 text-slate-500">No items match filter.</td></tr>`;
            container.innerHTML = `<table class="w-full text-sm">${headers}<tbody>${body}</tbody></table>`;
            
            // Mobile card view
            if (data.length > 0) {
                cardsContainer.innerHTML = data.map((item, idx) => renderSppToolsCard(item, idx)).join('');
            } else {
                cardsContainer.innerHTML = '<p class="text-center p-6 text-slate-500">No items match filter.</p>';
            }
            
            const sortingTh = container.querySelector(`th[data-sort-by="${state.sppToolsSort.column}"]`);
            if (sortingTh) {
                const indicator = sortingTh.querySelector('.sort-indicator');
                indicator.textContent = state.sppToolsSort.direction === 'asc' ? '▲' : '▼';                
                indicator.style.color = state.sppToolsSort.direction === 'asc' ? '#22c55e' : '#ef4444';
            }
        }
        function renderSppToolsRow(item, idx) {
            const diff = (item.counted === null) ? null : item.counted - item.SOH;
            const diffText = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
            let { rowClass } = getRowVisuals(diff, false);
            
            const categoryBadge = getCategoryBadge(item);
            const branchTypeBadge = getBranchTypeBadge(item);
            
            return `<tr class="border-b border-slate-200 transition-colors duration-200 ${rowClass}" data-sku="${item.SKU}">
                <td class="p-2 text-center">${idx + 1}</td>
                <td class="p-2 font-medium text-slate-700">
                    ${item.SKU}
                    ${branchTypeBadge}
                </td>
                <td class="p-2 text-slate-600">
                    ${item.Description}
                    ${categoryBadge}
                </td>                <td class="p-2 text-center text-slate-600">${item.Price ?? 0}</td>
                <td class="p-2 text-center text-slate-600">${item.Age || 'N/A'}</td>
                <td class="p-2 text-center text-slate-600">${item.SOH}</td>
                <td class="p-2 text-center text-slate-600"><input type="number" value="${item.counted ?? 0}" class="w-full text-center p-1.5 border border-slate-300 rounded-md bg-white"/></td>                <td class="p-2 text-center font-bold diff-cell ${getDiffColorClass(diff)}">${diffText}</td>
                <td class="p-2 text-center"><input type="text" value="${item.remark ?? ''}" class="w-full text-center p-1.5 border border-slate-300 rounded-md bg-white"/></td>
            </tr>`;
        }        function renderSppToolsCard(item, idx) {
            const diff = (item.counted === null) ? null : item.counted - item.SOH;
            const diffText = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
            const diffClass = diff === null ? 'diff-null' : diff > 0 ? 'diff-positive' : diff < 0 ? 'diff-negative' : 'diff-zero';
            
            const categoryBadge = getCategoryBadge(item);
            const branchTypeBadge = getBranchTypeBadge(item);
            
            return `
                <div class="stock-card ${diffClass}" data-sku="${item.SKU}">
                    <div class="stock-card-header">
                        <span class="stock-card-number">#${idx + 1}</span>
                        <span class="stock-card-sku">${item.SKU}</span>
                        ${branchTypeBadge}
                    </div>
                    
                    <div class="stock-card-description">
                        ${item.Description}
                    </div>
                    
                    <div class="stock-card-meta">
                        <div class="stock-card-field">
                            <label>SRP</label>
                            <span class="stock-card-value">${item.Price ?? 0}</span>
                        </div>
                        <div class="stock-card-field">
                            <label>Age</label>
                            <span class="stock-card-value">${item.Age || 'N/A'}</span>
                        </div>
                        <div class="stock-card-field">
                            <label>SOH</label>
                            <span class="stock-card-value">${item.SOH}</span>
                        </div>
                        <div class="stock-card-field">
                            <label>Diff</label>
                            <span class="stock-card-value font-bold ${getDiffColorClass(diff)}">${diffText}</span>
                        </div>
                    </div>
                    
                    <div class="stock-card-controls">
                        <div class="stock-card-field">
                            <label>Counted</label>
                            <input type="number" value="${item.counted ?? 0}" 
                                   class="stock-card-input" 
                                   onchange="updateSppToolsCount('${item.SKU}', this.value)" />
                        </div>
                        <div class="stock-card-field">
                            <label>Remark</label>
                            <input type="text" value="${item.remark ?? ''}" 
                                   class="stock-card-input" 
                                   onchange="updateSppToolsRemark('${item.SKU}', this.value)" />
                        </div>                    </div>
                </div>
            `;
        }        
        function updateSppToolsSummary() {
            if (!state || !state.sppToolsMaster || !Array.isArray(state.sppToolsMaster) || state.sppToolsMaster.length === 0) {
                const summaryEl = getEl('spp-tools-summary');
                if (summaryEl) summaryEl.innerHTML = '';
                return;
            }
            
            // Ensure sppToolsCounts is initialized
            if (!state.sppToolsCounts) {
                state.sppToolsCounts = {};
            }
            
            const totalSOH = state.sppToolsMaster.reduce((sum, item) => sum + (item.SOH || 0), 0);
            const totalSOHPrice = state.sppToolsMaster.reduce((sum, item) => sum + ((item.SOH || 0) * (item.Price || 0)), 0);
            const countedSKUs = Object.values(state.sppToolsCounts).filter(c => c && c.qty !== null && c.qty !== undefined).length;
            const countedSOHValue = state.sppToolsMaster.reduce((sum, item) => {
                const counted = state.sppToolsCounts[item.SKU]?.qty;
                return sum + ((counted || 0) * (item.Price || 0));
            }, 0);
            const countedSOH = state.sppToolsMaster.reduce((sum, item) => {
                const counted = state.sppToolsCounts[item.SKU]?.qty;
                return sum + (counted || 0);
            }, 0);
            const diffItems = state.sppToolsMaster.filter(item => { 
                const countInfo = state.sppToolsCounts[item.SKU]; 
                return countInfo && countInfo.qty !== null && countInfo.qty !== undefined && countInfo.qty !== (item.SOH || 0); 
            }).length;

            const summaryEl = getEl('spp-tools-summary');
            if (summaryEl) {
                summaryEl.innerHTML = `
                    <div class="grid grid-cols-2 gap-x-4 gap-y-2">
                        <div class="flex justify-between gap-2"><span>Total SPP Tools SOH:</span><span class="font-bold">${formatNumber(totalSOH)}</span></div>
                        <div class="flex justify-between gap-2"><span>Total SPP Tools SOH Value:</span><span class="font-bold text-blue-600">${formatNumber(totalSOHPrice)}</span></div>
                        <div class="flex justify-between gap-2"><span>Counted SPP Tools SOH:</span><span class="font-bold text-green-600">${formatNumber(countedSOH)}</span></div>
                        <div class="flex justify-between gap-2"><span>Counted SPP Tools SOH Value:</span><span class="font-bold text-green-600">${formatNumber(countedSOHValue)}</span></div>
                        <div class="flex justify-between gap-2"><span>Total SPP Tools SKUs:</span><span class="font-bold">${formatNumber(state.sppToolsMaster.length)}</span></div>
                        <div class="flex justify-between gap-2"><span>Counted SKUs:</span><span class="font-bold text-green-600">${countedSKUs}</span></div>
                        <div class="flex justify-between gap-2 col-span-2"><span>Discrepancies:</span><span class="font-bold text-red-600">${diffItems}</span></div>
                    </div>
                `;
            }
        }        
        function updateSppToolsCount(sku, value, reason = 'SPP-Manual') {
            const item = state.sppToolsMaster.find(i => i.SKU === sku);
            if (!item) return;
            
            // Ensure sppToolsCounts is initialized
            if (!state.sppToolsCounts) {
                state.sppToolsCounts = {};
            }
            
            const numValue = value === '' ? null : parseInt(value, 10);
            if (numValue !== null && (isNaN(numValue) || numValue < 0)) return;
            
            item.counted = numValue;
            
            if (numValue !== null) {
                state.sppToolsCounts[sku] = { qty: numValue, reason: reason };
            } else {
                delete state.sppToolsCounts[sku];
            }
            
            // Update final report if it exists
            if (state.reconciledData && state.reconciledData.length > 0) {
                const reportItem = state.reconciledData.find(i => i.SKU === sku);
                if (reportItem) {
                    const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(sku);
                    reportItem.Recount = numValue ?? 0;
                    reportItem.FinalDiff = reportItem.Recount - reportItem.SOH;
                    reportItem.ReasonFinal = wasSohUpdated ? 'SOHupdated-SPP-Manual' : 'SPP-Manual';
                    if (typeof applyFinalReportView === 'function') applyFinalReportView();
                    if (typeof renderFinalReportCharts === 'function') renderFinalReportCharts();
                }
            }
              // Update table row display immediately
            const row = getEl('spp-tools-container').querySelector(`tr[data-sku="${sku}"]`);
            if (row) {
                const diff = item.counted === null ? null : item.counted - item.SOH;
                const diffCell = row.querySelector('.diff-cell');
                if (diffCell) {
                    diffCell.textContent = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
                    diffCell.className = `p-2 text-center font-bold diff-cell ${getDiffColorClass(diff)}`;
                }
                if (typeof updateTableRowVisuals === 'function') {
                    updateTableRowVisuals(row, diff, false);
                }
            }
              // Update mobile card display
            const card = getEl('spp-tools-cards').querySelector(`[data-sku="${sku}"]`);
            if (card) {
                const diff = item.counted === null ? null : item.counted - item.SOH;
                const diffText = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
                const diffClass = diff === null ? 'diff-null' : diff > 0 ? 'diff-positive' : diff < 0 ? 'diff-negative' : 'diff-zero';
                
                // Update card class
                card.className = `stock-card ${diffClass}`;
                
                // Update diff value
                const diffValueEl = card.querySelector('.stock-card-field:nth-of-type(4) .stock-card-value');
                if (diffValueEl) {
                    diffValueEl.textContent = diffText;
                    diffValueEl.className = `stock-card-value font-bold ${getDiffColorClass(diff)}`;
                }
                
                // Update input value
                const countInput = card.querySelector('input[type="number"]');
                if (countInput) countInput.value = item.counted ?? 0;
            }
            
            updateSppToolsSummary();
            if (typeof updateFinalReportSummary === 'function') updateFinalReportSummary();
            if (typeof setUnsavedChanges === 'function') setUnsavedChanges(true);
        }

        function updateSppToolsRemark(sku, value) {
            const item = state.sppToolsMaster.find(i => i.SKU === sku);
            if (item) {
                item.remark = value;
                setUnsavedChanges(true);
            }        
        }

        // === SPP Filter Population Functions ===
        function populateSppSparePartsFilters() {
            if (!state || !state.sppSparePartsMaster) return;
            populateGroupCodeFilter('sppSparePartsGroupCodeFilter', state.sppSparePartsMaster);
            populateSubclassFilter('sppSparePartsSubclassFilter', state.sppSparePartsMaster);
        }

        function populateSppGlueFilters() {
            if (!state || !state.sppGlueMaster) return;
            populateGroupCodeFilter('sppGlueGroupCodeFilter', state.sppGlueMaster);
            populateSubclassFilter('sppGlueSubclassFilter', state.sppGlueMaster);
        }        function populateSppToolsFilters() {
            if (!state || !state.sppToolsMaster) return;
            populateGroupCodeFilter('sppToolsGroupCodeFilter', state.sppToolsMaster);
            populateSubclassFilter('sppToolsSubclassFilter', state.sppToolsMaster);
        }

        // === Helper Functions for Filter Population ===
        function populateGroupCodeFilter(selectId, data) {
            const select = getEl(selectId);
            if (!select || !data) return;
            
            // Get unique GROUP_CODE values
            const groupCodes = [...new Set(data.map(item => item.GROUP_CODE).filter(Boolean))].sort();
            
            // Store current selection
            const currentValue = select.value;
            
            // Clear and repopulate
            select.innerHTML = '<option value="all">ทุก GROUP_CODE</option>';
            groupCodes.forEach(code => {
                const option = document.createElement('option');
                option.value = code;
                option.textContent = code;
                select.appendChild(option);
            });
            
            // Restore selection if still valid
            if (groupCodes.includes(currentValue)) {
                select.value = currentValue;
            }
        }
        
        function populateSubclassFilter(selectId, data) {
            const select = getEl(selectId);
            if (!select || !data) return;
            
            // Get unique SUBCLASS_CODE values
            const subclassCodes = [...new Set(data.map(item => item.SUBCLASS_CODE).filter(Boolean))].sort();
            
            // Store current selection
            const currentValue = select.value;
            
            // Clear and repopulate
            select.innerHTML = '<option value="all">ทุก SUBCLASS</option>';
            subclassCodes.forEach(code => {
                const option = document.createElement('option');
                option.value = code;
                option.textContent = code;
                select.appendChild(option);
            });
            
            // Restore selection if still valid
            if (subclassCodes.includes(currentValue)) {
                select.value = currentValue;
            }
        }

        // === Scanner Processing Functions ===
    </script>
    
    <body class="bg-slate-50">
    <div class="w-full">

    <!-- Loading Overlay -->
    <div id="loader-overlay" class="overlay hidden no-print">
        <div class="flex flex-col items-center gap-4">
            <div class="loader"></div>
            <p id="loader-message" class="text-slate-600 font-medium">กำลังประมวลผล...</p>
        </div>
    </div>

    <!-- Custom Modal -->
    <div id="modal-container" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex justify-center items-center z-[1000] hidden no-print">
        <div class="bg-white rounded-lg shadow-xl p-8 w-11/12 md:w-1/2 text-center transform transition-all scale-95 opacity-0" id="modal-box">
            <h3 id="modal-title" class="text-xl font-bold text-slate-800 mb-3">Notice</h3>
            <div id="modal-message" class="text-slate-600 mb-6 text-left"></div>
            <div id="modal-buttons" class="flex justify-center gap-4">
                <button id="modal-cancel-btn" class="bg-gray-300 text-gray-800 font-bold py-2.5 px-8 rounded-lg hover:bg-gray-400 transition-colors shadow-sm hidden">Cancel</button>
                <button id="modal-confirm-btn" class="bg-blue-600 text-white font-bold py-2.5 px-8 rounded-lg hover:bg-blue-700 transition-colors shadow-sm">OK</button>
            </div>
        </div>
    </div>      <div class="container w-full p-3 md:p-8" style="max-width:100vw;">
        <header class="mb-6 md:mb-8 text-center relative no-print mt-2 md:mt-4">
            <div class="absolute top-0 left-0">
                 <div id="save-status" class="text-xs md:text-sm text-slate-500 opacity-0 text-left"></div>
            </div>
            <h1 class="text-2xl md:text-4xl font-bold text-slate-900 mb-1 md:mb-2">ระบบตรวจนับสต็อกสินค้า</h1>            <div class="flex flex-col md:flex-row items-center justify-center mt-2 gap-2 md:gap-4">
                <p class="text-slate-500 text-sm md:text-base text-center">เครื่องมือช่วยตรวจนับและกระทบยอดสต็อก</p>
                <button id="newJobButton" class="bg-red-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-red-600 transition-colors shadow-sm text-sm min-h-[44px] flex-shrink-0">
                    New Job
                </button>
            </div>
        </header>        <div id="export-soh-excel-bar" class="flex justify-center md:justify-end mb-4 no-print">
            <button id="exportSohExcelBtn" class="bg-teal-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-teal-700 transition-colors shadow-sm text-xs md:text-sm w-full md:w-auto min-h-[44px]">
                <span class="hidden md:inline">Export SOH Excel (SKU, Description, Age, SRP, SOH, FAMILY)</span>
                <span class="md:hidden">Export SOH Excel</span>
            </button>
        </div><div id="info-box-container" class="hidden bg-sky-100 border border-sky-300 text-sky-800 px-4 py-3 rounded-lg relative mb-8 text-sm" role="alert">
            <div class="flex justify-between items-center flex-col md:flex-row gap-2">
                <div>
                    <strong class="font-bold">Branch:</strong>
                    <span id="info-branch-code" class="ml-2 font-mono"></span>
                    <span class="ml-1">-</span>
                    <span id="info-branch-name" class="ml-1 font-mono"></span>
                </div>
                <div>
                    <strong class="font-bold">Count Date:</strong>
                    <span id="info-count-date" class="ml-2 font-mono"></span>
                </div>
            </div>
        </div>        <div id="file-ops-container" class="bg-white p-4 rounded-2xl shadow-sm border border-slate-200 mb-6 md:mb-8 flex flex-col md:flex-row items-center justify-center gap-3 md:gap-4 no-print">
            <label for="load-progress-file" class="flex-1 w-full bg-blue-600 text-white font-bold py-3 px-4 md:py-2.5 md:px-5 rounded-lg hover:bg-blue-700 transition-colors shadow-sm text-center cursor-pointer min-h-[44px] flex items-center justify-center text-sm md:text-base">Load Progress from File</label>
            <input type="file" id="load-progress-file" class="hidden" accept=".json">
            <button id="save-progress-button" class="flex-1 w-full bg-green-600 text-white font-bold py-3 px-4 md:py-2.5 md:px-5 rounded-lg hover:bg-green-700 transition-colors shadow-sm min-h-[44px] text-sm md:text-base">Save Progress to File</button>
        </div>        <div id="upload-container" class="bg-white p-4 md:p-6 lg:p-8 rounded-2xl shadow-sm border border-slate-200 mb-6 md:mb-8 no-print">
             <h2 class="text-xl md:text-2xl font-semibold mb-2 text-slate-800">ขั้นตอนที่ 1: อัพโหลดไฟล์ SOH</h2>
            <p class="mb-4 md:mb-6 text-slate-500 text-sm md:text-base">อัพโหลดไฟล์ Stock on Hand (.xlsx หรือ .csv).</p>
            <label for="initialSohFile" class="custom-file-input w-full rounded-xl flex flex-col items-center justify-center text-center">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-10 h-10 text-slate-400 mb-2">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" />
                </svg>
                <span class="font-medium text-slate-600">คลิกเพื่อเลือกไฟล์ SOH</span>
                <span id="initialSohFileName" class="text-sm text-slate-500 mt-1">(.xlsx, .csv)</span>
            </label>
            <input type="file" id="initialSohFile" class="hidden" accept=".csv, .xlsx, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel" />
        </div>        
        <div id="workspace-container" class="hidden no-print">              <div class="mb-6 border-b border-slate-200">
                <nav class="-mb-px flex space-x-2 md:space-x-6 overflow-x-auto scrollbar-hide">
                    <button id="main-tab-workflow" class="tab-button text-sm md:text-lg font-semibold py-3 md:py-4 px-3 md:px-1 active whitespace-nowrap flex-shrink-0 min-w-max rounded-t-lg transition-all duration-200">ตรวจนับสินค้าขาย</button>
                    <button id="main-tab-demo" class="tab-button text-sm md:text-lg font-semibold py-3 md:py-4 px-3 md:px-1 text-slate-500 hover:text-slate-700 whitespace-nowrap flex-shrink-0 min-w-max rounded-t-lg transition-all duration-200">ตรวจนับสินค้า DEMO</button>
                    <button id="main-tab-spp" class="tab-button text-sm md:text-lg font-semibold py-3 md:py-4 px-3 md:px-1 text-slate-500 hover:text-slate-700 whitespace-nowrap hidden flex-shrink-0 min-w-max rounded-t-lg transition-all duration-200">SPP อะไหล่ กาว และเครื่องมือช่าง</button>
                </nav>
            </div>
        </div>
                <!-- Workflow Panel Section (moved to be first) -->
                <div id="main-panel-workflow">
                     <div class="bg-white p-6 md:p-8 rounded-2xl shadow-sm border border-slate-200">
                         <h2 class="text-2xl font-semibold mb-2 text-slate-800">ตรวจนับสินค้าขาย</h2>                         <div id="wf-step-tabs" class="mb-4 border-b border-slate-200">
                             <nav class="flex -mb-px space-x-2 md:space-x-6 overflow-x-auto scrollbar-hide">
                                 <button id="wf-tab-btn-1" class="tab-button active text-sm md:text-base font-semibold px-2 md:px-1 py-3 md:py-4 whitespace-nowrap flex-shrink-0 min-w-max">ขั้นตอนที่ 1: สร้างไฟล์</button>
                                 <button id="wf-tab-btn-2" class="tab-button text-sm md:text-base font-semibold px-2 md:px-1 py-3 md:py-4 text-slate-500 hover:text-slate-700 whitespace-nowrap flex-shrink-0 min-w-max">ขั้นตอนที่ 2: กระทบยอด</button>
                                 <button id="wf-tab-btn-3" class="tab-button text-sm md:text-base font-semibold px-2 md:px-1 py-3 md:py-4 text-slate-500 hover:text-slate-700 whitespace-nowrap flex-shrink-0 min-w-max">ขั้นตอนที่ 3: สรุปผล</button>
                             </nav>
                         </div>
                         <div id="wf-step1" class="workflow-step">
                             <h3 class="text-lg font-semibold text-slate-700">สร้าง Master File</h3>
                             <p class="text-slate-500 mb-4">ดาวน์โหลดไฟล์สำหรับสแกน (เฉพาะสินค้าขาย)</p>
                             <button id="downloadMasterForScan" class="inline-flex items-center gap-2 bg-blue-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-blue-700 transition-colors shadow-sm disabled:bg-slate-400 disabled:cursor-not-allowed" disabled>
                                 <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                     <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                                 </svg>
                                 ดาวน์โหลด Master.csv
                             </button>
                         </div>                         
                         <div id="wf-step2" class="workflow-step hidden">
                             <h3 class="text-lg font-semibold text-slate-700">กระทบยอดรอบที่ 1</h3>                             
                             <p class="text-slate-500 mb-4">อัพโหลด Logfile จากสแกนเนอร์ และ/หรือ Master.csv (ข้อมูล DEMO จะถูกรวมอัตโนมัติ)</p>
                             <!-- First Count File Uploads (both file types supported) -->
                             <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                                 <!-- Logfile Upload -->
                                 <div>
                                     <label for="firstScanLogfile" class="block mb-2 text-sm font-medium text-slate-700">Logfile (จากสแกนเนอร์)</label>
                                     <input type="file" id="firstScanLogfile" accept=".csv" multiple class="block w-full text-sm text-slate-500 file:mr-4 file:py-2.5 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-slate-50 file:text-slate-700 hover:file:bg-slate-100 border border-slate-300 rounded-lg" />
                                     <p class="text-xs text-slate-500 mt-1">รูปแบบ: คอลัมน์ 3=Part No., คอลัมน์ 5=จำนวน</p>
                                 </div>
                                 <!-- Master.csv Upload -->
                                 <div>
                                     <label for="firstMasterFile" class="block mb-2 text-sm font-medium text-slate-700">Master.csv</label>
                                     <input type="file" id="firstMasterFile" accept=".csv" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2.5 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 border border-blue-300 rounded-lg" />
                                     <p class="text-xs text-slate-500 mt-1">รูปแบบ: คอลัมน์ 1=Part No., คอลัมน์ 6=Actual Qty (เฉพาะรายการที่ qty > 0 เท่านั้น)</p>
                                 </div>
                             </div>
                             <p class="text-xs text-slate-500 mb-3">หมายเหตุ: สามารถอัพโหลดทั้ง Logfile และ Master.csv พร้อมกันได้ ระบบจะรวมข้อมูลจากทั้งสองไฟล์</p>
                             <button id="processFirstCount" class="inline-flex items-center gap-2 mt-4 bg-violet-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-violet-700 transition-colors shadow-sm disabled:bg-slate-400 disabled:cursor-not-allowed" disabled>
                                 ประมวลผลต่าง
                             </button>
                             <div id="step2-results" class="hidden mt-6">
                                 <h4 class="font-semibold text-slate-700 mb-4">สรุปผลการนับรอบที่ 1:</h4>
                                 <div id="netdiff-summary-container"></div>
                             </div>
                         </div>                         <div id="wf-step3" class="workflow-step hidden">
                             <h3 class="text-lg font-semibold text-slate-700">สรุปผลและดำเนินการต่อ</h3>
                             <p class="text-slate-500 mb-4">สรุปผลทันที หรือนับซ้ำรายการที่ไม่ได้ตรวจนับ</p>
                             <button id="finalizeFromFirstCount" class="w-full inline-flex items-center justify-center gap-2 bg-teal-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-teal-700 transition-colors shadow-sm disabled:bg-slate-400 disabled:cursor-not-allowed">
                                 <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z" clip-rule="evenodd" />
                                 </svg>
                                 แสดงรายงานสรุป (ตรวจนับรอบที่ 1)
                             </button>
                             
                             <!-- Sales Data Upload Section -->
                             <div class="mt-6 p-4 bg-orange-50 border border-orange-200 rounded-lg">
                                 <h4 class="text-md font-semibold text-orange-800 mb-2">🔄 อัพโหลดข้อมูลยอดขายระหว่างการนับ (Optional)</h4>                                 
                                 <p class="text-sm text-orange-700 mb-3">
                                     อัพโหลดไฟล์ยอดขายที่เกิดขึ้นระหว่างการนับสต็อกเพื่อติดตามและบันทึกการขายในช่วงนั้น
                                 </p>
                                 <div class="space-y-3">
                                     <div>
                                         <label for="salesDataFile" class="block mb-2 text-sm font-medium text-orange-800">Sales Data (.xlsx)</label>
                                         <input type="file" id="salesDataFile" accept=".xlsx,.xls" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2.5 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-orange-100 file:text-orange-800 hover:file:bg-orange-200 border border-orange-300 rounded-lg" />
                                         <p class="text-xs text-orange-600 mt-1">รูปแบบ: นำเข้าไฟล์ RD020.. เพื่ออัพเดทยอดขาย</p>
                                     </div>
                                     <button id="processSalesData" class="bg-orange-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-orange-700 transition-colors shadow-sm text-sm disabled:bg-slate-400 disabled:cursor-not-allowed" disabled>
                                         ประมวลผลข้อมูลยอดขาย
                                     </button>
                                     <div id="sales-processing-results" class="hidden mt-4 p-3 bg-white border border-orange-200 rounded text-sm"></div>
                                 </div>
                             </div>
                             
                             <div class="mt-6 pt-6 border-t border-slate-200">
                                 <h4 class="text-md font-semibold text-slate-600">หรือ (Optional) ทำการนับซ้ำ</h4>
                                 <p class="text-slate-500 mb-4 text-sm">
                                     หากมีการขายสินค้าระหว่างการนับ ให้อัพเดต SOH ล่าสุดก่อนสร้างไฟล์นับซ้ำ
                                 </p>

                                 <div class="bg-amber-50 border border-amber-200 p-4 rounded-lg mb-4">
                                     <label for="latestSohFile" class="block mb-2 text-sm font-medium text-amber-800">1. อัพเดต SOH ล่าสุด (ถ้ามี)</label>
                                     <input type="file" id="latestSohFile" accept=".csv, .xlsx, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2.5 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-amber-100 file:text-amber-800 hover:file:bg-amber-200 border border-amber-300 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed" disabled />
                                     <span id="latestSohFileName" class="text-xs text-slate-500 mt-1"></span>
                                 </div>
                                 
                                 <h5 class="text-sm font-medium text-slate-700 mt-4 mb-2">2. สร้างไฟล์และดำเนินการนับซ้ำ</h5>
                                 <button id="generateRecountMasterFile" class="inline-flex items-center gap-2 mb-4 bg-green-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-green-700 transition-colors shadow-sm text-sm disabled:bg-slate-400 disabled:cursor-not-allowed">
                                     สร้าง Master File สำหรับนับซ้ำ
                                 </button>
                                 
                                 <!-- Recount File Uploads (both file types supported) -->
                                 <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                                     <!-- Logfile Upload -->
                                     <div>
                                         <label for="secondScanLogfile" class="block mb-2 text-sm font-medium text-slate-700">Logfile (จากสแกนเนอร์)</label>
                                         <input type="file" id="secondScanLogfile" accept=".csv" multiple class="block w-full text-sm text-slate-500 file:mr-4 file:py-2.5 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-slate-50 file:text-slate-700 hover:file:bg-slate-100 border border-slate-300 rounded-lg" />
                                         <p class="text-xs text-slate-500 mt-1">รูปแบบ: คอลัมน์ 3=Part No., คอลัมน์ 5=จำนวน</p>
                                     </div>

                                     <!-- Master.csv Upload -->
                                     <div>
                                         <label for="secondMasterFile" class="block mb-2 text-sm font-medium text-slate-700">Master.csv</label>
                                         <input type="file" id="secondMasterFile" accept=".csv" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2.5 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 border border-blue-300 rounded-lg" />
                                         <p class="text-xs text-slate-500 mt-1">รูปแบบ: คอลัมน์ 1=Part No., คอลัมน์ 6=Actual Qty (เฉพาะรายการที่ qty > 0 เท่านั้น)</p>
                                     </div>
                                 </div>
                                 
                                 <p class="text-xs text-slate-500 mb-3">หมายเหตุ: สามารถอัพโหลดทั้ง Logfile และ Master.csv พร้อมกันได้ ระบบจะรวมข้อมูลจากทั้งสองไฟล์</p>
                                 
                                 <button id="processSecondCount" class="inline-flex items-center gap-2 bg-sky-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-sky-700 transition-colors shadow-sm disabled:bg-slate-400 disabled:cursor-not-allowed">
                                     ประมวลผลยอดนับซ้ำ
                                 </button>
                             </div>
                         </div>
                     </div>
                </div>

                <!-- DEMO Panel Section (moved to be second) -->
                <div id="main-panel-demo" class="hidden">
                     <div class="bg-white p-6 md:p-8 rounded-2xl shadow-sm border border-slate-200">
                         <div class="flex flex-col md:flex-row justify-between items-start mb-4 gap-4">
                             <h3 class="text-xl font-semibold text-slate-800">รายการตรวจนับสินค้า DEMO</h3>                             
                             <div id="demo-summary" class="flex flex-col gap-2 p-2 bg-slate-50 rounded-lg border border-slate-200 text-xs"></div>                         </div>                         <div class="filter-container my-4">
                             <div class="relative flex-grow">
                                 <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 absolute left-3 top-1/2 -translate-y-1/2 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                     <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                                 </svg>
                                 <input type="text" id="demoSearchInput" placeholder="ค้นหาด้วย SKU หรือ Description..." class="w-full pl-10 pr-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                             </div>                             <button id="openScannerBtn" class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors shadow-sm text-sm whitespace-nowrap">
                                Scan
                             </button>
                             <select id="demoFilterSelect" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                 <option value="all">แสดงทั้งหมด</option>
                                 <option value="uncounted">รายการที่ยังไม่นับ</option>
                                 <option value="discrepancy">เฉพาะรายการที่ผลต่างไม่เท่ากับ 0</option>
                                 <option value="matched">นับตรง</option>
                             </select>
                             <select id="demoGroupCodeFilter" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                 <option value="all">ทุก GROUP_CODE</option>
                             </select>
                             <select id="demoAgeFilter" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                 <option value="all">ทุกอายุสินค้า</option>
                                 <option value="new">อายุ < 300 วัน</option>
                                 <option value="old">อายุ ≥ 300 วัน</option>
                             </select>
                             <select id="demoSubclassFilter" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                 <option value="all">ทุก SUBCLASS</option>                             </select>                         </div>
                         <!-- Desktop table view -->
                         <div id="demo-count-container" class="table-container border rounded-lg mobile-hidden"></div>
                         <!-- Mobile card view -->
                         <div id="demo-count-cards" class="mobile-card-view space-y-4"></div>                         <div class="flex gap-2 mt-2">
                             <button id="exportDemoCsvButton" class="flex-1 bg-emerald-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-emerald-600 transition-colors shadow-sm text-sm">
                                 Export DEMO Table as CSV
                             </button>
                             <div class="flex-1">
                                 <input type="file" id="importDemoCsvFile" accept=".csv" class="hidden" />
                                 <button id="importDemoCsvButton" class="w-full bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors shadow-sm text-sm">
                                     Import DEMO Count CSV
                                 </button>
                             </div>
                             <button id="debugDataButton" class="bg-orange-500 text-white font-bold py-2 px-3 rounded-lg hover:bg-orange-600 transition-colors shadow-sm text-xs">
                                 Debug
                             </button>                         
                        </div>
                     </div>
                </div><!-- SPP Panel Section -->
                <div id="main-panel-spp" class="hidden">
                    <div class="space-y-8">
                        <!-- SPP Spare Parts Section -->
                        <div class="bg-white p-6 md:p-8 rounded-2xl shadow-sm border border-slate-200">
                            <div class="flex flex-col md:flex-row justify-between items-start mb-4 gap-4">
                                <h3 class="text-xl font-semibold text-slate-800">รายการตรวจนับ SPP - อะไหล่ (Spare Parts)</h3>                                
                                <div id="spp-spare-parts-summary" class="flex flex-col gap-2 p-2 bg-slate-50 rounded-lg border border-slate-200 text-xs"></div>
                            </div>                            
                            <div class="filter-container my-4">
                                <div class="relative flex-grow">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 absolute left-3 top-1/2 -translate-y-1/2 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                                    </svg>
                                    <input type="text" id="sppSparePartsSearchInput" placeholder="ค้นหา SPP Spare Parts..." class="w-full pl-10 pr-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                </div>                                <button id="openScannerBtn-spp-spare-parts" class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors shadow-sm text-sm whitespace-nowrap">
                                   Scan
                                </button>
                                <select id="sppSparePartsFilterSelect" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <option value="all">แสดงทั้งหมด</option>
                                    <option value="uncounted">รายการที่ยังไม่นับ</option>
                                    <option value="discrepancy">เฉพาะรายการที่ผลต่างไม่เท่ากับ 0</option>
                                    <option value="matched">นับตรง</option>
                                </select>
                                <select id="sppSparePartsGroupCodeFilter" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <option value="all">ทุก GROUP_CODE</option>
                                </select>
                                <select id="sppSparePartsAgeFilter" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <option value="all">ทุกอายุสินค้า</option>
                                    <option value="new">อายุ < 300 วัน</option>
                                    <option value="old">อายุ ≥ 300 วัน</option>
                                </select>
                                <select id="sppSparePartsSubclassFilter" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <option value="all">ทุก SUBCLASS</option>
                                </select>                            
                            </div>
                            <!-- Desktop table view -->
                            <div id="spp-spare-parts-container" class="table-container border rounded-lg mobile-hidden"></div>
                            <!-- Mobile card view -->
                            <div id="spp-spare-parts-cards" class="mobile-card-view space-y-4"></div>
                            <div class="flex gap-3 mt-2">
                                <button id="exportSppSparePartsCsvButton" class="flex-1 inline-flex items-center justify-center gap-2 bg-emerald-500 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-emerald-600 transition-colors shadow-sm text-sm">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                                    </svg>
                                    Export SPP Spare Parts CSV
                                </button>
                                <div class="flex-1">
                                    <input type="file" id="importSppSparePartsCsvFile" accept=".csv" class="hidden" />
                                    <button id="importSppSparePartsCsvButton" class="w-full inline-flex items-center justify-center gap-2 bg-blue-500 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-blue-600 transition-colors shadow-sm text-sm">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                            <path stroke-linecap="round" stroke-linejoin="round" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                                        </svg>
                                        Import SPP Spare Parts CSV
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- SPP Glue/Adhesive Section -->
                        <div class="bg-white p-6 md:p-8 rounded-2xl shadow-sm border border-slate-200">
                            <div class="flex flex-col md:flex-row justify-between items-start mb-4 gap-4">
                                <h3 class="text-xl font-semibold text-slate-800">รายการตรวจนับ SPP - กาว/สารยึดติด (Glue/Adhesive)</h3>                                
                                <div id="spp-glue-summary" class="flex flex-col gap-2 p-2 bg-slate-50 rounded-lg border border-slate-200 text-xs"></div>
                            </div>                            
                            <div class="filter-container my-4">
                                <div class="relative flex-grow">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 absolute left-3 top-1/2 -translate-y-1/2 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                                    </svg>
                                    <input type="text" id="sppGlueSearchInput" placeholder="ค้นหา SPP Glue/Adhesive..." class="w-full pl-10 pr-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                </div>
                                <button id="openScannerBtn-spp-glue" class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors shadow-sm text-sm whitespace-nowrap">
                                   Scan
                                </button>
                                <select id="sppGlueFilterSelect" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <option value="all">แสดงทั้งหมด</option>
                                    <option value="uncounted">รายการที่ยังไม่นับ</option>
                                    <option value="discrepancy">เฉพาะรายการที่ผลต่างไม่เท่ากับ 0</option>
                                    <option value="matched">นับตรง</option>
                                </select>
                                <select id="sppGlueGroupCodeFilter" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <option value="all">ทุก GROUP_CODE</option>
                                </select>
                                <select id="sppGlueAgeFilter" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <option value="all">ทุกอายุสินค้า</option>
                                    <option value="new">อายุ < 300 วัน</option>
                                    <option value="old">อายุ ≥ 300 วัน</option>
                                </select>
                                <select id="sppGlueSubclassFilter" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <option value="all">ทุก SUBCLASS</option>
                                </select>                            
                            </div>
                            <!-- Desktop table view -->
                            <div id="spp-glue-container" class="table-container border rounded-lg mobile-hidden"></div>
                            <!-- Mobile card view -->
                            <div id="spp-glue-cards" class="mobile-card-view space-y-4"></div>
                            <div class="flex gap-3 mt-2">
                                <button id="exportSppGlueCsvButton" class="flex-1 inline-flex items-center justify-center gap-2 bg-emerald-500 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-emerald-600 transition-colors shadow-sm text-sm">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                                    </svg>
                                    Export SPP Glue/Adhesive CSV
                                </button>
                                <div class="flex-1">
                                    <input type="file" id="importSppGlueCsvFile" accept=".csv" class="hidden" />
                                    <button id="importSppGlueCsvButton" class="w-full inline-flex items-center justify-center gap-2 bg-blue-500 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-blue-600 transition-colors shadow-sm text-sm">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                            <path stroke-linecap="round" stroke-linejoin="round" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                                        </svg>
                                        Import SPP Glue/Adhesive CSV
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- SPP Tools Section -->
                        <div class="bg-white p-6 md:p-8 rounded-2xl shadow-sm border border-slate-200">
                            <div class="flex flex-col md:flex-row justify-between items-start mb-4 gap-4">
                                <h3 class="text-xl font-semibold text-slate-800">รายการตรวจนับ SPP - เครื่องมือ (Tools)</h3>                                
                                <div id="spp-tools-summary" class="flex flex-col gap-2 p-2 bg-slate-50 rounded-lg border border-slate-200 text-xs"></div>
                            </div>                            
                            <div class="filter-container my-4">
                                <div class="relative flex-grow">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 absolute left-3 top-1/2 -translate-y-1/2 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                                    </svg>
                                    <input type="text" id="sppToolsSearchInput" placeholder="ค้นหา SPP Tools..." class="w-full pl-10 pr-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                </div>
                                <button id="openScannerBtn-spp-tools" class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors shadow-sm text-sm whitespace-nowrap">
                                   Scan
                                </button>
                                <select id="sppToolsFilterSelect" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <option value="all">แสดงทั้งหมด</option>
                                    <option value="uncounted">รายการที่ยังไม่นับ</option>
                                    <option value="discrepancy">เฉพาะรายการที่ผลต่างไม่เท่ากับ 0</option>
                                    <option value="matched">นับตรง</option>
                                </select>
                                <select id="sppToolsGroupCodeFilter" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <option value="all">ทุก GROUP_CODE</option>
                                </select>
                                <select id="sppToolsAgeFilter" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <option value="all">ทุกอายุสินค้า</option>
                                    <option value="new">อายุ < 300 วัน</option>
                                    <option value="old">อายุ ≥ 300 วัน</option>
                                </select>
                                <select id="sppToolsSubclassFilter" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                    <option value="all">ทุก SUBCLASS</option>
                                </select>                            
                            </div>
                            <!-- Desktop table view -->
                            <div id="spp-tools-container" class="table-container border rounded-lg mobile-hidden"></div>
                            <!-- Mobile card view -->
                            <div id="spp-tools-cards" class="mobile-card-view space-y-4"></div>
                            <div class="flex gap-3 mt-2">
                                <button id="exportSppToolsCsvButton" class="flex-1 inline-flex items-center justify-center gap-2 bg-emerald-500 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-emerald-600 transition-colors shadow-sm text-sm">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                                    </svg>
                                    Export SPP Tools CSV
                                </button>
                                <div class="flex-1">
                                    <input type="file" id="importSppToolsCsvFile" accept=".csv" class="hidden" />
                                    <button id="importSppToolsCsvButton" class="w-full inline-flex items-center justify-center gap-2 bg-blue-500 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-blue-600 transition-colors shadow-sm text-sm">
                                        <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                            <path stroke-linecap="round" stroke-linejoin="round" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12" />
                                        </svg>
                                        Import SPP Tools CSV
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Floating Scanner Component -->
                <div id="floating-scanner" class="floating-scanner">                    
                    <div class="floating-scanner-header" id="scanner-header">
                        <h3 class="font-semibold">🔍 Serial/SKU Scanner</h3>                        
                        <div class="flex items-center gap-2">
                            <button id="close-floating-scanner" class="bg-white/20 hover:bg-white/30 px-2 py-1 rounded">✕</button>
                        </div>
                    </div><div class="floating-scanner-content">                        
                        <div class="flex gap-1 mb-3">
                            <button id="floating-barcode-tab" class="scanner-tab-button active flex-1 text-sm">📱 Barcode</button>
                            <button id="floating-text-tab" class="scanner-tab-button flex-1 text-sm">🔍 Serial/SKU OCR</button>
                        </div>
                        
                        <!-- Barcode Scanner View -->
                        <div id="floating-barcode-view" class="scanner-viewport">
                            <div id="floating-qr-reader"></div>
                            <div class="barcode-line"></div>
                        </div>
                          <!-- Text Scanner View -->
                        <div id="floating-text-view" class="hidden scanner-viewport">
                            <video id="floating-text-video" playsinline></video>
                            <div class="scan-box"></div>
                        </div>
                        <!-- Scanner Results -->
                        <div id="floating-scanner-results" class="mt-3 p-2 bg-slate-50 border border-slate-200 rounded text-center min-h-[50px] text-sm"></div>
                        <!-- OCR Preview Canvas -->
                        <canvas id="floating-ocr-preview" class="mt-2 border border-blue-300 rounded w-full max-w-xs mx-auto hidden" style="background:#fff;"></canvas>                        
                        <!-- OCR Controls - Enhanced Serial/SKU Optimized (Only visible in Text/OCR mode) -->
                        <div id="floating-ocr-controls" class="mt-3 p-2 bg-gray-50 border border-gray-200 rounded hidden">
                            <h4 class="text-xs font-semibold mb-2 text-gray-700">🔍 Serial/SKU OCR Settings</h4>
                            <div class="space-y-1">
                                <div class="flex items-center justify-between">
                                    <label class="text-xs text-gray-600">Confidence:</label>
                                    <div class="flex items-center gap-1">
                                        <input type="range" id="floating-confidence-slider" min="30" max="90" value="60" class="w-14">
                                        <span id="floating-confidence-value" class="text-xs text-gray-600 w-8">60%</span>
                                    </div>
                                </div>
                                <div class="flex items-center justify-between">
                                    <label class="text-xs text-gray-600">Serial/SKU Mode:</label>
                                    <select id="floating-preprocessing-select" class="text-xs p-1 border border-gray-300 rounded">
                                        <option value="basic">Basic Processing</option>
                                        <option value="enhanced" selected>Enhanced Serial/SKU</option>
                                        <option value="aggressive">Aggressive OCR</option>
                                    </select>
                                </div>
                                <div class="text-xs text-blue-600 mt-1 px-1">
                                    <span class="inline-flex items-center gap-1">
                                        ⚡ Pyodide Enhanced: Pattern Recognition & Quality Analysis
                                    </span>
                                </div>
                            </div>                        
                        </div>
                    </div>                
                </div>
            </div>
        </div>
      </div>
    </div>        
</div>
        
        <!-- Final Report Container (at root level, hidden initially) -->
        <div id="final-report-container" class="mt-8 hidden">
            <div class="bg-white p-6 md:p-8 rounded-2xl shadow-sm border border-slate-200">
                <div class="space-y-8">
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <h3 class="text-xl font-semibold text-slate-800">Dashboard สรุปผลการตรวจสอบ</h3>
                            <div class="flex items-center gap-2 no-print">
                                <button id="refreshChartsButton" class="bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 transition-colors shadow-sm text-sm flex items-center gap-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8m0 0V3m0 5h-5" />
                                    </svg>
                                    Refresh Chart
                                </button>
                            </div>                        
                        </div>                          <div class="p-4 bg-slate-50 rounded-lg border border-slate-200 flex flex-col">
                            <h4 class="text-sm font-semibold text-center mb-2 text-slate-600 flex-shrink-0">ผลต่างแยกตามหมวดหมู่ (จำนวน)</h4>
                            <div class="relative h-96 md:h-[500px]">
                                <canvas id="categoryChart"></canvas>
                            </div>
                        </div>
                        <div id="final-summary" class="flex flex-col gap-2 p-4 bg-slate-100 rounded-lg border border-slate-200 text-sm"></div>
                    </div>
                    <div class="space-y-4">                        
                        <h3 class="text-xl font-semibold text-slate-800">รายการสรุปผลทั้งหมด</h3>                        
                        <div class="filter-container no-print">
                            <div class="relative flex-grow">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 absolute left-3 top-1/2 -translate-y-1/2 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>
                                <input type="text" id="finalSearchInput" placeholder="ค้นหารายงาน..." class="w-full pl-10 pr-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                            </div>
                            <button id="final-openScannerBtn" class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors shadow-sm text-sm whitespace-nowrap">
                                Scan
                            </button>
                            <select id="finalFilterSelect" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                <option value="all">แสดงทั้งหมด</option>
                                <option value="discrepancy">เฉพาะรายการที่ผลต่างไม่เท่ากับ 0</option>
                                <option value="demo">เฉพาะสินค้า DEMO</option>
                                <option value="normal">เฉพาะสินค้าปกติ</option>
                            </select>
                            <select id="finalGroupCodeFilter" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                <option value="all">ทุก GROUP_CODE</option>
                            </select>
                            <select id="finalAgeFilter" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                <option value="all">ทุกอายุสินค้า</option>
                                <option value="new">อายุ < 300 วัน</option>
                                <option value="old">อายุ ≥ 300 วัน</option>
                            </select>
                            <select id="finalSubclassFilter" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                <option value="all">ทุก SUBCLASS</option>                            </select>
                        </div>
                        <!-- Desktop table view -->
                        <div id="final-report-table-container" class="table-container border border-slate-200 rounded-lg mobile-hidden"></div>
                        <!-- Mobile card view -->
                        <div id="final-report-cards" class="mobile-card-view space-y-4"></div>                        <div class="mt-4 flex flex-col sm:flex-row gap-4 no-print">
                            <button id="export-pdf-btn" class="flex-1 inline-flex items-center justify-center gap-2 bg-red-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-red-700 transition-colors shadow-sm">
                                <!-- PDF icon -->
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
                                </svg>
                                Export เป็น PDF
                            </button>
                            <button id="exportCsvButton" class="flex-1 inline-flex items-center justify-center gap-2 bg-emerald-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-emerald-700 transition-colors shadow-sm">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>
                                Export CSV
                            </button>
                            <button id="exportJsonButton" class="flex-1 inline-flex items-center justify-center gap-2 bg-indigo-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-indigo-700 transition-colors shadow-sm">
                                <!-- Curly braces icon for JSON -->
                                <span class="text-lg font-bold">{ }</span>
                                Export JSON
                            </button>
                        </div>
                    </div>
                </div>
            </div>        
        </div>

        <!-- Legal Declaration and Signature Section (print only) -->
        <div class="print-legal-section">
            <div class="legal-certification">
                ข้าพเจ้าขอรับรองว่าข้อมูลในรายงานนี้ถูกต้องตามที่ตรวจสอบและเป็นความจริงทุกประการ
                <div class="english-text">
                    (I hereby certify that the information in this report is accurate and true to the best of my knowledge.)
                </div>
            </div>
            
            <div class="signature-section">
                <div class="signature-container">
                    <div class="signature-box">
                        <div class="signature-line"></div>
                        <div class="signature-name">ลงชื่อ .................................................</div>
                        <div class="signature-title">(ผู้ตรวจสอบ / Auditor)</div>
                        <div class="signature-date">
                            วันที่: <span class="signature-date-line"></span> / <span class="signature-date-line"></span> / <span class="signature-date-line"></span>
                        </div>
                    </div>
                    <div class="signature-box">
                        <div class="signature-line"></div>
                        <div class="signature-name">ลงชื่อ .................................................</div>
                        <div class="signature-title">(ผู้รับการตรวจสอบ / Auditee)</div>
                        <div class="signature-date">
                            วันที่: <span class="signature-date-line"></span> / <span class="signature-date-line"></span> / <span class="signature-date-line"></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>        
    // Global variables that need to be accessible throughout the application
        const getEl = (id) => document.getElementById(id);
        let hasUnsavedChanges = false;
        let state = null; // Will be initialized when DOM is ready

        // Global utility functions
        function getRowVisuals(diff, isDemo = false) {
            // Remove all row highlighting for performance - return white background for all rows
            return { rowClass: 'bg-white', statusDotColor: 'bg-gray-400' };
        }
        function getCategoryBadge(item) {
            if (!item.category || item.category === 'REGULAR') return '';
            
            const categoryColors = {
                'DEMO': 'bg-purple-100 text-purple-800',
                'SPP_GLUE_ADHESIVE': 'bg-orange-100 text-orange-800',
                'SPP_TOOLS': 'bg-green-100 text-green-800',
                'SPP_SLED_FIXTURE': 'bg-green-100 text-green-800', // Legacy support, now treated as Tools
                'SPP_OTHER': 'bg-gray-100 text-gray-800'
            };
            
            const categoryLabels = {
                'DEMO': 'DEMO',
                'SPP_GLUE_ADHESIVE': 'Glue/Adhesive',
                'SPP_TOOLS': 'Tools',
                'SPP_SLED_FIXTURE': 'Tools', // Legacy support, now labeled as Tools
                'SPP_OTHER': 'SPP Other'
            };
            
            const colorClass = categoryColors[item.category] || 'bg-gray-100 text-gray-800';
            const label = categoryLabels[item.category] || item.category;
            
            return `<div class="inline-block px-2 py-1 text-xs rounded-full ${colorClass} mt-1">${label}</div>`;
        }
        function getBranchTypeBadge(item) {
            if (!item.branchType || item.branchType === 'Standard') return '';
            
            const typeColors = {
                'iCenter': 'bg-indigo-100 text-indigo-800',
                'iStudio': 'bg-violet-100 text-violet-800'
            };
            
            const colorClass = typeColors[item.branchType] || 'bg-gray-100 text-gray-800';
            
            return `<div class="inline-block px-2 py-1 text-xs rounded-full ${colorClass} ml-2">${item.branchType}</div>`;
        }        
        function getDiffColorClass(diff) {
            if (diff < 0) return 'text-red-600 font-bold';
            if (diff > 0) return 'text-yellow-500 font-bold';
            return 'text-green-600 font-bold';
        }

        function formatNumber(num) {
            return (num ?? 0).toLocaleString('en-US');
        }
        
        let cvReady = false;
        function onOpenCvReady() {
            cvReady = true;
            const textScannerTab = document.getElementById('text-scanner-tab');
            const cameraViewBox = document.getElementById('camera-view-box');
            const textScannerView = document.getElementById('text-scanner-view');
            const textScannerVideo = document.getElementById('text-scanner-video');
            if (
                textScannerTab && textScannerTab.classList.contains('active') &&
                cameraViewBox && !cameraViewBox.classList.contains('hidden')
            ) {
                // If video is not playing, start it
                if (textScannerView && !textScannerView.classList.contains('hidden')) {
                    if (textScannerVideo && textScannerVideo.srcObject == null) {
                        if (typeof startTextScanner === 'function') startTextScanner();
                    }
                }
                if (typeof stopOcrStreaming === 'function') stopOcrStreaming();
                if (typeof startOcrStreaming === 'function') startOcrStreaming();
                const scannerResultsEl = document.getElementById('scanner-results');
                if (scannerResultsEl) {
                    scannerResultsEl.innerHTML = `<p class="text-green-600">OpenCV is ready. Scanner refreshed.</p>`;
                }
            }        }          document.addEventListener('DOMContentLoaded', () => {
            // Initialize global state
            state = getInitialState();
            
            let finalSummaryData = {};
            
            // === Floating Scanner Variables ===
            let floatingScanner = null;
            let floatingStream = null;
            let floatingOcrStreaming = false;
            let floatingOcrStreamInterval = null;
            let currentScannerMode = 'barcode';
            let currentScannerContext = 'demo'; // 'demo' or 'final'
            let pyodide = null;
            let pyodideReady = false;
            let lastScannedText = null; // Store latest scanned text
            let scanHistory = []; // Store scan history
            
            // === Pyodide OCR Variables ===
            let pyodideWorker = null;
            let floatingOcrSettings = {
                confidence: 60,
                preprocessing: 'enhanced',
                speed: 800
            };

            // === Initialize Pyodide for Enhanced OCR ===
            async function initializePyodide() {                
                try {
                    if (pyodideReady) return;
                    pyodide = await loadPyodide();
                    // Install required packages
                    await pyodide.loadPackage(['opencv-python', 'numpy', 'pillow']);
                    // Load enhanced OCR processing script with optimized Serial/SKU processing
                    await pyodide.runPython(`
import cv2
import numpy as np
from PIL import Image, ImageEnhance, ImageFilter
import base64
import io
import re

def process_image_enhanced(image_data_base64, preprocessing_mode='enhanced'):
    """
    Enhanced image processing using OpenCV and Python
    Optimized for Apple product serial number and SKU recognition
    with advanced Serial/SKU data processing capabilities
    """
    try:
        # Decode base64 image
        image_data = base64.b64decode(image_data_base64.split(',')[1])
        image = Image.open(io.BytesIO(image_data))
        
        # Convert to OpenCV format
        img_array = np.array(image)
        if len(img_array.shape) == 3:
            img = cv2.cvtColor(img_array, cv2.COLOR_RGB2BGR)
        else:
            img = img_array
            
        # Convert to grayscale
        if len(img.shape) == 3:
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        else:
            gray = img

        # === OPTIMIZED SERIAL/SKU PREPROCESSING ===
        # Apply preprocessing based on mode with Serial/SKU optimization
        if preprocessing_mode == 'basic':
            # Basic sharpening optimized for Serial/SKU text
            kernel = np.array([[-1,-1,-1,-1,-1], 
                              [-1,2,2,2,-1], 
                              [-1,2,8,2,-1], 
                              [-1,2,2,2,-1], 
                              [-1,-1,-1,-1,-1]]) / 8
            processed = cv2.filter2D(gray, -1, kernel)
            
            # Enhance contrast for Serial/SKU readability
            processed = cv2.convertScaleAbs(processed, alpha=1.2, beta=10)
            _, processed = cv2.threshold(processed, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
            
        elif preprocessing_mode == 'enhanced':
            # Enhanced Apple Serial/SKU optimized processing
            # Advanced CLAHE specifically tuned for Serial/SKU text
            clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(6,6))
            processed = clahe.apply(gray)
            
            # Serial/SKU specific bilateral filtering
            processed = cv2.bilateralFilter(processed, 11, 80, 80)
            
            # Enhance Serial/SKU text definition
            enhancer = ImageEnhance.Sharpness(Image.fromarray(processed))
            processed = np.array(enhancer.enhance(2.0))
            
            # Unsharp masking optimized for Serial/SKU characters
            blurred = cv2.GaussianBlur(processed, (3, 3), 0)
            processed = cv2.addWeighted(processed, 1.8, blurred, -0.8, 0)
            
            # Serial/SKU adaptive thresholding
            processed = cv2.adaptiveThreshold(processed, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 13, 4)
            
        elif preprocessing_mode == 'aggressive':
            # Aggressive preprocessing for difficult Serial/SKU conditions
            # Advanced CLAHE for challenging lighting
            clahe = cv2.createCLAHE(clipLimit=4.0, tileGridSize=(4,4))
            processed = clahe.apply(gray)
            
            # Multiple denoising passes for Serial/SKU clarity
            processed = cv2.fastNlMeansDenoising(processed, None, 12, 7, 21)
            processed = cv2.bilateralFilter(processed, 13, 90, 90)
            
            # Multi-scale sharpening for Serial/SKU text
            sharp1 = cv2.GaussianBlur(processed, (2, 2), 0)
            sharp2 = cv2.GaussianBlur(processed, (4, 4), 0)
            processed = cv2.addWeighted(processed, 2.2, sharp1, -0.6, 0)
            processed = cv2.addWeighted(processed, 1.2, sharp2, -0.2, 0)
            
            # Serial/SKU specific morphological operations
            kernel1 = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 1))
            kernel2 = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 2))
            processed = cv2.morphologyEx(processed, cv2.MORPH_CLOSE, kernel1)
            processed = cv2.morphologyEx(processed, cv2.MORPH_OPEN, kernel2)
            
            # Final Serial/SKU optimized thresholding
            processed = cv2.adaptiveThreshold(processed, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 15, 2)
        
        # Convert back to PIL Image
        processed_image = Image.fromarray(processed)
        
        # === SERIAL/SKU SPECIFIC ENHANCEMENTS ===
        # Apply Serial/SKU text enhancement filters
        processed_image = processed_image.filter(ImageFilter.UnsharpMask(radius=1, percent=200, threshold=0))
        
        # Convert to base64 for return
        buffer = io.BytesIO()
        processed_image.save(buffer, format='PNG')
        processed_base64 = base64.b64encode(buffer.getvalue()).decode()
        
        return f"data:image/png;base64,{processed_base64}"
        
    except Exception as e:
        return f"Error: {str(e)}"

def analyze_image_quality(image_data_base64):
    """
    Analyze image quality for better Serial/SKU OCR feedback
    Enhanced with Serial/SKU specific quality metrics
    """
    try:
        # Decode base64 image
        image_data = base64.b64decode(image_data_base64.split(',')[1])
        image = Image.open(io.BytesIO(image_data))
        img_array = np.array(image)
        
        if len(img_array.shape) == 3:
            gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)
        else:
            gray = img_array
            
        # Calculate enhanced metrics for Serial/SKU processing
        brightness = np.mean(gray)
        contrast = np.std(gray)
        sharpness = cv2.Laplacian(gray, cv2.CV_64F).var()
        
        # Serial/SKU specific quality metrics
        edges = cv2.Canny(gray, 50, 150)
        edge_density = np.sum(edges > 0) / edges.size
        
        # Text region analysis for Serial/SKU
        text_regions = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)
        text_density = np.sum(text_regions == 0) / text_regions.size
        
        # Quality assessment optimized for Serial/SKU
        quality = {
            'brightness': float(brightness),
            'contrast': float(contrast),
            'sharpness': float(sharpness),
            'edge_density': float(edge_density),
            'text_density': float(text_density),
            'overall': 'good'
        }
        
        # Enhanced quality thresholds for Serial/SKU processing
        if brightness < 45:
            quality['overall'] = 'too_dark'
        elif brightness > 210:
            quality['overall'] = 'too_bright'
        elif contrast < 25:
            quality['overall'] = 'low_contrast'
        elif sharpness < 80:
            quality['overall'] = 'blurry'
        elif edge_density < 0.02:
            quality['overall'] = 'insufficient_detail'
        elif text_density < 0.05:
            quality['overall'] = 'no_text_detected'
            
        return quality
        
    except Exception as e:
        return {'error': str(e)}

def extract_serial_sku_patterns(text):
    """
    Advanced Serial/SKU pattern extraction and validation
    Optimized for Apple products and various SKU formats
    """
    try:
        # Clean the input text
        cleaned_text = re.sub(r'[^A-Z0-9\-_]', '', text.upper())
        
        # Enhanced Serial/SKU patterns
        patterns = {
            'apple_serial': r'[A-Z0-9]{10,12}',  # Apple serial format
            'sku_standard': r'S[A-Z0-9]{8,12}',  # Standard SKU with S prefix
            'sku_numeric': r'\d{8,12}',          # Numeric SKU
            'mixed_pattern': r'[A-Z]{2,4}\d{6,10}',  # Mixed letter-number
            'barcode_pattern': r'\d{12,14}',     # Barcode patterns
        }
        
        extracted = {}
        for pattern_name, pattern in patterns.items():
            matches = re.findall(pattern, cleaned_text)
            if matches:
                extracted[pattern_name] = matches
        
        # Score patterns based on likelihood for Serial/SKU
        scored_results = []
        for pattern_name, matches in extracted.items():
            for match in matches:
                score = calculate_serial_sku_score(match, pattern_name)
                scored_results.append({
                    'text': match,
                    'pattern': pattern_name,
                    'score': score,
                    'length': len(match)
                })
        
        # Sort by score descending
        scored_results.sort(key=lambda x: x['score'], reverse=True)
        
        return {
            'best_matches': scored_results[:3],  # Top 3 matches
            'all_patterns': extracted,
            'original_text': text,
            'cleaned_text': cleaned_text
        }
        
    except Exception as e:
        return {'error': str(e)}

def calculate_serial_sku_score(text, pattern_type):
    """
    Calculate confidence score for Serial/SKU matches
    """
    score = 0
    
    # Base score by pattern type
    pattern_scores = {
        'apple_serial': 90,
        'sku_standard': 85,
        'mixed_pattern': 70,
        'sku_numeric': 60,
        'barcode_pattern': 50
    }
    score += pattern_scores.get(pattern_type, 30)
    
    # Length scoring (optimal lengths for Serial/SKU)
    length = len(text)
    if 8 <= length <= 12:
        score += 20
    elif 6 <= length <= 14:
        score += 10
    else:
        score -= 10
    
    # Character composition scoring
    letters = sum(1 for c in text if c.isalpha())
    digits = sum(1 for c in text if c.isdigit())
    
    # Prefer mixed alphanumeric for serials
    if letters > 0 and digits > 0:
        score += 15
    
    # Apple serial specific patterns
    if pattern_type == 'apple_serial':
        if letters >= 3 and digits >= 6:
            score += 25
        if not any(char in text for char in ['O', 'I']):  # Apple avoids O, I
            score += 10
    
    # SKU specific patterns
    if 'sku' in pattern_type:
        if text.startswith('S') and len(text) >= 9:
            score += 20
        if digits >= length * 0.6:  # SKUs often numeric-heavy
            score += 10
    
    return min(score, 100)  # Cap at 100
                    `);
                      pyodideReady = true;
                      } catch (error) {
                    // Silent error handling for production
                }
            }              
            // === Floating Scanner Functions ===
            function initializeFloatingScanner() {
                floatingScanner = document.getElementById('floating-scanner');
                const header = document.getElementById('scanner-header');
                
                if (!floatingScanner || !header) {
                    console.warn('Floating scanner elements not found');
                    return;
                }
                
                // Make header draggable with enhanced responsiveness
                let isDragging = false;
                let currentX = 0;
                let currentY = 0;
                let initialX = 0;
                let initialY = 0;
                let xOffset = 0;
                let yOffset = 0;
                
                function dragStart(e) {
                    // Only drag if clicking on the header itself, not buttons
                    if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                        return;
                    }
                    
                    // Prevent default to avoid text selection
                    e.preventDefault();
                    
                    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                    
                    initialX = clientX - xOffset;
                    initialY = clientY - yOffset;
                    isDragging = true;
                    
                    // Enhanced visual feedback
                    floatingScanner.style.cursor = 'grabbing';
                    floatingScanner.style.userSelect = 'none';
                    floatingScanner.style.transition = 'none'; // Disable transition during drag
                    header.style.transform = 'scale(0.98)'; // Subtle scale effect
                    
                    // Change header cursor
                    header.style.cursor = 'grabbing';
                }
                    function drag(e) {
                    if (isDragging) {
                        e.preventDefault();
                        
                        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                        
                        const newX = clientX - initialX;
                        const newY = clientY - initialY;
                        
                        // Only update if position actually changed (performance optimization)
                        if (Math.abs(newX - currentX) > 1 || Math.abs(newY - currentY) > 1) {
                            currentX = newX;
                            currentY = newY;
                            
                            xOffset = currentX;
                            yOffset = currentY;                            // More lenient viewport bounds - allow complete freedom of movement
                            const margin = 20; // Reduced margin for more compact movement
                            const windowWidth = floatingScanner.offsetWidth || 320; // fallback width (updated)
                            const windowHeight = floatingScanner.offsetHeight || 400; // fallback height (updated)
                            
                            const minX = -(windowWidth - 50); // Allow window to go almost completely off-screen to the left, keep 50px visible for dragging back
                            const maxX = window.innerWidth - 50; // Allow mostly off-screen to the right, keep 50px visible
                            const minY = -windowHeight + margin + 40; // Keep header visible (40px for smaller header)
                            const maxY = window.innerHeight - margin; // Allow mostly off-screen at bottom
                            
                            currentX = Math.max(minX, Math.min(currentX, maxX));
                            currentY = Math.max(minY, Math.min(currentY, maxY));
                            
                            // Smooth transform with GPU acceleration
                            requestAnimationFrame(() => {
                                floatingScanner.style.transform = `translate3d(${currentX}px, ${currentY}px, 0)`;
                            });
                        }
                    }
                }
                
                function dragEnd() {
                    if (isDragging) {
                        initialX = currentX;
                        initialY = currentY;
                        isDragging = false;
                        
                        // Restore visual feedback
                        floatingScanner.style.cursor = '';
                        floatingScanner.style.userSelect = '';
                        floatingScanner.style.transition = 'transform 0.3s ease-in-out, visibility 0.3s ease-in-out, opacity 0.3s ease-in-out';
                        header.style.transform = 'scale(1)';
                        header.style.cursor = 'grab';
                    }
                }
                
                // Enhanced event listeners for both mouse and touch
                header.addEventListener('mousedown', dragStart, { passive: false });
                header.addEventListener('touchstart', dragStart, { passive: false });
                
                document.addEventListener('mousemove', drag, { passive: false });
                document.addEventListener('touchmove', drag, { passive: false });
                
                document.addEventListener('mouseup', dragEnd);
                document.addEventListener('touchend', dragEnd);
                  
                // Initialize event listeners
                setupFloatingTabSwitching();
                setupFloatingControls();
            }

            function setupFloatingTabSwitching() {
                const barcodeTab = document.getElementById('floating-barcode-tab');
                const textTab = document.getElementById('floating-text-tab');
                const barcodeView = document.getElementById('floating-barcode-view');
                const textView = document.getElementById('floating-text-view');
                
                barcodeTab.addEventListener('click', () => switchFloatingTab('barcode'));
                textTab.addEventListener('click', () => switchFloatingTab('text'));
                  function switchFloatingTab(mode) {
                    currentScannerMode = mode;
                    const ocrControls = document.getElementById('floating-ocr-controls');
                    const ocrPreview = document.getElementById('floating-ocr-preview');
                    
                    if (mode === 'barcode') {
                        barcodeTab.classList.add('active');
                        textTab.classList.remove('active');
                        barcodeView.classList.remove('hidden');
                        textView.classList.add('hidden');
                        ocrControls.classList.add('hidden');
                        ocrPreview.classList.add('hidden');
                        
                        stopFloatingTextScanner();
                        stopFloatingOcrStreaming();
                        startFloatingBarcodeScanner();
                    } else {
                        textTab.classList.add('active');
                        barcodeTab.classList.remove('active');
                        textView.classList.remove('hidden');
                        barcodeView.classList.add('hidden');
                        ocrControls.classList.remove('hidden');
                        
                        stopFloatingBarcodeScanner();
                        startFloatingTextScanner();
                        setTimeout(startFloatingOcrStreaming, 800);
                    }
                }
            }

            function setupFloatingControls() {
                // Confidence slider
                const confidenceSlider = document.getElementById('floating-confidence-slider');
                const confidenceValue = document.getElementById('floating-confidence-value');
                
                confidenceSlider.addEventListener('input', (e) => {
                    floatingOcrSettings.confidence = parseInt(e.target.value);
                    confidenceValue.textContent = e.target.value + '%';
                });
                  // Preprocessing select
                const preprocessingSelect = document.getElementById('floating-preprocessing-select');
                preprocessingSelect.addEventListener('change', (e) => {
                    floatingOcrSettings.preprocessing = e.target.value;
                });
                  // Close button
                const closeBtn = document.getElementById('close-floating-scanner');
                closeBtn.addEventListener('click', closeFloatingScanner);
            }            
            async function startFloatingTextScanner() {
                try {
                    if (floatingStream) {
                        floatingStream.getTracks().forEach(track => track.stop());
                    }
                    
                    const constraints = {
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 1920, max: 1920 },
                            height: { ideal: 1080, max: 1080 },
                            frameRate: { ideal: 30, max: 30 }
                        }
                    };
                    
                    floatingStream = await navigator.mediaDevices.getUserMedia(constraints);
                    const video = document.getElementById('floating-text-video');                    
                    video.srcObject = floatingStream;
                    video.play();
                } catch (err) {
                    updateFloatingResults(`<p class="text-red-500">Camera error: ${err.message}</p>`);
                }
            }

            function stopFloatingTextScanner() {
                const video = document.getElementById('floating-text-video');
                if (video && video.srcObject) {
                    const tracks = video.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    video.srcObject = null;
                }
                floatingStream = null;
            }            
            function startFloatingBarcodeScanner() {
                // Use the correct target element for Quagga
                const barcodeTarget = document.getElementById('floating-qr-reader');
                
                if (!barcodeTarget) {
                    updateFloatingResults(`<p class="text-red-500">Barcode scanner target not found</p>`);
                    return;
                }
                
                Quagga.init({
                    inputStream: {
                        name: "Live",
                        type: "LiveStream",
                        target: barcodeTarget,
                        constraints: { 
                            facingMode: "environment",
                            width: { ideal: 640, max: 640 },
                            height: { ideal: 480, max: 480 }
                        }
                    },
                    decoder: {
                        readers: [
                            "code_128_reader", "ean_reader", "ean_8_reader",
                            "code_39_reader", "upc_reader", "upc_e_reader"
                        ]
                    },
                    locate: true,
                    locator: {
                        patchSize: "medium",
                        halfSample: true
                    },
                    numOfWorkers: 2,
                    frequency: 10
                }, (err) => {
                    if (err) {
                        updateFloatingResults(`<p class="text-red-500">Barcode scanner error: ${err.message}</p>`);
                        return;
                    }
                    Quagga.start();
                    updateFloatingResults(`<p class="text-green-500">Barcode scanner ready</p>`);
                });
                
                Quagga.onDetected(onFloatingBarcodeDetected);
            }            
            function stopFloatingBarcodeScanner() {
                if (typeof Quagga !== 'undefined' && Quagga.running) {
                    Quagga.offDetected(onFloatingBarcodeDetected);
                    Quagga.stop();
                }
                
                // Clean up video element properly
                const barcodeTarget = document.getElementById('floating-qr-reader');
                if (barcodeTarget) {
                    const quaggaVideo = barcodeTarget.querySelector('video');
                    if (quaggaVideo && quaggaVideo.srcObject) {
                        quaggaVideo.srcObject.getTracks().forEach(track => track.stop());
                        quaggaVideo.srcObject = null;
                    }
                    // Clear the container
                    barcodeTarget.innerHTML = '';
                }
            }

            function startFloatingOcrStreaming() {
                if (floatingOcrStreaming) return;
                floatingOcrStreaming = true;
                updateFloatingResults('<p class="text-blue-500">กำลังสแกนแบบเรียลไทม์...</p>');
                floatingOcrStreamInterval = setInterval(processFloatingOcrFrame, floatingOcrSettings.speed);
            }

            function stopFloatingOcrStreaming() {
                floatingOcrStreaming = false;
                if (floatingOcrStreamInterval) {
                    clearInterval(floatingOcrStreamInterval);
                    floatingOcrStreamInterval = null;
                }
            }

            async function processFloatingOcrFrame() {
                if (!floatingOcrStreaming || !floatingStream || !cvReady) return;
                  const video = document.getElementById('floating-text-video');
                if (video.readyState < 2) return;
                
                const startTime = performance.now();
                
                const canvas = document.createElement('canvas');
                
                // Enhanced crop settings for Apple products
                const cropY = video.videoHeight * 0.45;
                const cropHeight = video.videoHeight * 0.18;
                const cropX = video.videoWidth * 0.05;
                const cropWidth = video.videoWidth * 0.90;
                
                canvas.width = cropWidth;
                canvas.height = cropHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

                // Show preview
                const preview = document.getElementById('floating-ocr-preview');
                if (preview) {
                    preview.classList.remove('hidden');
                    preview.width = canvas.width;
                    preview.height = canvas.height;
                    preview.getContext('2d').drawImage(canvas, 0, 0);
                }

                try {
                    let processedImageData;
                      if (pyodideReady) {
                        // Use Pyodide for enhanced Serial/SKU processing
                        const imageDataURL = canvas.toDataURL('image/png');
                        
                        // Analyze image quality first
                        const quality = pyodide.runPython(`analyze_image_quality("""${imageDataURL}""")`);
                        const qualityObj = quality.toJs();
                        
                        if (qualityObj.error) {
                            throw new Error(qualityObj.error);
                        }
                          // Provide enhanced quality feedback for Serial/SKU
                        if (qualityObj.overall === 'too_dark') {
                            updateFloatingResults(`<p class="text-yellow-600">ภาพมืดเกินไป กรุณาเพิ่มแสงสว่าง (${qualityObj.brightness.toFixed(0)})</p>`);
                            return;
                        } else if (qualityObj.overall === 'too_bright') {
                            updateFloatingResults(`<p class="text-yellow-600">ภาพสว่างเกินไป กรุณาลดแสงสว่าง (${qualityObj.brightness.toFixed(0)})</p>`);
                            return;
                        } else if (qualityObj.overall === 'low_contrast') {
                            updateFloatingResults(`<p class="text-yellow-600">ภาพไม่ชัดเจน กรุณาปรับโฟกัส (ความชัด: ${qualityObj.contrast.toFixed(0)})</p>`);
                            return;
                        } else if (qualityObj.overall === 'blurry') {
                            updateFloatingResults(`<p class="text-yellow-600">ภาพเบลอ กรุณาปรับโฟกัส (ความคม: ${qualityObj.sharpness.toFixed(0)})</p>`);
                            return;
                        } else if (qualityObj.overall === 'insufficient_detail') {
                            updateFloatingResults(`<p class="text-yellow-600">รายละเอียดไม่เพียงพอ กรุณาเข้าใกล้ข้อความ</p>`);
                            return;
                        } else if (qualityObj.overall === 'no_text_detected') {
                            updateFloatingResults(`<p class="text-yellow-600">ไม่พบข้อความ กรุณาจัดตำแหน่งกล้อง</p>`);
                            return;
                        }
                        
                        // Process image with Pyodide enhanced Serial/SKU processing
                        processedImageData = pyodide.runPython(`process_image_enhanced("""${imageDataURL}""", "${floatingOcrSettings.preprocessing}")`);
                        
                        if (processedImageData.startsWith('Error:')) {
                            throw new Error(processedImageData);
                        }
                        
                        // Convert processed image back to canvas
                        const img = new Image();
                        img.onload = async () => {
                            const processedCanvas = document.createElement('canvas');
                            processedCanvas.width = img.width;
                            processedCanvas.height = img.height;
                            const processedCtx = processedCanvas.getContext('2d');
                            processedCtx.drawImage(img, 0, 0);
                            
                            await performOCRRecognition(processedCanvas, startTime);
                        };
                        img.src = processedImageData;
                        
                    } else {
                        // Fallback to OpenCV processing
                        await performOpenCVProcessing(canvas, startTime);
                    }
                      } catch (err) {
                    updateFloatingResults(`<p class="text-red-500">Processing error: ${err.message}</p>`);
                }
            }

            async function performOpenCVProcessing(canvas, startTime) {
                if (!cvReady) return;
                
                let src = cv.imread(canvas);
                let dst = new cv.Mat();
                
                // Apply OpenCV preprocessing based on settings
                if (floatingOcrSettings.preprocessing === 'basic') {
                    cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);
                    const sharpKernel = cv.matFromArray(3, 3, cv.CV_32FC1, [0, -1, 0, -1, 5, -1, 0, -1, 0]);
                    cv.filter2D(dst, dst, -1, sharpKernel);
                    sharpKernel.delete();
                    cv.threshold(dst, dst, 0, 255, cv.THRESH_OTSU | cv.THRESH_BINARY_INV);
                } else if (floatingOcrSettings.preprocessing === 'enhanced') {
                    cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);
                    const clahe = new cv.CLAHE(2.0, new cv.Size(8, 8));
                    clahe.apply(dst, dst);
                    clahe.delete();
                    cv.bilateralFilter(dst, dst, 9, 75, 75);
                    const blurred = new cv.Mat();
                    cv.GaussianBlur(dst, blurred, new cv.Size(3, 3), 0, 0, cv.BORDER_DEFAULT);
                    cv.addWeighted(dst, 1.5, blurred, -0.5, 0, dst);
                    blurred.delete();
                    cv.threshold(dst, dst, 0, 255, cv.THRESH_OTSU | cv.THRESH_BINARY_INV);
                }
                
                cv.imshow(canvas, dst);
                src.delete();
                dst.delete();
                
                await performOCRRecognition(canvas, startTime);
            }

            async function performOCRRecognition(canvas, startTime) {
                if (!tesseractWorker) {
                    await initTesseract('eng', true);
                }
                
                const result = await tesseractWorker.recognize(canvas);
                const processingTime = performance.now() - startTime;
                
                let text = result.data.text.replace(/\s/g, '').toUpperCase();
                let confidence = result.data.confidence;
                  // Enhanced Serial/SKU processing with Pyodide
                if (pyodideReady) {
                    try {
                        // Use Pyodide for advanced Serial/SKU pattern extraction
                        const extractionResult = pyodide.runPython(`extract_serial_sku_patterns("""${text}""")`);
                        const patterns = extractionResult.toJs();
                        
                        if (patterns.error) {
                            throw new Error(patterns.error);
                        }
                        
                        // Check if we have high-confidence Serial/SKU matches
                        if (patterns.best_matches && patterns.best_matches.length > 0) {
                            const bestMatch = patterns.best_matches[0];
                            
                            // Validate confidence and score thresholds
                            if (bestMatch.score >= 70 && confidence >= floatingOcrSettings.confidence) {
                                const finalText = bestMatch.text;
                                const patternType = bestMatch.pattern;
                                
                                updateFloatingResults(`
                                    <div class="text-left space-y-1">
                                        <p><strong>${patternType.includes('serial') ? 'Serial' : 'SKU'}:</strong> <span class="font-mono text-blue-600">${finalText}</span></p>
                                        <div class="flex justify-between text-xs text-gray-500">
                                            <span>Score: ${bestMatch.score}%</span>
                                            <span>OCR: ${confidence.toFixed(1)}%</span>
                                        </div>
                                        <p class="text-xs text-green-600">Pattern: ${patternType}</p>
                                    </div>
                                `);
                                
                                processFloatingScannedCode(finalText, 'DEMO-Enhanced Text Scan');
                                stopFloatingOcrStreaming();
                                return;
                            }
                        }
                        
                        // Show scanning progress with pattern information
                        const patternCount = Object.keys(patterns.all_patterns || {}).length;
                        updateFloatingResults(`
                            <div class="text-center space-y-1">
                                <p class="text-blue-500">Scanning Serial/SKU...</p>
                                <div class="flex justify-between text-xs text-gray-500">
                                    <span>OCR: ${confidence.toFixed(1)}%</span>
                                    <span>Patterns: ${patternCount}</span>
                                </div>
                                <p class="text-xs text-gray-400">${patterns.cleaned_text.substring(0, 20)}${patterns.cleaned_text.length > 20 ? '...' : ''}</p>
                            </div>
                        `);
                        
                    } catch (pyodideError) {
                        // Pyodide pattern extraction failed, falling back to basic processing
                        // Fallback to basic processing
                        performBasicSerialSKUProcessing(text, confidence);
                    }
                } else {
                    // Fallback when Pyodide is not ready
                    performBasicSerialSKUProcessing(text, confidence);
                }
            }
            
            function performBasicSerialSKUProcessing(text, confidence) {
                // Apple-specific text post-processing (fallback)
                text = text.replace(/[|]/g, 'I')
                           .replace(/[0]/g, 'O')
                           .replace(/[8]/g, 'B')
                           .replace(/[5]/g, 'S')
                           .replace(/[1]/g, 'I')
                           .replace(/[\.]/g, '')
                           .replace(/[,]/g, '')
                           .replace(/[\s]/g, '');
                
                // Enhanced Apple serial validation
                const appleSerialMatch = text.match(/[A-Z0-9\-]{8,}/);
                const isValidAppleSerial = appleSerialMatch && (
                    text.length >= 8 && text.length <= 14 &&
                    /[A-Z]/.test(text) &&
                    /[0-9]/.test(text) &&
                    !/[^A-Z0-9\-]/.test(text)
                );
                  if (isValidAppleSerial && confidence >= floatingOcrSettings.confidence) {
                    const finalText = appleSerialMatch[0];
                    updateFloatingResults(`<p>Serial/SKU: <b>${finalText}</b></p>`);
                    processFloatingScannedCode(finalText, 'DEMO-Text Scan');
                    stopFloatingOcrStreaming();
                } else {
                    updateFloatingResults(`<p class='text-blue-500'>Scanning... (${confidence.toFixed(1)}%)</p>`);
                }
            }

            async function captureAndRecognizeFloating() {
                if (!floatingStream || !cvReady) {
                    updateFloatingResults(`<p class="text-red-500">Camera or OpenCV not ready</p>`);
                    return;
                }
                
                updateFloatingResults(`<p class="text-blue-500">กำลังประมวลผลตัวอักษร...</p>`);
                const captureBtn = document.getElementById('floating-capture-btn');
                captureBtn.disabled = true;
                
                try {
                    const video = document.getElementById('floating-text-video');
                    const canvas = document.createElement('canvas');
                    
                    const cropHeightPercentage = 0.15;
                    const cropWidthPercentage = 0.70;
                    const sWidth = video.videoWidth * cropWidthPercentage;
                    const sHeight = video.videoHeight * cropHeightPercentage;
                    const sx = video.videoWidth * (1 - cropWidthPercentage) / 2;
                    const sy = video.videoHeight * 0.45;
                    
                    canvas.width = sWidth;
                    canvas.height = sHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
                    
                    await performOCRRecognition(canvas, performance.now());
                    
                } catch (err) {
                    updateFloatingResults(`<p class="text-red-500">Capture error: ${err.message}</p>`);
                } finally {
                    captureBtn.disabled = false;
                }
            }            
            
            function processFloatingScannedCode(code, reason) {
                const scannedText = code.toUpperCase();
                // Store latest scanned text and add to history
                lastScannedText = scannedText;
                scanHistory.unshift({ text: scannedText, timestamp: new Date().toLocaleTimeString(), reason });
                if (scanHistory.length > 10) scanHistory.pop(); // Keep last 10 scans
                
                let item = null;
                  // Determine which dataset to search based on context
                let searchData;
                if (currentScannerContext === 'demo') {
                    searchData = state.demoMaster;
                } else if (currentScannerContext === 'final') {
                    searchData = state.reconciledData;
                } else if (currentScannerContext === 'spp-spare-parts') {
                    searchData = state.sppSparePartsMaster;
                } else if (currentScannerContext === 'spp-glue') {
                    searchData = state.sppGlueMaster;
                } else if (currentScannerContext === 'spp-tools') {
                    searchData = state.sppToolsMaster;
                } else {
                    searchData = state.demoMaster; // fallback
                }
                  if (!searchData || searchData.length === 0) {
                    playSound('error');
                    updateFloatingResults(`<div class="text-center w-full"><p class="font-bold text-red-600">No data available</p><p class="text-sm text-slate-500">Scanned: ${scannedText}</p><p class="text-xs text-slate-400">Latest scan stored</p></div>`);
                    return;
                }
                
                // Use shared matching function
                item = findItemByScannedText(searchData, scannedText);
                  if (item) {
                    playSound('success');
                    
                    if (currentScannerContext === 'demo') {
                        // Update demo count
                        let currentCount = typeof item.counted === 'number' ? item.counted : 0;
                        item.counted = currentCount + 1;
                        state.demoCounts[item.SKU] = { qty: item.counted, reason: reason };
                        applyDemoView();
                        
                        const diff = item.counted - item.SOH;
                        let statusText = (diff === 0) ? 'Matched' : (diff > 0) ? 'Overage' : 'Shortage';
                        let statusColor = (diff === 0) ? 'text-green-600' : (diff > 0) ? 'text-yellow-600' : 'text-blue-600';
                        
                        updateFloatingResults(`<div class="text-left w-full space-y-1"><p class="font-medium text-slate-800">${item.Description}</p><p class="text-sm text-slate-500">SKU: ${item.SKU}</p><div class="flex justify-between items-baseline pt-1"><span class="text-lg font-bold text-slate-700">Count: <span class="text-blue-600">${item.counted}</span> / ${item.SOH}</span><span class="text-lg font-bold ${statusColor}">${statusText}</span></div><p class="text-xs text-green-600 mt-1">✓ Match found for: ${scannedText}</p></div>`);                    } else if (currentScannerContext === 'spp-spare-parts') {
                        // Update SPP Spare Parts count
                        updateSppSparePartsCount(item.SKU, 1, 'SPP-Scan');
                        applySppSparePartsView();
                        
                        const currentCount = state.sppSparePartsCounts[item.SKU]?.qty || 0;
                        updateFloatingResults(`<div class="text-left w-full space-y-1"><p class="font-medium text-slate-800">${item.Description}</p><p class="text-sm text-slate-500">Part No: ${item.SKU}</p><div class="flex justify-between items-baseline pt-1"><span class="text-lg font-bold text-slate-700">Count: <span class="text-blue-600">${currentCount}</span></span><span class="text-sm text-slate-500">SPP Spare Parts</span></div><p class="text-xs text-green-600 mt-1">✓ Match found for: ${scannedText}</p></div>`);
                    } else if (currentScannerContext === 'spp-glue') {
                        // Update SPP Glue count
                        updateSppGlueCount(item.SKU, 1, 'SPP-Scan');
                        applySppGlueView();
                        
                        const currentCount = state.sppGlueCounts[item.SKU]?.qty || 0;
                        updateFloatingResults(`<div class="text-left w-full space-y-1"><p class="font-medium text-slate-800">${item.Description}</p><p class="text-sm text-slate-500">Part No: ${item.SKU}</p><div class="flex justify-between items-baseline pt-1"><span class="text-lg font-bold text-slate-700">Count: <span class="text-blue-600">${currentCount}</span></span><span class="text-sm text-slate-500">SPP Glue/Adhesive</span></div><p class="text-xs text-green-600 mt-1">✓ Match found for: ${scannedText}</p></div>`);
                    } else if (currentScannerContext === 'spp-tools') {
                        // Update SPP Tools count
                        updateSppToolsCount(item.SKU, 1, 'SPP-Scan');
                        applySppToolsView();
                        
                        const currentCount = state.sppToolsCounts[item.SKU]?.qty || 0;
                        updateFloatingResults(`<div class="text-left w-full space-y-1"><p class="font-medium text-slate-800">${item.Description}</p><p class="text-sm text-slate-500">Part No: ${item.SKU}</p><div class="flex justify-between items-baseline pt-1"><span class="text-lg font-bold text-slate-700">Count: <span class="text-blue-600">${currentCount}</span></span><span class="text-sm text-slate-500">SPP Tools</span></div><p class="text-xs text-green-600 mt-1">✓ Match found for: ${scannedText}</p></div>`);
                    } else {
                        // Final report context - just highlight the found item
                        updateFloatingResults(`<div class="text-left w-full space-y-1"><p class="font-medium text-slate-800">${item.Description}</p><p class="text-sm text-slate-500">SKU: ${item.SKU}</p><div class="flex justify-between items-baseline pt-1"><span class="text-lg font-bold text-slate-700">Counted: <span class="text-blue-600">${item.Recount}</span> / ${item.SOH}</span><span class="text-lg font-bold">${item.FinalDiff === 0 ? '<span class="text-green-600">Matched</span>' : item.FinalDiff > 0 ? '<span class="text-yellow-600">Overage</span>' : '<span class="text-blue-600">Shortage</span>'}</span></div><p class="text-xs text-green-600 mt-1">✓ Match found for: ${scannedText}</p></div>`);
                    }                    
                    // Scroll to item in table and highlight
                    let tableContainer, cardsContainer;
                    if (currentScannerContext === 'demo') {
                        tableContainer = document.getElementById('demo-count-container');
                        cardsContainer = document.getElementById('demo-count-cards');
                    } else if (currentScannerContext === 'final') {
                        tableContainer = document.getElementById('final-report-table-container');
                        cardsContainer = document.getElementById('final-report-cards');
                    } else if (currentScannerContext === 'spp-spare-parts') {
                        tableContainer = document.getElementById('spp-spare-parts-container');
                        cardsContainer = document.getElementById('spp-spare-parts-cards');
                    } else if (currentScannerContext === 'spp-glue') {
                        tableContainer = document.getElementById('spp-glue-container');
                        cardsContainer = document.getElementById('spp-glue-cards');
                    } else if (currentScannerContext === 'spp-tools') {
                        tableContainer = document.getElementById('spp-tools-container');
                        cardsContainer = document.getElementById('spp-tools-cards');
                    }
                        
                    // Try desktop table first
                    if (tableContainer) {
                        const row = tableContainer.querySelector(`tr[data-sku="${item.SKU}"]`);
                        if (row) {
                            row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            row.classList.add('ring-2', 'ring-offset-2', 'ring-green-500');
                            setTimeout(() => row.classList.remove('ring-2', 'ring-offset-2', 'ring-green-500'), 800);
                        }
                    }
                    
                    // Also try mobile cards (for mobile view)
                    if (cardsContainer) {
                        const card = cardsContainer.querySelector(`[data-sku="${item.SKU}"]`);
                        if (card) {
                            card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            card.classList.add('ring-2', 'ring-offset-2', 'ring-green-500');
                            setTimeout(() => card.classList.remove('ring-2', 'ring-offset-2', 'ring-green-500'), 800);
                        }
                    }} else {
                    playSound('error');
                    // Show scanned text even when no match found
                    updateFloatingResults(`<div class="text-center w-full"><p class="font-bold text-red-600">SKU Not Found</p><p class="text-sm text-slate-700 font-medium">Scanned: ${scannedText}</p><p class="text-xs text-slate-400 mt-1">Latest scan stored • No matching SKU in ${currentScannerContext} data</p></div>`);
                }
            }

            const floatingScanCooldown = {};
            function onFloatingBarcodeDetected(result) {
                const code = result.codeResult.code.trim();
                const now = Date.now();
                if (floatingScanCooldown[code] && now - floatingScanCooldown[code] < 10000) return;
                floatingScanCooldown[code] = now;
                processFloatingScannedCode(code, 'DEMO-Barcode');
            }            
            function openFloatingScanner(context = 'demo') {
                currentScannerContext = context;
                currentScannerMode = 'barcode';
                  // Reset scanner state
                document.getElementById('floating-barcode-tab').classList.add('active');
                document.getElementById('floating-text-tab').classList.remove('active');
                document.getElementById('floating-barcode-view').classList.remove('hidden');
                document.getElementById('floating-text-view').classList.add('hidden');
                document.getElementById('floating-ocr-preview').classList.add('hidden');
                document.getElementById('floating-ocr-controls').classList.add('hidden');
                
                // Ensure proper display and visibility
                floatingScanner.style.display = 'block';
                floatingScanner.style.visibility = 'visible';
                floatingScanner.style.opacity = '1';
                
                // Show scanner with animation
                floatingScanner.classList.add('active');
                
                // Start with barcode scanner
                setTimeout(() => {
                    startFloatingBarcodeScanner();
                }, 300);
                
                // Initialize Pyodide if not already done
                if (!pyodideReady) {
                    initializePyodide();
                }
                  updateFloatingResults('<p class="text-blue-500">Scanner ready</p>');
            }
            function closeFloatingScanner() {                
                if (!floatingScanner) return;
                // Stop all scanner activities first
                stopFloatingTextScanner();
                stopFloatingBarcodeScanner();
                stopFloatingOcrStreaming();
                
                // Clear all video streams
                const video = document.getElementById('floating-text-video');
                if (video && video.srcObject) {                    
                    const tracks = video.srcObject.getTracks();
                    tracks.forEach(track => {
                        track.stop();
                    });
                    video.srcObject = null;
                }
                
                // Force stop Quagga barcode scanner
                if (typeof Quagga !== 'undefined' && Quagga.running) {                    
                    try {
                        Quagga.offDetected(onFloatingBarcodeDetected);
                        Quagga.stop();                    
                    } catch (err) {
                        // Silent error handling for production
                    }
                }
                  // Clear barcode scanner video with improved cleanup
                const barcodeTarget = document.getElementById('floating-qr-reader');
                if (barcodeTarget) {
                    const quaggaVideo = barcodeTarget.querySelector('video');
                    if (quaggaVideo && quaggaVideo.srcObject) {
                        const tracks = quaggaVideo.srcObject.getTracks();                
                        tracks.forEach(track => track.stop());
                        quaggaVideo.srcObject = null;
                    }
                    // Clear the container to remove any Quagga elements
                    barcodeTarget.innerHTML = '';
                }
                
                // Reset any custom transform on scanner
                floatingScanner.style.transform = '';
                
                // Ensure proper transition is enabled
                floatingScanner.style.transition = 'transform 0.3s ease-in-out, visibility 0.3s ease-in-out, opacity 0.3s ease-in-out';
                
                // Hide scanner completely with proper CSS states
                floatingScanner.classList.remove('active');
                  // Force complete hiding after animation
                setTimeout(() => {
                    if (!floatingScanner.classList.contains('active')) {
                        floatingScanner.style.display = 'none';
                        floatingScanner.style.visibility = 'hidden';
                        floatingScanner.style.opacity = '0';
                    }
                }, 350); // Wait for CSS transition to complete
                
                // Reset tab states for next opening
                setTimeout(() => {
                    document.getElementById('floating-barcode-tab').classList.add('active');
                    document.getElementById('floating-text-tab').classList.remove('active');
                    document.getElementById('floating-barcode-view').classList.remove('hidden');
                    document.getElementById('floating-text-view').classList.add('hidden');
                    document.getElementById('floating-ocr-preview').classList.add('hidden');
                    document.getElementById('floating-ocr-controls').classList.add('hidden');
                      // Clear results when scanner is closed
                    updateFloatingResults('<p class="text-gray-400">Click scan to start</p>');
                    
                    currentScannerMode = 'barcode';
                }, 400); // Wait for animation to complete
            }

            function updateFloatingResults(html) {
                const resultsEl = document.getElementById('floating-scanner-results');
                if (resultsEl) {
                    resultsEl.innerHTML = html;
                }            }            // === OCR Enhancement Variables ===
            let tesseractWorker = null;
            let finalTesseractWorker = null;
              // === OCR Cache and Performance Variables ===
            let ocrResultsCache = new Map();
            let finalOcrResultsCache = new Map();
            let ocrSuccessCount = 0;
            let ocrTotalAttempts = 0;
            let ocrCacheHits = 0;
            let ocrPerformanceHistory = [];
            let ocrPatternLearning = new Map();
            let finalOcrSuccessCount = 0;
            let finalOcrTotalAttempts = 0;
            let finalOcrCacheHits = 0;
            let finalOcrPerformanceHistory = [];
            let finalOcrPatternLearning = new Map();
            
            // === OCR Streaming Variables ===
            let ocrStreaming = false;
            let ocrStreamInterval = null;
            let finalOcrStreaming = false;
            let finalOcrStreamInterval = null;
            
            // === Scanner Variables ===
            let textScannerVideo = null;
            let activeStream = null;
            
            // === OCR Variables (simplified) ===
            let ocrSettings = {
                demo: { confidence: 60, language: 'eng', preprocessing: 'enhanced', speed: 800 },
                final: { confidence: 60, language: 'eng', preprocessing: 'enhanced', speed: 800 }
            };

            // === OCR Enhancement Functions ===
            async function initTesseract(language = 'eng', isDemo = true) {
                const worker = isDemo ? tesseractWorker : finalTesseractWorker;
                if (worker) {
                    await worker.terminate();
                }
                
                const newWorker = await Tesseract.createWorker(language);
                
                // Enhanced OCR parameters for Apple product serial numbers
                await newWorker.setParameters({
                    // Character whitelist optimized for Apple serials
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_',
                    // Single line mode for serial numbers
                    tessedit_pageseg_mode: Tesseract.PSM.SINGLE_LINE,
                    // Improved OCR engine mode for better accuracy
                    tessedit_ocr_engine_mode: Tesseract.OEM.LSTM_ONLY,
                    // Enable dictionary for better word recognition
                    tessedit_enable_dict_correction: 1,
                    // Numeric mode for better digit recognition
                    tessedit_enable_numeric_mode: 1,
                    // Improve recognition of similar characters
                    tessedit_char_unblacklist: '',
                    // Better handling of mixed alphanumeric content
                    preserve_interword_spaces: 0,
                    // Optimize for Apple's typical serial number patterns
                    user_defined_dpi: 300,
                    // Better edge detection for clear text
                    edges_use_image_gradients: 1
                });
                  if (isDemo) {
                    tesseractWorker = newWorker;
                } else {
                    finalTesseractWorker = newWorker;
                }
                
                return newWorker;
            }

            function generateCacheKey(imageData, settings) {
                const canvas = document.createElement('canvas');
                canvas.width = 50;
                canvas.height = 20;
                const ctx = canvas.getContext('2d');
                ctx.putImageData(imageData, 0, 0);
                const hash = btoa(canvas.toDataURL()).slice(0, 16);
                return `${hash}-${settings.language}-${settings.preprocessing}-${settings.confidence}`;
            }            function learnSuccessPattern(text, confidence, processingTime, isDemo = true) {
                const pattern = text.substring(0, 3); // First 3 characters as pattern
                const patternMap = isDemo ? ocrPatternLearning : finalOcrPatternLearning;
                
                if (!patternMap.has(pattern)) {
                    patternMap.set(pattern, { count: 0, avgConfidence: 0, avgTime: 0 });
                }
                const existing = patternMap.get(pattern);
                existing.count++;
                existing.avgConfidence = (existing.avgConfidence + confidence) / 2;
                existing.avgTime = (existing.avgTime + processingTime) / 2;
            }            function boostConfidenceForKnownPatterns(text, confidence, isDemo = true) {
                const pattern = text.substring(0, 3);
                const patternMap = isDemo ? ocrPatternLearning : finalOcrPatternLearning;
                const learned = patternMap.get(pattern);
                if (learned && learned.count > 2) {
                    return Math.min(confidence + (learned.avgConfidence * 0.1), 100);
                }
                return confidence;
            }            
            // Error recovery functions
            function handleOcrError(error, isDemo = true) {
                const errorMsg = error.message || 'Unknown OCR error';
                // OCR error handled silently for production
                
                // Handle error processing
                if (isDemo) {
                } else {
                }
                  // Attempt recovery based on error type
                if (errorMsg.includes('Worker')) {
                    // Worker-related error - reinitialize
                    setTimeout(() => {
                        initTesseract(isDemo ? ocrSettings.demo.language : ocrSettings.final.language, isDemo);
                    }, 1000);
                } else if (errorMsg.includes('canvas') || errorMsg.includes('image')) {
                    // Image processing error - skip frame
                } else if (errorMsg.includes('memory')) {                    // Memory issue - clear cache and restart
                    cleanupOcrCache();
                    setTimeout(() => {
                        initTesseract(isDemo ? ocrSettings.demo.language : ocrSettings.final.language, isDemo);
                    }, 2000);
                }
                
                return false; // Indicate error was handled
            }

            function validateOcrResult(result, confidence, expectedPattern = /[A-Z0-9\-]{8,}/) {
                if (!result || !result.data) return false;
                
                const text = result.data.text.replace(/\s/g, '').toUpperCase();
                const hasValidPattern = expectedPattern.test(text);
                const hasValidConfidence = confidence >= 30; // Minimum threshold
                
                return hasValidPattern && hasValidConfidence;
            }

            function adaptiveOcrSettings(performance, isDemo = true) {
                const settings = isDemo ? ocrSettings.demo : ocrSettings.final;
                const recentPerformance = (isDemo ? ocrPerformanceHistory : finalOcrPerformanceHistory).slice(-10);
                
                if (recentPerformance.length < 5) return; // Not enough data
                
                const avgConfidence = recentPerformance.reduce((sum, p) => sum + p.confidence, 0) / recentPerformance.length;
                const successRate = recentPerformance.filter(p => p.success).length / recentPerformance.length;
                  // Adapt preprocessing based on performance
                if (successRate < 0.3 && avgConfidence < 70) {
                    // Poor performance - increase preprocessing
                    if (settings.preprocessing === 'basic') {
                        settings.preprocessing = 'enhanced';
                    } else if (settings.preprocessing === 'enhanced') {
                        settings.preprocessing = 'aggressive';
                    }
                } else if (successRate > 0.8 && avgConfidence > 85) {
                    // Great performance - reduce preprocessing for speed
                    if (settings.preprocessing === 'aggressive') {
                        settings.preprocessing = 'enhanced';
                    } else if (settings.preprocessing === 'enhanced') {
                        settings.preprocessing = 'basic';
                    }
                }
                
                // Update UI if needed
                const selectElement = document.getElementById(isDemo ? 'ocr-preprocessing-select' : 'final-ocr-preprocessing-select');
                if (selectElement && selectElement.value !== settings.preprocessing) {
                    selectElement.value = settings.preprocessing;
                }            }

            // Cache management functions
            function cleanupOcrCache() {
                const now = Date.now();
                const maxAge = 5 * 60 * 1000; // 5 minutes
                
                // Clean demo cache
                for (const [key, value] of ocrResultsCache.entries()) {
                    if (now - value.timestamp > maxAge) {
                        ocrResultsCache.delete(key);
                    }
                }
                
                // Clean final cache
                for (const [key, value] of finalOcrResultsCache.entries()) {
                    if (now - value.timestamp > maxAge) {
                        finalOcrResultsCache.delete(key);
                    }
                }
                
                // Limit cache size
                const maxCacheSize = 100;
                if (ocrResultsCache.size > maxCacheSize) {
                    const entries = Array.from(ocrResultsCache.entries());
                    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
                    const toDelete = entries.slice(0, entries.length - maxCacheSize);
                    toDelete.forEach(([key]) => ocrResultsCache.delete(key));
                }
                
                if (finalOcrResultsCache.size > maxCacheSize) {
                    const entries = Array.from(finalOcrResultsCache.entries());
                    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
                    const toDelete = entries.slice(0, entries.length - maxCacheSize);
                    toDelete.forEach(([key]) => finalOcrResultsCache.delete(key));                
                }
            }
            
            function resetOcrStats() {
                ocrSuccessCount = 0;
                ocrTotalAttempts = 0;
                ocrCacheHits = 0;
                ocrPerformanceHistory.length = 0;
                ocrResultsCache.clear();
                ocrPatternLearning.clear();
                  finalOcrSuccessCount = 0;
                finalOcrTotalAttempts = 0;
                finalOcrCacheHits = 0;
                finalOcrPerformanceHistory.length = 0;
                finalOcrResultsCache.clear();
                finalOcrPatternLearning.clear();
            }            
            // Auto-cleanup cache every 2 minutes
            setInterval(cleanupOcrCache, 2 * 60 * 1000);

            // === Shared SKU Matching Functions ===
            function getMatchingAlgorithms() {
                return [
                    // Algorithm 1: Direct SKU contained in scanned text
                    (sku, scanned) => scanned.includes(sku),
                    // Algorithm 2: SKU with S prefix contained in scanned text
                    (sku, scanned) => scanned.includes(sku.slice(1)),
                    // Algorithm 3: SKU without S prefix (if SKU starts with S)
                    (sku, scanned) => sku.startsWith('S') && scanned.includes(sku.slice(1)),
                    // Algorithm 4: Scanned text with S prefix matches SKU
                    (sku, scanned) => ('S' + scanned) === sku,
                    // Algorithm 5: Last 5 characters pattern match
                    (sku, scanned) => {
                        if (sku.length >= 5) {
                            const skuLast5 = sku.slice(-5);
                            return scanned.includes(skuLast5);
                        }
                        return false;
                    },
                    // Algorithm 6: First 5 characters pattern match
                    (sku, scanned) => {
                        if (sku.length >= 5) {
                            const skuFirst5 = sku.slice(0, 5);
                            return scanned.includes(skuFirst5);
                        }
                        return false;
                    },
                    // Algorithm 7: Middle pattern match (removes first and last char)
                    (sku, scanned) => {
                        if (sku.length >= 6) {
                            const skuMiddle = sku.slice(1, -1);
                            return scanned.includes(skuMiddle);
                        }
                        return false;
                    },
                    // Algorithm 8: Fuzzy match for Apple serial patterns
                    (sku, scanned) => {
                        const cleanSku = sku.replace(/^S?/, '').replace(/[-_].*$/, '');
                        const cleanScanned = scanned.replace(/[-_].*$/, '');
                        return cleanSku.length >= 4 && cleanScanned.includes(cleanSku);
                    },
                    // Algorithm 9: CS prefix matching
                    (sku, scanned) => sku.includes('CS' + scanned),
                    // Algorithm 10: cs prefix matching
                    (sku, scanned) => sku.includes('cs' + scanned),
                    // Algorithm 11: 0 prefix matching
                    (sku, scanned) => sku.includes('0' + scanned),
                    // Algorithm 12: SKU without CS prefix (if SKU starts with CS)
                    (sku, scanned) => sku.startsWith('CS') && scanned.includes(sku.slice(2)),
                    // Algorithm 13: SKU without cs prefix (if SKU starts with cs)
                    (sku, scanned) => sku.startsWith('cs') && scanned.includes(sku.slice(2)),
                    // Algorithm 14: SKU without 0 prefix (if SKU starts with 0)
                    (sku, scanned) => sku.startsWith('0') && scanned.includes(sku.slice(1))
                ];
            }

            function findItemByScannedText(items, scannedText) {
                // Try direct matches first
                let item = items.find(i => i.SKU === scannedText) ||
                          items.find(i => i.SKU === 'S' + scannedText) ||
                          items.find(i => i.SKU === 'CS' + scannedText) ||
                          items.find(i => i.SKU === 'cs' + scannedText) ||
                          items.find(i => i.SKU === '0' + scannedText);

                // If not found, try advanced matching algorithms
                if (!item) {
                    const matchingAlgorithms = getMatchingAlgorithms();
                    for (const dataItem of items) {
                        for (const algorithm of matchingAlgorithms) {
                            if (algorithm(dataItem.SKU, scannedText)) {
                                item = dataItem;
                                break;
                            }
                        }
                        if (item) break;
                    }
                                }                return item;
            }
            
            function getInitialState() {
                return {
                    sohData: [], sohLookup: {}, scannerMaster: [], demoMaster: [],
                    demoCounts: {}, demoSort: { column: 'SKU', direction: 'asc' },
                    // SPP state management
                    sppSparePartsMaster: [], sppGlueMaster: [], sppToolsMaster: [],
                    sppSparePartsCounts: {}, sppGlueCounts: {}, sppToolsCounts: {},
                    sppSparePartsSort: { column: 'SKU', direction: 'asc' },
                    sppGlueSort: { column: 'SKU', direction: 'asc' },
                    sppToolsSort: { column: 'SKU', direction: 'asc' },
                    netDiffData: [], reconciledData: [], finalReportSort: { column: 'SKU', direction: 'asc' },
                    charts: { cost: null, qty: null, category: null },
                    branchName: null, branchCode: null, countDate: null,
                    sohUpdatedSkus: new Set(), // Track SKUs that had SOH updated
                };
            }
              function showLoader(message = "Processing...") { 
                const loaderMessageEl = getEl('loader-message');
                const loaderOverlayEl = getEl('loader-overlay');
                if (loaderMessageEl) loaderMessageEl.textContent = message;
                if (loaderOverlayEl) loaderOverlayEl.classList.remove('hidden'); 
            }
            function hideLoader() { 
                const loaderOverlayEl = getEl('loader-overlay');
                if (loaderOverlayEl) loaderOverlayEl.classList.add('hidden'); 
            }
              function showModal(title, message, options = {}) {
                const modalTitleEl = getEl('modal-title');
                const modalMessageEl = getEl('modal-message');
                const confirmBtn = getEl('modal-confirm-btn');
                const cancelBtn = getEl('modal-cancel-btn');
                const modalContainerEl = getEl('modal-container');
                const modalBoxEl = getEl('modal-box');
                
                if (modalTitleEl) modalTitleEl.textContent = title;
                if (modalMessageEl) modalMessageEl.innerHTML = message;
                if (confirmBtn) {
                    confirmBtn.textContent = options.confirmText || 'OK';
                    confirmBtn.onclick = () => { hideModal(); if (options.onConfirm) options.onConfirm(); };
                }
                if (cancelBtn) {
                    cancelBtn.classList.toggle('hidden', !options.onCancel);
                    if (options.onCancel) {
                        cancelBtn.textContent = options.cancelText || 'Cancel';
                        cancelBtn.onclick = () => { hideModal(); options.onCancel(); };
                    }
                }
                if (modalContainerEl) modalContainerEl.classList.remove('hidden');
                if (modalBoxEl) setTimeout(() => modalBoxEl.classList.add('scale-100', 'opacity-100'), 10);
            }

            function hideModal() {
                const modalBoxEl = getEl('modal-box');
                const modalContainerEl = getEl('modal-container');
                if (modalBoxEl) modalBoxEl.classList.add('scale-95', 'opacity-0');
                if (modalContainerEl) setTimeout(() => modalContainerEl.classList.add('hidden'), 200);
            }

            let saveStatusTimeout;
            function showSaveStatus(message, isWarning) {
                const statusEl = getEl('save-status');
                clearTimeout(saveStatusTimeout);
                statusEl.textContent = message;
                statusEl.className = `text-left text-sm font-semibold opacity-100 ${isWarning ? 'text-red-600' : 'text-green-600'}`;
                if (!isWarning) {
                    saveStatusTimeout = setTimeout(() => statusEl.classList.add('opacity-0'), 3000);
                }
            }            function updateInfoBox() {
                try {
                    if (state.branchName) {
                        const branchCodeEl = getEl('info-branch-code');
                        const branchNameEl = getEl('info-branch-name');
                        const countDateEl = getEl('info-count-date');
                        const containerEl = getEl('info-box-container');
                        
                        if (branchCodeEl) branchCodeEl.textContent = state.branchCode || '';
                        if (branchNameEl) branchNameEl.textContent = state.branchName;
                        if (countDateEl) countDateEl.textContent = state.countDate;
                        if (containerEl) containerEl.classList.remove('hidden');
                    } else {
                        const containerEl = getEl('info-box-container');
                        if (containerEl) containerEl.classList.add('hidden');
                    }
                } catch (error) {
                    console.warn('Error updating info box:', error);
                }
            }
            function resetAppState() {
                // Destroy existing charts
                Object.values(state.charts).forEach(chart => chart?.destroy());
                
                // Reset application state
                state = getInitialState();
                hasUnsavedChanges = false;
                finalSummaryData = {};
                
                // Reset scanner-related variables
                lastScannedText = null;
                scanHistory = [];
                currentScannerMode = 'barcode';
                currentScannerContext = 'demo';
                floatingOcrStreaming = false;
                
                // Clear OCR streaming if active
                if (floatingOcrStreamInterval) {
                    clearInterval(floatingOcrStreamInterval);
                    floatingOcrStreamInterval = null;
                }
                
                // Reset floating scanner settings
                floatingOcrSettings = {
                    confidence: 60,
                    preprocessing: 'enhanced',
                    speed: 800
                };
            }            function resetUI() {
                // Hide/show main containers
                const workspaceContainerEl = getEl('workspace-container');
                const finalReportContainerEl = getEl('final-report-container');
                const uploadContainerEl = getEl('upload-container');
                
                if (workspaceContainerEl) workspaceContainerEl.classList.add('hidden');
                if (finalReportContainerEl) finalReportContainerEl.classList.add('hidden');
                if (uploadContainerEl) uploadContainerEl.classList.remove('hidden');
                
                // Clear all file inputs
                ['initialSohFile', 'firstScanLogfile', 'secondScanLogfile', 'latestSohFile', 'salesDataFile', 'firstMasterFile', 'secondMasterFile'].forEach(id => {
                    const el = getEl(id);
                    if (el) el.value = '';
                });
                
                // Reset file name displays
                const initialSohFileNameEl = getEl('initialSohFileName');
                const latestSohFileNameEl = getEl('latestSohFileName');
                if (initialSohFileNameEl) initialSohFileNameEl.textContent = '(.xlsx, .csv)';
                if (latestSohFileNameEl) latestSohFileNameEl.textContent = '';
                
                // Hide info box and result containers
                const infoBoxEl = getEl('info-box-container');
                const step2ResultsEl = getEl('step2-results');
                const salesProcessingEl = getEl('sales-processing-results');
                
                if (infoBoxEl) infoBoxEl.classList.add('hidden');
                if (step2ResultsEl) step2ResultsEl.classList.add('hidden');                if (salesProcessingEl) salesProcessingEl.classList.add('hidden');
                
                // Clear result container contents
                const netdiffSummaryEl = getEl('netdiff-summary-container');
                const demoCountEl = getEl('demo-count-container');
                const demoSummaryEl = getEl('demo-summary');
                const finalReportTableEl = getEl('final-report-table-container');
                const finalSummaryEl = getEl('final-summary');
                
                if (netdiffSummaryEl) netdiffSummaryEl.innerHTML = '';
                if (demoCountEl) demoCountEl.innerHTML = '';
                if (demoSummaryEl) demoSummaryEl.innerHTML = '';
                if (finalReportTableEl) finalReportTableEl.innerHTML = '';
                if (finalSummaryEl) finalSummaryEl.innerHTML = '';
                
                // Clear floating scanner results
                const floatingResults = getEl('floating-scanner-results');
                if (floatingResults) floatingResults.innerHTML = '';
                
                // Close floating scanner if open
                const floatingScanner = getEl('floating-scanner');
                if (floatingScanner && floatingScanner.classList.contains('active')) {
                    closeFloatingScanner();
                }
                  // Reset button states
                const downloadBtn = getEl('downloadMasterForScan');
                const processFirstBtn = getEl('processFirstCount');
                const finalizeBtn = getEl('finalizeFromFirstCount');
                const generateRecountBtn = getEl('generateRecountMasterFile');
                const processSecondBtn = getEl('processSecondCount');
                const processSalesBtn = getEl('processSalesData');
                const latestSohBtn = getEl('latestSohFile');
                
                if (downloadBtn) downloadBtn.disabled = true;
                if (processFirstBtn) processFirstBtn.disabled = true;
                if (finalizeBtn) finalizeBtn.disabled = true;
                if (generateRecountBtn) generateRecountBtn.disabled = true;
                if (processSecondBtn) processSecondBtn.disabled = true;
                if (processSalesBtn) processSalesBtn.disabled = true;
                if (latestSohBtn) latestSohBtn.disabled = true;
                
                // Reset search inputs
                const demoSearchInput = getEl('demoSearchInput');
                if (demoSearchInput) demoSearchInput.value = '';
                const finalSearchInput = getEl('finalSearchInput');
                if (finalSearchInput) finalSearchInput.value = '';
                  // Reset filter selects
                const demoFilterSelect = getEl('demoFilterSelect');
                if (demoFilterSelect) demoFilterSelect.value = 'all';
                const finalFilterSelect = getEl('finalFilterSelect');
                if (finalFilterSelect) finalFilterSelect.value = 'all';
                  // Reset advanced filter selects
                const demoGroupCodeFilter = getEl('demoGroupCodeFilter');
                if (demoGroupCodeFilter) demoGroupCodeFilter.value = 'all';
                const demoAgeFilter = getEl('demoAgeFilter');
                if (demoAgeFilter) demoAgeFilter.value = 'all';
                const demoSubclassFilter = getEl('demoSubclassFilter');
                if (demoSubclassFilter) demoSubclassFilter.value = 'all';
                
                const finalGroupCodeFilter = getEl('finalGroupCodeFilter');
                if (finalGroupCodeFilter) finalGroupCodeFilter.value = 'all';
                const finalAgeFilter = getEl('finalAgeFilter');
                if (finalAgeFilter) finalAgeFilter.value = 'all';
                const finalSubclassFilter = getEl('finalSubclassFilter');
                if (finalSubclassFilter) finalSubclassFilter.value = 'all';
                
                // Reset SPP search inputs and filter dropdowns
                const sppSparePartsSearchInput = getEl('sppSparePartsSearchInput');
                if (sppSparePartsSearchInput) sppSparePartsSearchInput.value = '';
                const sppGlueSearchInput = getEl('sppGlueSearchInput');
                if (sppGlueSearchInput) sppGlueSearchInput.value = '';
                const sppToolsSearchInput = getEl('sppToolsSearchInput');
                if (sppToolsSearchInput) sppToolsSearchInput.value = '';
                
                const sppSparePartsFilterSelect = getEl('sppSparePartsFilterSelect');
                if (sppSparePartsFilterSelect) sppSparePartsFilterSelect.value = 'all';
                const sppSparePartsGroupCodeFilter = getEl('sppSparePartsGroupCodeFilter');
                if (sppSparePartsGroupCodeFilter) sppSparePartsGroupCodeFilter.value = 'all';
                const sppSparePartsAgeFilter = getEl('sppSparePartsAgeFilter');
                if (sppSparePartsAgeFilter) sppSparePartsAgeFilter.value = 'all';
                const sppSparePartsSubclassFilter = getEl('sppSparePartsSubclassFilter');
                if (sppSparePartsSubclassFilter) sppSparePartsSubclassFilter.value = 'all';
                
                const sppGlueFilterSelect = getEl('sppGlueFilterSelect');
                if (sppGlueFilterSelect) sppGlueFilterSelect.value = 'all';
                const sppGlueGroupCodeFilter = getEl('sppGlueGroupCodeFilter');
                if (sppGlueGroupCodeFilter) sppGlueGroupCodeFilter.value = 'all';
                const sppGlueAgeFilter = getEl('sppGlueAgeFilter');
                if (sppGlueAgeFilter) sppGlueAgeFilter.value = 'all';
                const sppGlueSubclassFilter = getEl('sppGlueSubclassFilter');
                if (sppGlueSubclassFilter) sppGlueSubclassFilter.value = 'all';
                
                const sppToolsFilterSelect = getEl('sppToolsFilterSelect');
                if (sppToolsFilterSelect) sppToolsFilterSelect.value = 'all';
                const sppToolsGroupCodeFilter = getEl('sppToolsGroupCodeFilter');
                if (sppToolsGroupCodeFilter) sppToolsGroupCodeFilter.value = 'all';
                const sppToolsAgeFilter = getEl('sppToolsAgeFilter');
                if (sppToolsAgeFilter) sppToolsAgeFilter.value = 'all';
                const sppToolsSubclassFilter = getEl('sppToolsSubclassFilter');
                if (sppToolsSubclassFilter) sppToolsSubclassFilter.value = 'all';// Reset main tabs to workflow view
                const allMainTabs = ['demo', 'workflow', 'spp'];
                allMainTabs.forEach(tabName => {
                    const tab = getEl(`main-tab-${tabName}`);
                    const panel = getEl(`main-panel-${tabName}`);
                    if (tab && panel) {
                        tab.classList.remove('active');
                        panel.classList.add('hidden');
                    }
                });
                
                // Hide SPP tab in main navigation during reset
                getEl('main-tab-spp').classList.add('hidden');
                
                // Activate workflow tab
                const workflowTab = getEl('main-tab-workflow');
                const workflowPanel = getEl('main-panel-workflow');
                if (workflowTab && workflowPanel) {
                    workflowTab.classList.add('active');
                    workflowPanel.classList.remove('hidden');
                }
                  // Reset workflow step tabs to step 1
                document.querySelectorAll('#wf-step-tabs .tab-button').forEach(btn => btn.classList.remove('active'));
                getEl('wf-tab-btn-1').classList.add('active');
                document.querySelectorAll('.workflow-step').forEach(div => div.classList.add('hidden'));
                getEl('wf-step1').classList.remove('hidden');
                
                // Reset OCR controls to default values
                const confidenceSlider = getEl('floating-confidence-slider');
                const confidenceValue = getEl('floating-confidence-value');
                const preprocessingSelect = getEl('floating-preprocessing-select');
                if (confidenceSlider) {
                    confidenceSlider.value = '60';
                    if (confidenceValue) confidenceValue.textContent = '60%';
                }
                if (preprocessingSelect) {
                    preprocessingSelect.value = 'enhanced';
                }
            }
            
            function setUnsavedChanges(status){
                hasUnsavedChanges = status;
                if (status) {
                    showSaveStatus("Unsaved changes", true);
                }
            }
            
            function startNewJob() {
                showModal('Start New Job?', 'Are you sure? All unsaved progress will be lost.', {
                    confirmText: 'Yes, Start New Job',
                    onConfirm: () => {
                        resetAppState();
                        resetUI();
                        getEl('save-status').classList.add('opacity-0');
                    },
                    onCancel: ()=> {},
                    cancelText: 'Cancel'
                });
            }
            async function handleSohFileUpload(e) {
                const file = e.target.files[0];
                if (!file) return;
                getEl('initialSohFileName').textContent = file.name;
                showLoader();
                try {
                    resetAppState();
                    const data = await parseExcelFile(file);
                    if (!data?.length) throw new Error("File is empty or invalid.");
                    if (!data[0]?.BRANCH_NAME) throw new Error("'BRANCH_NAME' column is missing.");
                    
                    // Extract branch information
                    state.branchName = data[0].BRANCH_NAME;
                    
                    // Extract BRANCH_CODE if available
                    if (data[0]?.BRANCH_CODE) {
                        state.branchCode = data[0].BRANCH_CODE;
                    } else {
                        // If BRANCH_CODE column doesn't exist, try to extract from BRANCH_NAME
                        // Assume format like "001 - Branch Name" or similar
                        const branchNameMatch = state.branchName.match(/^(\d+)/);
                        state.branchCode = branchNameMatch ? branchNameMatch[1] : 'UNK';
                    }
                      state.countDate = new Date().toLocaleDateString('en-CA');
                    const { forScan, forDemo, forSpp, lookup } = processAndSeparateSoh(data);
                    if (Object.keys(lookup).length === 0) throw new Error("No valid stock items found. Check SKU/AVAILABLE_QTY columns.");
                    state.sohData = data;
                    state.sohLookup = lookup;
                    state.scannerMaster = forScan;
                    state.demoMaster = forDemo.map(item => ({ ...item, counted: null, reason: 'DEMO-Manual' }));
                      // Initialize SPP masters if available
                    if (forSpp) {
                        state.sppSparePartsMaster = forSpp.spareParts.map(item => ({ ...item, counted: null, reason: 'SPP-Manual' }));
                        state.sppGlueMaster = forSpp.glue.map(item => ({ ...item, counted: null, reason: 'SPP-Manual' }));
                        state.sppToolsMaster = forSpp.tools.map(item => ({ ...item, counted: null, reason: 'SPP-Manual' }));
                        
                        // Populate filter dropdowns
                        populateSppSparePartsFilters();
                        populateSppGlueFilters();
                        populateSppToolsFilters();
                    }
                    rebuildUiFromState();
                    setUnsavedChanges(true); 
                } catch (error) {
                    showModal("Error Processing File", error.message);
                    resetAppState();
                    resetUI();
                } finally {
                    hideLoader();
                }
            }            
            function handleSaveProgressToFile() {
                if (!state.sohData.length) {
                    return showModal("Info", "There is no progress to save.");
                }
                const stateToSave = { 
                    ...state, 
                    charts: {},
                    // Convert Set to Array for JSON serialization
                    sohUpdatedSkus: state.sohUpdatedSkus ? Array.from(state.sohUpdatedSkus) : []
                };
                const blob = new Blob([JSON.stringify(stateToSave, null, 2)], { type: 'application/json' });
                const branchInfo = state.branchCode ? `${state.branchCode}_${state.branchName.replace(/\s+/g, '_')}` : state.branchName.replace(/\s+/g, '_');
                const fileName = `${state.countDate}_stock_count_${branchInfo}.json`;
                downloadFile(blob, fileName);
                hasUnsavedChanges = false;
                showSaveStatus("Progress saved to file", false);
            }

            function handleLoadProgressFromFile(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const loadedState = JSON.parse(event.target.result);
                        if (!loadedState?.sohData?.length) throw new Error("Invalid or empty progress file.");
                        restoreState(loadedState);
                        showModal("Success", "Progress has been loaded.");
                    } catch(err) {
                        showModal("Error", "Could not parse the selected file. Please ensure it's a valid progress file.");
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            }
              function parseExcelFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const workbook = XLSX.read(e.target.result, { type: 'array' });
                            resolve(XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]]));
                        } catch (err) { reject(err); }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            }            
            function parseSalesExcelFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const workbook = XLSX.read(e.target.result, { 
                                type: 'array',
                                cellStyles: false,
                                cellNF: false,
                                cellDates: false
                            });
                            
                            const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                            
                            // Step 1: Unmerge all cells by expanding merged cell values
                            // Get the range of the worksheet
                            const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1:A1');
                            
                            // Process merged cells if they exist
                            if (worksheet['!merges']) {
                                worksheet['!merges'].forEach(merge => {
                                    // Get the value from the top-left cell of the merged range
                                    const topLeftCell = XLSX.utils.encode_cell({r: merge.s.r, c: merge.s.c});
                                    const mergedValue = worksheet[topLeftCell] ? worksheet[topLeftCell].v : '';
                                    
                                    // Fill all cells in the merged range with the same value
                                    for (let row = merge.s.r; row <= merge.e.r; row++) {
                                        for (let col = merge.s.c; col <= merge.e.c; col++) {
                                            const cellAddr = XLSX.utils.encode_cell({r: row, c: col});
                                            if (!worksheet[cellAddr]) {
                                                worksheet[cellAddr] = { t: 's', v: mergedValue };
                                            }
                                        }
                                    }
                                });
                                // Remove merge information
                                delete worksheet['!merges'];
                            }
                            
                            // Step 2: Convert to JSON array (this gives us all rows)
                            const jsonData = XLSX.utils.sheet_to_json(worksheet, { 
                                header: 1, // Use array format instead of object format
                                defval: '', // Default value for empty cells
                                raw: false // Convert values to strings
                            });
                            
                            // Step 3: Remove top 5 rows
                            const dataAfterTopRemoval = jsonData.slice(5);
                            
                            // Step 4: Remove blank rows from bottom
                            // Find the last row that has meaningful content
                            let lastMeaningfulRowIndex = -1;
                            for (let i = dataAfterTopRemoval.length - 1; i >= 0; i--) {
                                const row = dataAfterTopRemoval[i];
                                if (row && row.some(cell => cell && String(cell).trim() !== '')) {
                                    lastMeaningfulRowIndex = i;
                                    break;
                                }
                            }
                            
                            // Trim the array to remove blank rows from bottom
                            const cleanedData = lastMeaningfulRowIndex >= 0 
                                ? dataAfterTopRemoval.slice(0, lastMeaningfulRowIndex + 1)
                                : [];
                            
                            resolve(cleanedData);
                        } catch (err) { 
                            reject(err); 
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            }            
            function processAndSeparateSoh(sohData) {
                const forScan = [], forDemo = [], lookup = {};
                
                // Step 1: Determine target warehouse and branch information
                const targetWhCode = sohData.find(row => row.WH_CODE)?.WH_CODE;
                if (!targetWhCode) throw new Error("Could not determine warehouse code (WH_CODE).");
                
                const targetBranchName = sohData.find(row => row.BRANCH_NAME)?.BRANCH_NAME || '';
                const branchNameUpper = targetBranchName.toUpperCase();
                
                // Step 2: Determine processing mode based on branch type
                const isICenter = branchNameUpper.includes('ICENTER');
                const isIStudio = branchNameUpper.includes('ISTUDIO');
                const useAdvancedMode = isICenter || isIStudio;
                
                console.log(`Branch: ${targetBranchName}, iCenter: ${isICenter}, iStudio: ${isIStudio}, Advanced Mode: ${useAdvancedMode}`);
                
                if (useAdvancedMode) {
                    console.log(`Enhanced SPP filtering active for ${isICenter ? 'iCenter' : 'iStudio'} branch (CLASS_CODE, SUBCLASS_CODE detection enabled)`);
                }
                
                // Step 3: Filter by warehouse and apply transformations
                let processedData = sohData.filter(row => row.WH_CODE === targetWhCode);
                
                if (useAdvancedMode) {
                    // Advanced Power Query sequence for iCenter/iStudio branches
                    processedData = processAdvancedBranchData(processedData, isICenter, isIStudio);
                }
                
                // Step 4: Process each row with enhanced logic
                processedData.forEach(row => {
                    // Extract basic info first (Power Query sequence step 1)
                    const desc = String(row.DESCRIPTION || '').toUpperCase();
                    const family = String(row.FAMILY || '').toUpperCase();
                    const originalSku = String(row.SKU || '').trim().toUpperCase();
                    const groupCode = String(row.GROUP_CODE || '').toUpperCase();
                    const subclassCode = String(row.SUBCLASS_CODE || '').toUpperCase();
                      // Advanced DEMO detection logic (Power Query sequence step 2)
                    let isDemo;
                    if (useAdvancedMode) {
                        isDemo = detectAdvancedDemo(originalSku, desc, family, groupCode, subclassCode, isIStudio);
                    } else {
                        // Check family field first (highest priority)
                        if (family === 'DEMO') {
                            isDemo = true;
                        } else {
                            // Exclusion list for items that should NOT be flagged as DEMO
                            const demoExclusions = [
                                'AIS SIM DYNAMIC SALE',
                                'AIS SIM'
                            ];
                            
                            // Check if SKU or description contains any exclusion patterns
                            const isExcluded = demoExclusions.some(exclusion => 
                                originalSku.includes(exclusion) || desc.includes(exclusion)
                            );
                            
                            // Standard DEMO detection logic with exclusions (fallback if family is not DEMO)
                            isDemo = (
                                !isExcluded && 
                                !originalSku.startsWith('DLCGZ') && (
                                    originalSku.startsWith('D') ||           // Condition 1: First character is 'D'
                                    originalSku.includes('DEMO') ||          // Condition 2: SKU contains "DEMO" anywhere
                                    desc.includes('DEMO')                    // Condition 3: Description contains "DEMO"
                                )
                            );
                        }
                    }
                    
                    // Serial/SKU combination logic (Power Query sequence step 3)
                    const isSerial = !!row.SERIAL_NO;
                    let combinedSku = String(isSerial ? row.SERIAL_NO : row.SKU || '');
                    
                    // Apply advanced SKU transformations for iCenter/iStudio (Power Query sequence step 4)
                    if (useAdvancedMode) {
                        combinedSku = applyAdvancedSkuTransformations(combinedSku);
                    } else {
                        // Standard transformation: replace dots with spaces
                        combinedSku = combinedSku.replace(/\./g, ' ');
                    }
                    
                    // Final SKU processing (Power Query sequence step 5)
                    const sku = combinedSku.trim().toUpperCase();
                    if (!sku) return;
                    
                    const isSerialControlled = row.SERIAL_CONTROL === 'Y' || isSerial;
                    const qty = parseInt(String(row.AVAILABLE_QTY ?? 0).replace(/,/g, ''), 10);                    
                    const srpRaw = row.SRP_AMT_INC_VAT;
                    const srp = srpRaw === null || srpRaw === undefined || srpRaw === '' ? 0 : parseFloat(String(srpRaw).replace(/,/g, ''));
                      // Enhanced categorization for advanced mode
                    let category = 'REGULAR';
                    if (useAdvancedMode) {
                        // Add branch type to row for enhanced detection
                        const rowWithBranchType = {
                            ...row,
                            branchType: isICenter ? 'iCenter' : 'iStudio'
                        };
                        category = determineAdvancedCategory(rowWithBranchType, isDemo, isIStudio);
                    }
                    
                    // Aggregation logic (Power Query sequence step 6)
                    if (lookup[sku] && !isSerialControlled) {
                        const existing = lookup[sku];
                        const newTotalQty = existing.SOH + qty;
                        const newTotalSrpValue = (existing.SOH * existing.Price) + (qty * srp);
                        existing.SOH = newTotalQty;
                        existing.Price = newTotalQty > 0 ? newTotalSrpValue / newTotalQty : 0;
                        // Update flags if any instance is DEMO
                        existing.isDemo = existing.isDemo || isDemo;
                        existing.category = existing.category === 'DEMO' ? 'DEMO' : category;
                    } else if (!lookup[sku]) {
                        lookup[sku] = {
                            SKU: sku,
                            Description: (row.DESCRIPTION || '').replace(/,/g, ' '),
                            SOH: qty,
                            Price: srp,
                            Age: row.AGE,
                            CLASS_NAME: row.CLASS_NAME || 'UNCATEGORIZED',
                            FAMILY: row.FAMILY || '',
                            GROUP_CODE: groupCode,
                            SUBCLASS_CODE: subclassCode,
                            isSerialControlled,
                            isDemo,
                            category,
                            branchType: useAdvancedMode ? (isICenter ? 'iCenter' : 'iStudio') : 'Standard'
                        };
                    }
                });                // Final separation logic (Power Query sequence step 7)
                const forSpp = { spareParts: [], glue: [], tools: [] };
                let sppStats = { glue: 0, tools: 0, spareParts: 0 };
                
                Object.values(lookup).forEach(item => {
                    if (item.SOH > 0) {
                        if (item.isDemo || item.category === 'DEMO') {
                            forDemo.push(item);                        
                        } else if (useAdvancedMode && item.category && item.category.startsWith('SPP_')) {
                            // Separate SPP items by category for iCenter/iStudio branches
                            if (item.category === 'SPP_GLUE_ADHESIVE') {
                                forSpp.glue.push(item);
                                sppStats.glue++;
                            } else if (item.category === 'SPP_TOOLS' || item.category === 'SPP_SLED_FIXTURE') {
                                // Both SPP_TOOLS and legacy SPP_SLED_FIXTURE go to tools section
                                forSpp.tools.push(item);
                                sppStats.tools++;
                            } else {
                                // SPP_OTHER goes to spare parts
                                forSpp.spareParts.push(item);
                                sppStats.spareParts++;
                            }
                        } else {
                            forScan.push(item);
                        }
                    }
                });
                
                // Log SPP categorization summary for advanced branches
                if (useAdvancedMode && (sppStats.glue > 0 || sppStats.tools > 0 || sppStats.spareParts > 0)) {
                    console.log(`SPP Categorization Summary for ${isICenter ? 'iCenter' : 'iStudio'} branch:`);
                    console.log(`  - GLUE/ADHESIVE items: ${sppStats.glue}`);
                    console.log(`  - TOOLS items: ${sppStats.tools}`);  
                    console.log(`  - OTHER SPP items: ${sppStats.spareParts}`);
                    console.log(`  - Enhanced SOH-based detection active`);
                }
                
                return { forScan, forDemo, forSpp, lookup };
            }              
            // Advanced processing functions for iCenter/iStudio branches
            function processAdvancedBranchData(data, isICenter, isIStudio) {
                // Apply Power Query advanced transformations
                let processedData = [...data];
                
                // Sort by FAMILY_NAME descending (Power Query step)
                processedData.sort((a, b) => {
                    const familyA = String(a.FAMILY_NAME || '').toUpperCase();
                    const familyB = String(b.FAMILY_NAME || '').toUpperCase();
                    return familyB.localeCompare(familyA);
                });
                
                // Apply additional filters for WH_CODE (exclude T and EXP)
                processedData = processedData.filter(row => {
                    const whCode = String(row.WH_CODE || '');
                    return !whCode.includes('T') && !whCode.includes('EXP');
                });
                
                // Additional sorting by BRAND_NAME, CLASS_NAME
                processedData.sort((a, b) => {
                    const familyA = String(a.FAMILY_NAME || '').toUpperCase();
                    const familyB = String(b.FAMILY_NAME || '').toUpperCase();
                    const brandA = String(a.BRAND_NAME || '').toUpperCase();
                    const brandB = String(b.BRAND_NAME || '').toUpperCase();
                    const classA = String(a.CLASS_NAME || '').toUpperCase();
                    const classB = String(b.CLASS_NAME || '').toUpperCase();
                    
                    // Family descending, Brand ascending, Class ascending
                    if (familyA !== familyB) return familyB.localeCompare(familyA);
                    if (brandA !== brandB) return brandA.localeCompare(brandB);
                    return classA.localeCompare(classB);
                });
                
                return processedData;
            }              function detectAdvancedDemo(originalSku, desc, family, groupCode, subclassCode, isIStudio) {
                // Enhanced DEMO detection for advanced branches
                
                // Check family field first (highest priority)
                if (family === 'DEMO') {
                    return true;
                }
                
                // Standard DEMO detection fallback (only if family is not DEMO)
                const standardDemo = (
                    !originalSku.startsWith('DLCGZ') && (
                        originalSku.startsWith('D') ||
                        originalSku.includes('DEMO') ||
                        desc.includes('DEMO')
                    )
                );
                
                if (standardDemo) return true;
                
                // For iStudio branches with SPP items, do NOT treat them as DEMO
                // They should be properly categorized as SPP items instead
                if (isIStudio && groupCode.includes('SPP')) {
                    // SPP items should go through proper categorization, not be treated as DEMO
                    return false;
                }
                
                return false;
            }
            
            function applyAdvancedSkuTransformations(sku) {
                // Power Query advanced SKU transformations
                let transformed = sku;
                
                // Replace dots with spaces (standard)
                transformed = transformed.replace(/\./g, ' ');
                
                // Additional transformations for advanced mode
                // Handle special characters and formatting
                transformed = transformed.replace(/,/g, ' ');
                
                // Extract substring after dot if present (Power Query Custom column logic)
                if (sku.includes('.')) {
                    const afterDot = sku.split('.').pop();
                    if (afterDot && afterDot.length > 0) {
                        transformed = afterDot;
                    }
                }
                
                return transformed;
            }            function determineAdvancedCategory(row, isDemo, isIStudio) {
                if (isDemo) return 'DEMO';
                
                const groupCode = String(row.GROUP_CODE || '').toUpperCase();
                const subclassCode = String(row.SUBCLASS_CODE || '').toUpperCase();
                const classCode = String(row.CLASS_CODE || '').toUpperCase();
                const desc = String(row.DESCRIPTION || '').toUpperCase();
                const sku = String(row.SKU || '').toUpperCase();
                
                // Determine if this is an iCenter branch (since isICenter isn't passed to this function)
                const branchType = row.branchType || 'Standard';
                const isICenter = branchType === 'iCenter';
                
                // Enhanced categorization for both iStudio and iCenter SPP items with SOH-based detection
                if ((isIStudio || isICenter) && groupCode.includes('SPP')) {
                    // Enhanced GLUE/ADHESIVE detection using SOH data
                    if (shouldExcludeFromSPP(sku, desc, classCode, subclassCode, 'GLUE_ADHESIVE')) {
                        return 'SPP_GLUE_ADHESIVE';
                    }
                    
                    // Enhanced TOOLS detection using SOH data  
                    if (shouldExcludeFromSPP(sku, desc, classCode, subclassCode, 'TOOLS')) {
                        return 'SPP_TOOLS';
                    }
                    
                    return 'SPP_OTHER';
                }
                
                return 'REGULAR';
            }
              // Enhanced SPP filtering function using SOH data (similar to SMCO Check tool)
            // Supports both iCenter and iStudio branches with CLASS_CODE and SUBCLASS_CODE detection
            function shouldExcludeFromSPP(sku, description, classCode, subclassCode, category) {
                // Enhanced detection criteria based on SOH data
                if (classCode && subclassCode) {
                    // SOH-based detection criteria
                    if (category === 'GLUE_ADHESIVE') {
                        if (classCode === 'SP-GLUE' || 
                            subclassCode === 'ADHS-DP' || 
                            subclassCode === 'ADHS') {
                            console.log(`SPP filtering (SOH): Excluding SKU ${sku} for ${category} - CLASS_CODE: ${classCode}, SUBCLASS_CODE: ${subclassCode}`);
                            return true;
                        }
                    }
                    
                    if (category === 'TOOLS') {
                        if (subclassCode === 'OTH') {
                            console.log(`SPP filtering (SOH): Excluding SKU ${sku} for ${category} - SUBCLASS_CODE: ${subclassCode}`);
                            return true;
                        }
                    }
                }
                
                // Fallback to description-based detection
                const desc = (description || '').toString().toUpperCase();
                
                if (category === 'GLUE_ADHESIVE') {
                    const shouldExclude = desc.includes('GLUE') || desc.includes('ADHESIVE');
                    if (shouldExclude) {
                        console.log(`SPP filtering (fallback): Excluding SKU ${sku} for ${category} - description contains GLUE/ADHESIVE`);
                    }
                    return shouldExclude;
                }
                
                if (category === 'TOOLS') {
                    const shouldExclude = desc.includes('SLED') || desc.includes('FIXTURE') || desc.includes('TOOL');
                    if (shouldExclude) {
                        console.log(`SPP filtering (fallback): Excluding SKU ${sku} for ${category} - description contains TOOLS keywords`);
                    }
                    return shouldExclude;
                }
                
                return false;
            }
            function restoreState(loadedState) {
                resetAppState();
                state = { ...state, ...loadedState, charts: getInitialState().charts };
                
                // Handle SOH updated SKUs - convert array back to Set if needed
                if (loadedState.sohUpdatedSkus) {
                    if (Array.isArray(loadedState.sohUpdatedSkus)) {
                        state.sohUpdatedSkus = new Set(loadedState.sohUpdatedSkus);
                    } else if (loadedState.sohUpdatedSkus instanceof Set) {
                        state.sohUpdatedSkus = loadedState.sohUpdatedSkus;
                    }
                } else {
                    state.sohUpdatedSkus = new Set();
                }
                  const { forScan, forDemo, forSpp, lookup } = processAndSeparateSoh(state.sohData);
                state.sohLookup = lookup;
                state.scannerMaster = forScan;
                state.demoMaster = forDemo.map(item => ({ 
                    ...item, 
                    counted: state.demoCounts[item.SKU]?.qty ?? null,
                    reason: state.demoCounts[item.SKU]?.reason ?? 'DEMO-Manual' 
                }));
                
                // Restore SPP masters if available
                if (forSpp) {
                    state.sppSparePartsMaster = forSpp.spareParts.map(item => ({ 
                        ...item, 
                        counted: state.sppSparePartsCounts[item.SKU]?.qty ?? null,
                        remark: item.remark ?? '',
                        reason: state.sppSparePartsCounts[item.SKU]?.reason ?? 'SPP-Manual' 
                    }));
                    state.sppGlueMaster = forSpp.glue.map(item => ({ 
                        ...item, 
                        counted: state.sppGlueCounts[item.SKU]?.qty ?? null,
                        remark: item.remark ?? '',
                        reason: state.sppGlueCounts[item.SKU]?.reason ?? 'SPP-Manual' 
                    }));                    
                    state.sppToolsMaster = forSpp.tools.map(item => ({ 
                        ...item, 
                        counted: state.sppToolsCounts[item.SKU]?.qty ?? null,
                        remark: item.remark ?? '',
                        reason: state.sppToolsCounts[item.SKU]?.reason ?? 'SPP-Manual' 
                    }));
                    
                    // Populate filter dropdowns
                    populateSppSparePartsFilters();
                    populateSppGlueFilters();
                    populateSppToolsFilters();
                }
                
                rebuildUiFromState();            }
            
            function downloadFile(content, fileName) {
                const blob = (typeof content === 'string') ? new Blob([content], { type: 'text/csv;charset=utf-8;' }) : content;
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            // SPP CSV Export Functions
            
            function exportSppSparePartsTable() {
                if (!state || !state.sppSparePartsMaster || !Array.isArray(state.sppSparePartsMaster) || state.sppSparePartsMaster.length === 0) {
                    showModal("Export Error", "No SPP Spare Parts data available to export.");
                    return;
                }                try {
                    // Sort data alphabetically by SKU for consistent output
                    const sortedData = [...state.sppSparePartsMaster].sort((a, b) => a.SKU.localeCompare(b.SKU));
                    
                    const dataToExport = sortedData.map((item, idx) => ({ 
                        NO: idx + 1, 
                        SKU: item.SKU, 
                        Description: item.Description, 
                        SRP: item.Price, 
                        Age: item.Age, 
                        SOH: item.SOH, 
                        Counted: item.counted, 
                        Diff: item.counted === null ? '' : item.counted - item.SOH,
                        Remark: item.remark || ''
                    }));
                    const csv = Papa.unparse(dataToExport, { header: true });
                    const branchInfo = state.branchCode ? `${state.branchCode}_${state.branchName.replace(/\s+/g, '_')}` : (state.branchName ? state.branchName.replace(/\s+/g, '_') : 'Unknown_Branch');                    const fileName = `${state.countDate || 'Unknown_Date'}_SPP_SpareParts_Count_${branchInfo}.csv`;
                    downloadFile(csv, fileName);
                } catch (error) {
                    showModal("Export Error", `Failed to export SPP Spare Parts data: ${error.message}`);
                }
            }
            
            function exportSppGlueTable() {
                if (!state || !state.sppGlueMaster || !Array.isArray(state.sppGlueMaster) || state.sppGlueMaster.length === 0) {
                    showModal("Export Error", "No SPP Glue/Adhesive data available to export.");
                    return;
                }                try {
                    // Sort data alphabetically by SKU for consistent output
                    const sortedData = [...state.sppGlueMaster].sort((a, b) => a.SKU.localeCompare(b.SKU));
                    
                    const dataToExport = sortedData.map((item, idx) => ({ 
                        NO: idx + 1, 
                        SKU: item.SKU, 
                        Description: item.Description, 
                        SRP: item.Price, 
                        Age: item.Age, 
                        SOH: item.SOH, 
                        Counted: item.counted, 
                        Diff: item.counted === null ? '' : item.counted - item.SOH,
                        Remark: item.remark || ''
                    }));
                    const csv = Papa.unparse(dataToExport, { header: true });
                    const branchInfo = state.branchCode ? `${state.branchCode}_${state.branchName.replace(/\s+/g, '_')}` : (state.branchName ? state.branchName.replace(/\s+/g, '_') : 'Unknown_Branch');                    const fileName = `${state.countDate || 'Unknown_Date'}_SPP_Glue_Count_${branchInfo}.csv`;
                    downloadFile(csv, fileName);
                } catch (error) {
                    showModal("Export Error", `Failed to export SPP Glue/Adhesive data: ${error.message}`);
                }
            }
            
            function exportSppToolsTable() {
                if (!state || !state.sppToolsMaster || !Array.isArray(state.sppToolsMaster) || state.sppToolsMaster.length === 0) {
                    showModal("Export Error", "No SPP Tools data available to export.");
                    return;
                }                try {
                    // Sort data alphabetically by SKU for consistent output
                    const sortedData = [...state.sppToolsMaster].sort((a, b) => a.SKU.localeCompare(b.SKU));
                    
                    const dataToExport = sortedData.map((item, idx) => ({ 
                        NO: idx + 1, 
                        SKU: item.SKU, 
                        Description: item.Description, 
                        SRP: item.Price, 
                        Age: item.Age, 
                        SOH: item.SOH, 
                        Counted: item.counted, 
                        Diff: item.counted === null ? '' : item.counted - item.SOH,
                        Remark: item.remark || ''
                    }));
                    const csv = Papa.unparse(dataToExport, { header: true });
                    const branchInfo = state.branchCode ? `${state.branchCode}_${state.branchName.replace(/\s+/g, '_')}` : (state.branchName ? state.branchName.replace(/\s+/g, '_') : 'Unknown_Branch');
                    const fileName = `${state.countDate || 'Unknown_Date'}_SPP_Tools_Count_${branchInfo}.csv`;
                    downloadFile(csv, fileName);
                } catch (error) {
                    showModal("Export Error", `Failed to export SPP Tools data: ${error.message}`);
                }
            }

            // SPP CSV Import Functions
            async function importSppSparePartsCsv() {
                const fileInput = getEl('importSppSparePartsCsvFile');
                const file = fileInput.files[0];
                if (!file) return;

                showLoader('Importing SPP Spare Parts CSV...');
                try {
                    const csvText = await file.text();
                    const parsedData = Papa.parse(csvText, {
                        header: true,
                        skipEmptyLines: true,
                        dynamicTyping: false
                    });

                    if (parsedData.errors.length > 0) {
                        throw new Error(`CSV parsing error: ${parsedData.errors[0].message}`);
                    }

                    const csvData = parsedData.data;
                    if (!csvData.length) {
                        throw new Error("No data found in CSV file");
                    }

                    const requiredColumns = ['SKU', 'Counted'];
                    const csvColumns = Object.keys(csvData[0]);
                    const missingColumns = requiredColumns.filter(col => !csvColumns.includes(col));
                    
                    if (missingColumns.length > 0) {
                        throw new Error(`Missing required columns: ${missingColumns.join(', ')}`);
                    }

                    let importedCount = 0;
                    let skippedCount = 0;

                    csvData.forEach(row => {
                        const sku = String(row.SKU || '').trim().toUpperCase();
                        const countedValue = row.Counted;
                        const remarkValue = row.Remark || '';
                        
                        if (!sku) {
                            skippedCount++;
                            return;
                        }

                        const sparePartsItem = state.sppSparePartsMaster.find(item => item.SKU === sku);
                        if (!sparePartsItem) {
                            skippedCount++;
                            return;
                        }

                        let counted = null;
                        if (countedValue !== null && countedValue !== undefined && countedValue !== '') {
                            const parsedCount = parseInt(String(countedValue).replace(/,/g, ''), 10);
                            if (!isNaN(parsedCount) && parsedCount >= 0) {
                                counted = parsedCount;
                            }
                        }

                        sparePartsItem.counted = counted;
                        sparePartsItem.remark = remarkValue;
                        
                        if (counted !== null) {
                            if (!state.sppSparePartsCounts) state.sppSparePartsCounts = {};
                            state.sppSparePartsCounts[sku] = { qty: counted, reason: 'SPP-SpareParts-logfile' };
                        } else {
                            if (state.sppSparePartsCounts) delete state.sppSparePartsCounts[sku];
                        }

                        importedCount++;
                    });

                    applySppSparePartsView();
                    updateSppSparePartsSummary();
                    setUnsavedChanges(true);
                    showModal("Import Successful", 
                        `SPP Spare Parts count data imported successfully!\n\n` +
                        `• Imported: ${importedCount} items\n` +
                        `• Skipped: ${skippedCount} items\n\n` +
                        `All imported items are marked with reason "SPP-SpareParts-logfile".`
                    );

                } catch (error) {
                    showModal("Import Error", `Failed to import SPP Spare Parts CSV: ${error.message}`);
                } finally {
                    hideLoader();
                    fileInput.value = '';
                }
            }

            async function importSppGlueCsv() {
                const fileInput = getEl('importSppGlueCsvFile');
                const file = fileInput.files[0];
                if (!file) return;

                showLoader('Importing SPP Glue CSV...');
                try {
                    const csvText = await file.text();
                    const parsedData = Papa.parse(csvText, {
                        header: true,
                        skipEmptyLines: true,
                        dynamicTyping: false
                    });

                    if (parsedData.errors.length > 0) {
                        throw new Error(`CSV parsing error: ${parsedData.errors[0].message}`);
                    }

                    const csvData = parsedData.data;
                    if (!csvData.length) {
                        throw new Error("No data found in CSV file");
                    }

                    const requiredColumns = ['SKU', 'Counted'];
                    const csvColumns = Object.keys(csvData[0]);
                    const missingColumns = requiredColumns.filter(col => !csvColumns.includes(col));
                    
                    if (missingColumns.length > 0) {
                        throw new Error(`Missing required columns: ${missingColumns.join(', ')}`);
                    }

                    let importedCount = 0;
                    let skippedCount = 0;

                    csvData.forEach(row => {
                        const sku = String(row.SKU || '').trim().toUpperCase();
                        const countedValue = row.Counted;
                        const remarkValue = row.Remark || '';
                        
                        if (!sku) {
                            skippedCount++;
                            return;
                        }

                        const glueItem = state.sppGlueMaster.find(item => item.SKU === sku);
                        if (!glueItem) {
                            skippedCount++;
                            return;
                        }

                        let counted = null;
                        if (countedValue !== null && countedValue !== undefined && countedValue !== '') {
                            const parsedCount = parseInt(String(countedValue).replace(/,/g, ''), 10);
                            if (!isNaN(parsedCount) && parsedCount >= 0) {
                                counted = parsedCount;
                            }
                        }

                        glueItem.counted = counted;
                        glueItem.remark = remarkValue;
                        
                        if (counted !== null) {
                            if (!state.sppGlueCounts) state.sppGlueCounts = {};
                            state.sppGlueCounts[sku] = { qty: counted, reason: 'SPP-Glue-logfile' };
                        } else {
                            if (state.sppGlueCounts) delete state.sppGlueCounts[sku];
                        }

                        importedCount++;
                    });

                    applySppGlueView();
                    updateSppGlueSummary();
                    setUnsavedChanges(true);
                    showModal("Import Successful", 
                        `SPP Glue count data imported successfully!\n\n` +
                        `• Imported: ${importedCount} items\n` +
                        `• Skipped: ${skippedCount} items\n\n` +
                        `All imported items are marked with reason "SPP-Glue-logfile".`
                    );

                } catch (error) {
                    showModal("Import Error", `Failed to import SPP Glue CSV: ${error.message}`);
                } finally {
                    hideLoader();
                    fileInput.value = '';
                }
            }

            async function importSppToolsCsv() {
                const fileInput = getEl('importSppToolsCsvFile');
                const file = fileInput.files[0];
                if (!file) return;

                showLoader('Importing SPP Tools CSV...');
                try {
                    const csvText = await file.text();
                    const parsedData = Papa.parse(csvText, {
                        header: true,
                        skipEmptyLines: true,
                        dynamicTyping: false
                    });

                    if (parsedData.errors.length > 0) {
                        throw new Error(`CSV parsing error: ${parsedData.errors[0].message}`);
                    }

                    const csvData = parsedData.data;
                    if (!csvData.length) {
                        throw new Error("No data found in CSV file");
                    }

                    const requiredColumns = ['SKU', 'Counted'];
                    const csvColumns = Object.keys(csvData[0]);
                    const missingColumns = requiredColumns.filter(col => !csvColumns.includes(col));
                    
                    if (missingColumns.length > 0) {
                        throw new Error(`Missing required columns: ${missingColumns.join(', ')}`);
                    }

                    let importedCount = 0;
                    let skippedCount = 0;

                    csvData.forEach(row => {
                        const sku = String(row.SKU || '').trim().toUpperCase();
                        const countedValue = row.Counted;
                        const remarkValue = row.Remark || '';
                        
                        if (!sku) {
                            skippedCount++;
                            return;
                        }

                        const toolsItem = state.sppToolsMaster.find(item => item.SKU === sku);
                        if (!toolsItem) {
                            skippedCount++;
                            return;
                        }

                        let counted = null;
                        if (countedValue !== null && countedValue !== undefined && countedValue !== '') {
                            const parsedCount = parseInt(String(countedValue).replace(/,/g, ''), 10);
                            if (!isNaN(parsedCount) && parsedCount >= 0) {
                                counted = parsedCount;
                            }
                        }

                        toolsItem.counted = counted;
                        toolsItem.remark = remarkValue;
                        
                        if (counted !== null) {
                            if (!state.sppToolsCounts) state.sppToolsCounts = {};
                            state.sppToolsCounts[sku] = { qty: counted, reason: 'SPP-Tools-logfile' };
                        } else {
                            if (state.sppToolsCounts) delete state.sppToolsCounts[sku];
                        }

                        importedCount++;
                    });

                    applySppToolsView();
                    updateSppToolsSummary();
                    setUnsavedChanges(true);
                    showModal("Import Successful", 
                        `SPP Tools count data imported successfully!\n\n` +
                        `• Imported: ${importedCount} items\n` +
                        `• Skipped: ${skippedCount} items\n\n` +
                        `All imported items are marked with reason "SPP-Tools-logfile".`
                    );
                } catch (error) {
                    showModal("Import Error", `Failed to import SPP Tools CSV: ${error.message}`);
                } finally {
                    hideLoader();
                    fileInput.value = '';
                }
            }
              function rebuildUiFromState() {
                if (state.sohData.length > 0) {
                    getEl('workspace-container').classList.remove('hidden');
                    getEl('upload-container').classList.add('hidden');
                    getEl('downloadMasterForScan').disabled = false;
                    updateInfoBox();
                    applyDemoView();                    // Show SPP tab if SPP data is available
                    if (state.sppSparePartsMaster.length > 0 || state.sppGlueMaster.length > 0 || state.sppToolsMaster.length > 0) {
                        applySppSparePartsView();
                        applySppGlueView();
                        applySppToolsView();
                        
                        // Show consolidated SPP tab in main navigation when data is available
                        getEl('main-tab-spp').classList.remove('hidden');
                    } else {
                        // Hide SPP tab in main navigation when no data is available
                        getEl('main-tab-spp').classList.add('hidden');
                    }
                    
                    if (state.netDiffData.length > 0) {
                        renderFirstCountSummary();
                        getEl('step2-results').classList.remove('hidden');
                        getEl('finalizeFromFirstCount').disabled = false;
                        getEl('generateRecountMasterFile').disabled = false;
                        getEl('latestSohFile').disabled = false;
                    }                    if (state.reconciledData.length > 0) {
                        applyFinalReportView();
                        renderFinalReportCharts();
                        // Final report container visibility will be controlled by switchMainTab function
                    }
                    switchMainTab('workflow');
                } else {
                    resetUI();
                }
            }                
            function switchMainTab(tabName) {
                // Hide all panels
                const allPanels = ['demo', 'workflow', 'spp'];
                allPanels.forEach(panelName => {
                    const panel = getEl(`main-panel-${panelName}`);
                    if (panel) panel.classList.add('hidden');
                });

                // Remove active class from all tabs
                const allTabs = ['demo', 'workflow', 'spp'];
                allTabs.forEach(tabName => {
                    const tab = getEl(`main-tab-${tabName}`);
                    if (tab) tab.classList.remove('active');
                });

                // Show selected panel and activate tab
                const selectedPanel = getEl(`main-panel-${tabName}`);
                const selectedTab = getEl(`main-tab-${tabName}`);
                
                if (selectedPanel) selectedPanel.classList.remove('hidden');
                if (selectedTab) selectedTab.classList.add('active');
                
                // Hide final report container and dashboard except on "workflow" (ตรวจนับสินค้าขาย) tab
                const finalReportContainer = getEl('final-report-container');
                if (finalReportContainer) {
                    if (tabName === 'workflow') {
                        // Only show final report on workflow tab if data exists
                        if (state.reconciledData && state.reconciledData.length > 0) {
                            finalReportContainer.classList.remove('hidden');
                        }
                    } else {
                        // Hide final report on other tabs to reduce resource usage
                        finalReportContainer.classList.add('hidden');
                    }
                }
            }

            function changeWorkflowTab(tabIndex) {
                document.querySelectorAll('.workflow-step').forEach(div => div.classList.add('hidden'));
                getEl(`wf-step${tabIndex}`).classList.remove('hidden');
                document.querySelectorAll('#wf-step-tabs .tab-button').forEach(btn => btn.classList.remove('active'));
                getEl(`wf-tab-btn-${tabIndex}`).classList.add('active');
            }            
            function handleSort(sortKey, column, applyViewFn) {
                const sortState = state[sortKey];
                if (sortState.column === column) {
                    sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    sortState.column = column;
                    sortState.direction = 'asc';
                }
                applyViewFn();
                setUnsavedChanges(true);
            }
            
            // Dynamic filter population functions
            function populateDemoFilters() {
                populateGroupCodeFilter('demoGroupCodeFilter', state.demoMaster);
                populateSubclassFilter('demoSubclassFilter', state.demoMaster);
            }
            
            function populateFinalReportFilters() {
                populateGroupCodeFilter('finalGroupCodeFilter', state.reconciledData);
                populateSubclassFilter('finalSubclassFilter', state.reconciledData);
            }
            
            function populateGroupCodeFilter(selectId, data) {
                const select = getEl(selectId);
                if (!select || !data) return;
                
                // Get unique GROUP_CODE values
                const groupCodes = [...new Set(data.map(item => item.GROUP_CODE).filter(Boolean))].sort();
                
                // Store current selection
                const currentValue = select.value;
                
                // Clear and repopulate
                select.innerHTML = '<option value="all">ทุก GROUP_CODE</option>';
                groupCodes.forEach(code => {
                    const option = document.createElement('option');
                    option.value = code;
                    option.textContent = code;
                    select.appendChild(option);
                });
                
                // Restore selection if still valid
                if (groupCodes.includes(currentValue)) {
                    select.value = currentValue;
                }
            }
            
            function populateSubclassFilter(selectId, data) {
                const select = getEl(selectId);
                if (!select || !data) return;
                
                // Get unique SUBCLASS_CODE values
                const subclassCodes = [...new Set(data.map(item => item.SUBCLASS_CODE).filter(Boolean))].sort();
                
                // Store current selection
                const currentValue = select.value;
                
                // Clear and repopulate
                select.innerHTML = '<option value="all">ทุก SUBCLASS</option>';
                subclassCodes.forEach(code => {
                    const option = document.createElement('option');
                    option.value = code;
                    option.textContent = code;
                    select.appendChild(option);
                });
                  // Restore selection if still valid
                if (subclassCodes.includes(currentValue)) {
                    select.value = currentValue;
                }
            }
              function applyDemoView() {
                if (state.demoMaster.length === 0) {
                    getEl('demo-count-container').innerHTML = '<p class="p-6 text-center text-slate-500">No DEMO items found.</p>';
                    updateDemoSummary();
                    return;
                }
                
                // Populate filter dropdowns dynamically
                populateDemoFilters();
                
                const searchValue = getEl('demoSearchInput')?.value?.toUpperCase() || '';
                const filterValue = getEl('demoFilterSelect')?.value || 'all';
                const groupCodeFilter = getEl('demoGroupCodeFilter')?.value || 'all';
                const ageFilter = getEl('demoAgeFilter')?.value || 'all';
                const subclassFilter = getEl('demoSubclassFilter')?.value || 'all';
                  let dataView = state.demoMaster.filter(item => {
                    // Text search filter
                    if (!(item.SKU.toUpperCase().includes(searchValue) || item.Description.toUpperCase().includes(searchValue))) return false;
                    
                    // Count status filter
                    const diff = (item.counted === null) ? null : item.counted - item.SOH;
                    if (filterValue !== 'all') {
                        if (filterValue === 'uncounted' && item.counted !== null) return false;
                        if (filterValue === 'discrepancy' && (diff === null || diff === 0)) return false;
                        if (filterValue === 'matched' && (diff === null || diff !== 0)) return false;
                    }
                    
                    // GROUP_CODE filter
                    if (groupCodeFilter !== 'all' && item.GROUP_CODE !== groupCodeFilter) return false;
                    
                    // Age filter
                    if (ageFilter !== 'all') {
                        const age = parseInt(item.Age) || 0;
                        if (ageFilter === 'new' && age >= 300) return false;
                        if (ageFilter === 'old' && age < 300) return false;
                    }
                    
                    // SUBCLASS filter
                    if (subclassFilter !== 'all' && item.SUBCLASS_CODE !== subclassFilter) return false;
                    
                    return true;
                });
                const { column, direction } = state.demoSort;
                dataView.sort((a, b) => {
                    let valA, valB;
                    
                    // Handle special calculated field "diff"
                    if (column === 'diff') {
                        valA = (a.counted === null) ? null : a.counted - a.SOH;
                        valB = (b.counted === null) ? null : b.counted - b.SOH;
                    } else if (column === 'counted') {
                        valA = a.counted;
                        valB = b.counted;
                    } else {
                        valA = a[column];
                        valB = b[column];
                    }
                    
                    // Handle null/undefined values
                    if (valA === null || valA === undefined) return 1;
                    if (valB === null || valB === undefined) return -1;
                    
                    // Sort by data type
                    if (typeof valA === 'string') {
                        return direction === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                    }
                    return direction === 'asc' ? valA - valB : valB - valA;
                });
                renderDemoCountTable(dataView);
                updateDemoSummary();
            }                function renderDemoCountTable(data) {
                const container = getEl('demo-count-container');
                const cardsContainer = getEl('demo-count-cards');
                
                // Desktop table view
                const headers = `<thead><tr>
                    <th class="p-2 text-center w-12">NO.</th>
                    <th class="p-2 text-left" data-sort-by="SKU">SKU<span class="sort-indicator"></span></th>
                    <th class="p-2 text-left" data-sort-by="Description">Description<span class="sort-indicator"></span></th>
                    <th class="p-2 text-center" data-sort-by="Price">SRP<span class="sort-indicator"></span></th>
                    <th class="p-2 text-center" data-sort-by="Age">Age<span class="sort-indicator"></span></th>
                    <th class="p-2 text-center" data-sort-by="SOH">SOH<span class="sort-indicator"></span></th>
                    <th class="p-2 text-center" data-sort-by="counted">Counted<span class="sort-indicator"></span></th>
                    <th class="p-2 text-center" data-sort-by="diff">Diff<span class="sort-indicator"></span></th>
                    <th class="p-2 text-center" data-sort-by="remark">Remark<span class="sort-indicator"></span></th>
                </tr></thead>`;
                const body = data.length > 0 ? data.map((item, idx) => renderDemoTableRow(item, idx)).join('') : `<tr><td colspan="9" class="text-center p-6 text-slate-500">No items match filter.</td></tr>`;
                container.innerHTML = `<table class="w-full text-sm">${headers}<tbody>${body}</tbody></table>`;
                
                // Mobile card view
                if (data.length > 0) {
                    cardsContainer.innerHTML = data.map((item, idx) => renderDemoCard(item, idx)).join('');
                } else {
                    cardsContainer.innerHTML = '<p class="text-center p-6 text-slate-500">No items match filter.</p>';
                }
                
                // Update sort indicators with colors
                const sortingTh = container.querySelector(`th[data-sort-by="${state.demoSort.column}"]`);
                if (sortingTh) {
                    const indicator = sortingTh.querySelector('.sort-indicator');
                    indicator.textContent = state.demoSort.direction === 'asc' ? '▲' : '▼';
                    // Add color: green for ascending, red for descending
                    indicator.style.color = state.demoSort.direction === 'asc' ? '#22c55e' : '#ef4444';
                }
            }            
            function renderDemoTableRow(item, idx) {
                const diff = (item.counted === null) ? null : item.counted - item.SOH;
                const diffText = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
                let { rowClass } = getRowVisuals(diff, true);
                
                // Enhanced display for advanced categorization
                const categoryBadge = getCategoryBadge(item);
                const branchTypeBadge = getBranchTypeBadge(item);
                
                return `<tr class="border-b border-slate-200 transition-colors duration-200 ${rowClass}" data-sku="${item.SKU}">
                    <td class="p-2 text-center">${idx + 1}</td>
                    <td class="p-2 font-medium text-slate-700">
                        ${item.SKU}
                        ${branchTypeBadge}
                    </td>
                    <td class="p-2 text-slate-600">
                        ${item.Description}
                        ${categoryBadge}
                    </td>
                    <td class="p-2 text-center text-slate-600">${item.Price ?? 0}</td>
                    <td class="p-2 text-center text-slate-600">${item.Age || 'N/A'}</td>
                    <td class="p-2 text-center text-slate-600">${item.SOH}</td>
                    <td class="p-2 text-center text-slate-600"><input type="number" value="${item.counted ?? 0}" class="w-full text-center p-1.5 border border-slate-300 rounded-md bg-white"/></td>
                    <td class="p-2 text-center font-bold diff-cell ${getDiffColorClass(diff)}">${diffText}</td>
                    <td class="p-2 text-center"><input type="text" value="${item.remark ?? ''}" class="w-full text-center p-1.5 border border-slate-300 rounded-md bg-white"/></td>
                    </tr>`;            }
    
                function renderDemoCard(item, idx) {
                    const diff = (item.counted === null) ? null : item.counted - item.SOH;
                    const diffText = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
                    const diffClass = diff === null ? 'diff-null' : diff > 0 ? 'diff-positive' : diff < 0 ? 'diff-negative' : 'diff-zero';
                    
                    const categoryBadge = getCategoryBadge(item);
                    const branchTypeBadge = getBranchTypeBadge(item);
                    
                    return `
                        <div class="stock-card ${diffClass}" data-sku="${item.SKU}">
                            <div class="stock-card-header">
                                <span class="stock-card-number">#${idx + 1}</span>
                                <span class="stock-card-sku">${item.SKU}</span>
                                ${branchTypeBadge}
                            </div>
                            
                            <div class="stock-card-description">
                                ${item.Description}
                            </div>
                            
                            <div class="stock-card-meta">
                                <div class="stock-card-field">
                                    <label>SRP</label>
                                    <span class="stock-card-value">${item.Price ?? 0}</span>
                                </div>
                                <div class="stock-card-field">
                                    <label>Age</label>
                                    <span class="stock-card-value">${item.Age || 'N/A'}</span>
                                </div>
                                <div class="stock-card-field">
                                    <label>SOH</label>
                                    <span class="stock-card-value">${item.SOH}</span>
                                </div>
                                <div class="stock-card-field">
                                    <label>Diff</label>
                                    <span class="stock-card-value font-bold ${getDiffColorClass(diff)}">${diffText}</span>
                                </div>
                            </div>
                            
                            <div class="stock-card-controls">
                                <div class="stock-card-field">
                                    <label>Counted</label>
                                    <input type="number" value="${item.counted ?? 0}" 
                                           class="stock-card-input" 
                                           onchange="updateDemoCount('${item.SKU}', this.value)" />
                                </div>
                                <div class="stock-card-field">
                                    <label>Remark</label>
                                    <input type="text" value="${item.remark ?? ''}" 
                                           class="stock-card-input" 
                                           onchange="updateDemoRemark('${item.SKU}', this.value)" />
                                </div>
                            </div>
                        </div>
                    `;
                }

            function updateDemoSummary() {
                const totalSOH = state.demoMaster.reduce((sum, item) => sum + item.SOH, 0);
                const totalSOHPrice = state.demoMaster.reduce((sum, item) => sum + (item.SOH * (item.Price ?? 0)), 0);
                const countedSKUs = Object.values(state.demoCounts).filter(c => c.qty !== null).length;
                const countedSOHValue = state.demoMaster.reduce((sum, item) => {
                    const counted = state.demoCounts[item.SKU]?.qty;
                    return sum + ((counted ?? 0) * (item.Price ?? 0));
                }, 0);
                const countedSOH = state.demoMaster.reduce((sum, item) => {
                    const counted = state.demoCounts[item.SKU]?.qty;
                    return sum + (counted ?? 0);
                }, 0);
                const diffItems = state.demoMaster.filter(item => { const countInfo = state.demoCounts[item.SKU]; return countInfo && countInfo.qty !== null && countInfo.qty !== item.SOH; }).length;
                getEl('demo-summary').innerHTML = `
                    <div class="grid grid-cols-2 gap-x-4 gap-y-2">
                        <div class="flex justify-between gap-2"><span>Total DEMO SOH:</span><span class="font-bold">${formatNumber(totalSOH)}</span></div>
                        <div class="flex justify-between gap-2"><span>Total DEMO SOH Value:</span><span class="font-bold text-blue-600">${formatNumber(totalSOHPrice)}</span></div>
                        <div class="flex justify-between gap-2"><span>Counted DEMO SOH:</span><span class="font-bold text-green-600">${formatNumber(countedSOH)}</span></div>
                        <div class="flex justify-between gap-2"><span>Counted DEMO SOH Value:</span><span class="font-bold text-green-600">${formatNumber(countedSOHValue)}</span></div>
                        <div class="flex justify-between gap-2"><span>Total DEMO SKUs:</span><span class="font-bold">${formatNumber(state.demoMaster.length)}</span></div>
                        <div class="flex justify-between gap-2"><span>Counted SKUs:</span><span class="font-bold text-green-600">${countedSKUs}</span></div>
                        <div class="flex justify-between gap-2 col-span-2"><span>Discrepancies:</span><span class="font-bold text-red-600">${diffItems}</span></div>
                    </div>
                `;
            }

            function updateDemoCount(sku, value) {
                const item = state.demoMaster.find(i => i.SKU === sku);
                if (!item) return;
                const intValue = value === '' ? null : parseInt(value, 10);
                item.counted = isNaN(intValue) ? null : intValue;                if (intValue === null) delete state.demoCounts[sku];
                else state.demoCounts[sku] = { qty: intValue, reason: 'DEMO-Manual' };
                if (state.reconciledData.length > 0) {
                    const reportItem = state.reconciledData.find(i => i.SKU === sku);
                    if (reportItem) {
                        const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(sku);
                        reportItem.Recount = intValue ?? 0;
                        reportItem.FinalDiff = reportItem.Recount - reportItem.SOH;
                        reportItem.ReasonFinal = wasSohUpdated ? 'SOHupdated-DEMO-Manual' : 'DEMO-Manual';
                        applyFinalReportView();
                        renderFinalReportCharts();
                    }                }                
                // Update desktop table row display
                const row = getEl('demo-count-container').querySelector(`tr[data-sku="${sku}"]`);
                if (row) {
                    const diff = item.counted === null ? null : item.counted - item.SOH;
                    row.querySelector('.diff-cell').textContent = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
                    row.querySelector('.diff-cell').className = `p-2 text-center font-bold diff-cell ${getDiffColorClass(diff)}`;
                    updateTableRowVisuals(row, diff, true);
                }
                
                // Update mobile card display
                const card = getEl('demo-count-cards').querySelector(`[data-sku="${sku}"]`);
                if (card) {
                    const diff = item.counted === null ? null : item.counted - item.SOH;
                    const diffText = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
                    const diffClass = diff === null ? 'diff-null' : diff > 0 ? 'diff-positive' : diff < 0 ? 'diff-negative' : 'diff-zero';
                    
                    // Update card class
                    card.className = `stock-card ${diffClass}`;
                    
                    // Update diff value
                    const diffValueEl = card.querySelector('.stock-card-field:nth-of-type(4) .stock-card-value');
                    if (diffValueEl) {
                        diffValueEl.textContent = diffText;
                        diffValueEl.className = `stock-card-value font-bold ${getDiffColorClass(diff)}`;
                    }
                    
                    // Update input value
                    const countInput = card.querySelector('input[type="number"]');
                    if (countInput) countInput.value = item.counted ?? 0;
                }
                
                updateDemoSummary();
                updateFinalReportSummary();
                setUnsavedChanges(true);
            }            function exportDemoTable() {
                // Sort data alphabetically by SKU for consistent output
                const sortedData = [...state.demoMaster].sort((a, b) => a.SKU.localeCompare(b.SKU));
                
                const dataToExport = sortedData.map((item, idx) => ({ 
                    NO: idx + 1, 
                    SKU: item.SKU, 
                    Description: item.Description, 
                    SRP: item.Price, 
                    Age: item.Age, 
                    SOH: item.SOH, 
                    Counted: item.counted, 
                    Diff: item.counted === null ? '' : item.counted - item.SOH,
                    Remark: item.remark || '',
                    Flag: item.isDemo ? 'DEMO' : 'NONE'
                }));
                const csv = Papa.unparse(dataToExport, { header: true });
                const branchInfo = state.branchCode ? `${state.branchCode}_${state.branchName.replace(/\s+/g, '_')}` : state.branchName.replace(/\s+/g, '_');
                downloadFile(csv, `${state.countDate}_DEMO_Count_${branchInfo}.csv`);
            }

            async function importDemoCountCsv() {
                const fileInput = getEl('importDemoCsvFile');
                const file = fileInput.files[0];
                if (!file) return;

                showLoader('Importing DEMO Count CSV...');
                try {
                    const csvText = await file.text();
                    const parsedData = Papa.parse(csvText, {
                        header: true,
                        skipEmptyLines: true,
                        dynamicTyping: false // Keep as strings to handle properly
                    });

                    if (parsedData.errors.length > 0) {
                        throw new Error(`CSV parsing error: ${parsedData.errors[0].message}`);
                    }

                    const csvData = parsedData.data;
                    if (!csvData.length) {
                        throw new Error("No data found in CSV file");
                    }                    // Validate CSV structure - should match export format
                    const requiredColumns = ['SKU', 'Counted'];
                    const csvColumns = Object.keys(csvData[0]);
                    const missingColumns = requiredColumns.filter(col => !csvColumns.includes(col));
                    
                    if (missingColumns.length > 0) {
                        throw new Error(`Missing required columns: ${missingColumns.join(', ')}`);
                    }

                    let importedCount = 0;
                    let skippedCount = 0;

                    // Process each row from CSV
                    csvData.forEach(row => {
                        const sku = String(row.SKU || '').trim().toUpperCase();
                        const countedValue = row.Counted;
                        const remarkValue = String(row.Remark || '').trim();
                        
                        if (!sku) {
                            skippedCount++;
                            return;
                        }

                        // Find matching DEMO item
                        const demoItem = state.demoMaster.find(item => item.SKU === sku);
                        if (!demoItem) {
                            skippedCount++;
                            return;
                        }

                        // Parse counted value
                        let counted = null;
                        if (countedValue !== null && countedValue !== undefined && countedValue !== '') {
                            const parsedCount = parseInt(String(countedValue).replace(/,/g, ''), 10);
                            if (!isNaN(parsedCount) && parsedCount >= 0) {
                                counted = parsedCount;
                            }
                        }

                        // Update demo item
                        demoItem.counted = counted;
                        demoItem.remark = remarkValue; // Import remark data
                        
                        // Update state.demoCounts with DEMO-logfile reason
                        if (counted !== null) {
                            state.demoCounts[sku] = { qty: counted, reason: 'DEMO-logfile' };
                        } else {
                            delete state.demoCounts[sku];
                        }

                        // Update final report if it exists
                        if (state.reconciledData.length > 0) {
                            const reportItem = state.reconciledData.find(i => i.SKU === sku);
                            if (reportItem && reportItem.isDemo) {
                                const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(sku);
                                reportItem.Recount = counted ?? 0;
                                reportItem.FinalDiff = reportItem.Recount - reportItem.SOH;
                                reportItem.ReasonFinal = wasSohUpdated ? 'SOHupdated-DEMO-logfile' : 'DEMO-logfile';
                            }
                        }

                        importedCount++;
                    });

                    // Refresh UI
                    applyDemoView();
                    updateDemoSummary();
                    if (state.reconciledData.length > 0) {
                        applyFinalReportView();
                        updateFinalReportSummary();
                        renderFinalReportCharts();
                    }
                    
                    setUnsavedChanges(true);
                    showModal("Import Successful", 
                        `DEMO count data imported successfully!\n\n` +
                        `• Imported: ${importedCount} items\n` +
                        `• Skipped: ${skippedCount} items\n\n` +
                        `All imported items are marked with reason "DEMO-logfile".`
                    );

                } catch (error) {
                    showModal("Import Error", `Failed to import DEMO count CSV: ${error.message}`);
                } finally {
                    hideLoader();
                    fileInput.value = ''; // Clear the file input
                }
            }
            function downloadMasterForScan() {
                // Exclude DEMO items using processed flags
                const scanRows = Object.values(state.sohLookup).filter(item => !item.isDemo && item.SOH > 0);
                const rowsForCsv = scanRows.map(item => [item.SKU, item.Description, item.Price, item.Age, item.SOH]);
                
                // Use new file naming convention: Master_branchcode_date.csv
                const branchInfo = state.branchCode ? `${state.branchCode}_${state.countDate}` : `${state.branchName.replace(/\s+/g, '_')}_${state.countDate}`;
                const fileName = `Master_${branchInfo}.csv`;
                downloadFile(Papa.unparse(rowsForCsv, { header: false }), fileName);
            }
            
            async function processFirstCount() {
                showLoader('Processing First Count...');
                try {
                    const logFiles = getEl('firstScanLogfile').files;
                    const masterFile = getEl('firstMasterFile').files[0];
                    
                    if (!logFiles.length && !masterFile) {
                        throw new Error("Please upload at least one file (Logfile or Master.csv) for the first count.");
                    }
                    
                    if (!state.sohData.length) {
                        throw new Error("Please upload SOH data first.");
                    }
                    
                    let scanCounts = [];
                    
                    // Process Logfile(s) if uploaded
                    if (logFiles.length > 0) {
                        const logfileData = await (async function(files){ 
                            const p = Array.from(files).map(f => new Promise((res, rej) => { 
                                Papa.parse(f, { 
                                    skipEmptyLines: true, 
                                    complete: r => { 
                                        const d = r.data.map(row => { 
                                            if(!row || row.length < 3 || !row[2]) return null; 
                                            const sku = String(row[2]).trim(); 
                                            const qty = parseInt(String(row[4] ?? 1).replace(/,/g,''), 10); 
                                            return {sku, qty: isNaN(qty) ? 1: qty};
                                        }).filter(Boolean); 
                                        res(d); 
                                    }, 
                                    error: rej
                                }); 
                            })); 
                            return Promise.all(p).then(r => r.flat()); 
                        })(logFiles);
                        scanCounts = scanCounts.concat(logfileData);
                    }
                    
                    // Process Master.csv if uploaded
                    if (masterFile) {
                        const masterData = await new Promise((resolve, reject) => {
                            Papa.parse(masterFile, {
                                skipEmptyLines: true,
                                complete: result => {
                                    try {
                                        const data = result.data.map(row => {
                                            if (!row || row.length < 6 || !row[0]) return null;
                                            const sku = String(row[0]).trim(); // Column 1: Part No.
                                            const qty = parseInt(String(row[5] || '0').replace(/,/g, ''), 10); // Column 6: Actual Qty
                                            // Only include items that were actually counted (qty > 0)
                                            if (isNaN(qty) || qty <= 0) return null;
                                            return { sku, qty };
                                        }).filter(Boolean);
                                        resolve(data);
                                    } catch (error) {
                                        reject(error);
                                    }
                                },
                                error: reject
                            });
                        });
                        scanCounts = scanCounts.concat(masterData);
                    }                    const processedCounts = {};
                    for(const item of scanCounts){ 
                        const {sku, qty} = item; 
                        const isSerial = state.sohLookup[sku] ? state.sohLookup[sku].isSerialControlled : false; 
                        if(isSerial){ 
                            if(!processedCounts[sku]) processedCounts[sku] = {qty: 1, reason: 'Scan'};
                        } else { 
                            const currentQty = processedCounts[sku] ? processedCounts[sku].qty : 0; 
                            processedCounts[sku] = {qty: currentQty + qty, reason: 'Scan'};
                        }
                    }
                    const combinedCounts = { ...processedCounts, ...state.demoCounts };
                    const netDiffMap = new Map(Object.values(state.sohLookup).filter(item => item.SOH > 0).map(item => [item.SKU, { ...item, Scan1: 0, Reason1: '' }]));
                    for (const [sku, data] of Object.entries(combinedCounts)) {
                        const entry = netDiffMap.get(sku);
                        if (entry) { entry.Scan1 = data.qty; entry.Reason1 = data.reason; }
                    }                    state.netDiffData = Array.from(netDiffMap.values()).map(item => {
                        // Check if this item already has sales data in reconciledData
                        const existingReconciledItem = state.reconciledData.find(r => r.SKU === item.SKU);
                        const hasSalesData = existingReconciledItem && 
                            existingReconciledItem.ReasonFinal && 
                            existingReconciledItem.ReasonFinal.includes('Sales:');
                        
                        if (hasSalesData) {
                            // Preserve sales data and add first count on top
                            const salesMatch = existingReconciledItem.ReasonFinal.match(/Sales: (\d+) units added/);
                            const salesQty = salesMatch ? parseInt(salesMatch[1], 10) : 0;
                            
                            return {
                                ...item, 
                                Counted1: item.Scan1,
                                Diff1: item.Scan1 - item.SOH, 
                                Recount: item.Scan1 + salesQty, 
                                FinalDiff: (item.Scan1 + salesQty) - item.SOH, 
                                ReasonFinal: item.Reason1 ? `${item.Reason1} + ${existingReconciledItem.ReasonFinal}` : existingReconciledItem.ReasonFinal, 
                                Remark: existingReconciledItem.Remark || ''
                            };
                        } else {
                            // Normal processing without existing sales data
                            return {
                                ...item, 
                                Counted1: item.Scan1,
                                Diff1: item.Scan1 - item.SOH, 
                                Recount: item.Scan1, 
                                FinalDiff: item.Scan1 - item.SOH, 
                                ReasonFinal: item.Reason1, 
                                Remark: '' 
                            };
                        }
                    });
                    renderFirstCountSummary();
                    getEl('step2-results').classList.remove('hidden');
                    getEl('finalizeFromFirstCount').disabled = false;
                    getEl('generateRecountMasterFile').disabled = false;
                    getEl('latestSohFile').disabled = false;
                    setUnsavedChanges(true);
                    
                    // Generate success message showing what files were processed
                    let processedFiles = [];
                    if (logFiles.length > 0) processedFiles.push(`${logFiles.length} Logfile(s)`);
                    if (masterFile) processedFiles.push('Master.csv');
                    const message = `First count processed successfully using: ${processedFiles.join(' and ')}.`;
                    
                    showModal("Success", message);
                } catch (error) {
                    showModal("Error", `Processing failed: ${error.message}`);
                } finally {
                    hideLoader();
                }
            }
            
            function renderFirstCountSummary() {
                const summary = state.netDiffData.reduce((acc, item) => { acc.totalSOH += item.SOH; if (item.Scan1 !== 0 || item.Reason1) acc.countedSOH += item.SOH; return acc; }, { totalSOH: 0, countedSOH: 0 });
                const uncountedSOH = summary.totalSOH - summary.countedSOH;
                getEl('netdiff-summary-container').innerHTML = `<div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center"><div class="p-4 bg-blue-100 rounded-lg"><p class="font-medium text-blue-800">Total SOH</p><p class="text-3xl font-bold text-blue-600 mt-1">${formatNumber(summary.totalSOH)}</p></div><div class="p-4 bg-green-100 rounded-lg"><p class="font-medium text-green-800">Counted SOH</p><p class="text-3xl font-bold text-green-600 mt-1">${formatNumber(summary.countedSOH)}</p></div><div class="p-4 bg-red-100 rounded-lg"><p class="font-medium text-red-800">Uncounted SOH</p><p class="text-3xl font-bold text-red-600 mt-1">${formatNumber(uncountedSOH)}</p></div></div>`;
            }            
            function finalizeFromFirstCount() {
                if (!state.netDiffData.length) return showModal("Warning", "Please process the first count (Step 2).");
                // --- Patch: Sync latest DEMO counts before finalizing ---
                state.netDiffData.forEach(item => {
                    if (item.isDemo) {
                        // Check if item has been manually edited in final table
                        const existingReconciledItem = state.reconciledData.find(r => r.SKU === item.SKU);
                        const hasManualEdit = existingReconciledItem && existingReconciledItem.ReasonFinal === 'Manual Edit';
                        
                        if (hasManualEdit) {
                            // Skip updating - preserve manual edit
                            return;
                        }                        
                        const demoCount = state.demoCounts[item.SKU];
                        const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(item.SKU);                        if (demoCount && typeof demoCount.qty === 'number') {
                            item.Recount = demoCount.qty;
                            item.FinalDiff = demoCount.qty - item.SOH;
                            const baseReason = demoCount.reason || 'DEMO-Manual';
                            item.ReasonFinal = wasSohUpdated ? `SOHupdated-${baseReason}` : baseReason;                        } else {
                            item.Recount = 0;
                            item.FinalDiff = -item.SOH;
                            item.ReasonFinal = wasSohUpdated ? 'SOHupdated-DEMO-N/A' : 'DEMO-N/A';
                        }
                    }
                });
                state.reconciledData = state.netDiffData.map(item => {
                    // Check if item already has sales data in reconciledData
                    const existingReconciledItem = state.reconciledData.find(r => r.SKU === item.SKU);
                    const hasSalesData = existingReconciledItem && 
                        existingReconciledItem.ReasonFinal && 
                        existingReconciledItem.ReasonFinal.includes('Sales:');
                    
                    if (hasSalesData) {
                        // Preserve sales data from existing reconciledData
                        return {                        ...item,
                            Recount: existingReconciledItem.Recount,
                            FinalDiff: existingReconciledItem.FinalDiff,
                            ReasonFinal: item.ReasonFinal ? `${item.ReasonFinal} + ${existingReconciledItem.ReasonFinal}` : existingReconciledItem.ReasonFinal,
                            Remark: existingReconciledItem.Remark || ''
                        };
                    } else {
                        // No existing sales data - use item as is
                        return {...item};
                    }
                });
                applyFinalReportView();
                renderFinalReportCharts();
                
                // Only show final report if on workflow tab
                const currentTab = document.querySelector('.tab-button.active')?.id;
                if (currentTab === 'main-tab-workflow') {
                    getEl('final-report-container').classList.remove('hidden');
                    getEl('final-report-container').scrollIntoView({ behavior: 'smooth' });
                }
                setUnsavedChanges(true);
            }            
            async function processSalesData() {
                showLoader('Processing Sales Data...');
                try {
                    const salesFile = getEl('salesDataFile').files[0];
                    if (!salesFile) throw new Error("Please select a sales data file.");

                    const salesData = await parseSalesExcelFile(salesFile);
                    if (!salesData?.length) throw new Error("Sales data file is empty or invalid after processing.");                    // Filter out completely empty rows (already cleaned by parseSalesExcelFile)
                    const cleanedData = salesData.filter(row => {
                        // Row is now an array, check if it has meaningful data
                        return Array.isArray(row) && row.some(cell => cell && String(cell).trim() !== '');
                    });

                    if (!cleanedData.length) throw new Error("No valid sales data found after cleaning.");

                    // Process sales data - extract relevant columns
                    const processedSales = [];
                    const salesMap = new Map(); // For aggregating by SKU
                      cleanedData.forEach((row, index) => {
                        try {
                            // Row is now an array, access columns directly by index (0-based)
                            const serial = row[53] || null; // Column 54 (Serial) -> index 53
                            const productName = row[19] || null; // Column 20 (Product Name) -> index 19
                            const qty = row[26] || null; // Column 27 (QTY) -> index 26
                            const billNo = row[9] || null; // Column 10 (Bill No) -> index 9

                            if (serial && qty && !isNaN(parseFloat(qty))) {
                                // Apply the same SKU transformation as SOH processing
                                const sku = String(serial).replace(/\./g, ' ').trim().toUpperCase();
                                const quantity = Math.abs(parseFloat(qty)); // Use absolute value
                                const product = String(productName || '').trim();
                                const bill = String(billNo || '').trim();

                                // Use enhanced matching to find the item in sohLookup
                                const allSohItems = Object.values(state.sohLookup);
                                const matchedItem = findItemByScannedText(allSohItems, sku);
                                
                                // Use the matched SKU if found, otherwise use the original
                                const finalSku = matchedItem ? matchedItem.SKU : sku;

                                if (salesMap.has(finalSku)) {
                                    const existing = salesMap.get(finalSku);
                                    existing.totalQty += quantity;
                                    existing.bills.push(bill);
                                } else {
                                    salesMap.set(finalSku, {
                                        sku: finalSku,
                                        productName: product,
                                        totalQty: quantity,
                                        bills: [bill],
                                        originalSerial: sku, // Keep track of original for debugging
                                        matched: !!matchedItem
                                    });
                                }
                            }
                        } catch (rowError) {
                            // Skip problematic rows silently
                        }
                    });

                    const salesSummary = Array.from(salesMap.values());

                    // Calculate matching statistics for debugging
                    const matchedCount = salesSummary.filter(sale => sale.matched).length;
                    const unmatchedCount = salesSummary.length - matchedCount;                    // Apply sales data to tracking - simplified approach
                    let adjustedItems = 0;
                    if (state.sohLookup && Object.keys(state.sohLookup).length > 0) {
                        salesSummary.forEach(sale => {
                            if (state.sohLookup[sale.sku]) {
                                adjustedItems++;
                                // Note: We no longer track SalesDuringCount in sohLookup 
                                // as sales are directly added to final count in the processing above
                            }
                        });                          // Update netDiffData if it exists - enhanced sales integration with new conditions
                        if (state.netDiffData.length > 0) {
                            state.netDiffData.forEach(item => {
                                const sale = salesSummary.find(s => s.sku === item.SKU);
                                if (sale) {
                                    const billNumbers = sale.bills.filter(bill => bill.trim() !== '').join(', ');
                                      // Check if this item already has any count (manual, first count, or recount)
                                    const hasExistingCount = (
                                        // Has been manually counted
                                        (item.ReasonFinal && (item.ReasonFinal.includes('Manual') || item.ReasonFinal.includes('Re-Scan') || item.ReasonFinal.includes('Scan'))) ||
                                        // Has been counted in first count (Scan1 > 0 or has Reason1)
                                        (item.Scan1 > 0 || (item.Reason1 && item.Reason1.trim() !== '')) ||
                                        // Has been recounted (Recount different from initial and not due to previous sales)
                                        (item.Recount !== item.Scan1 && !item.ReasonFinal?.includes('Sales:')) ||
                                        // Has any counting reason that's not sales-related (excluding uncounted items)
                                        (item.ReasonFinal && !item.ReasonFinal.includes('Sales:') && item.ReasonFinal.trim() !== '' && item.ReasonFinal !== 'DEMO-N/A' && !item.ReasonFinal.includes('N/A'))
                                    );
                                    
                                    if (hasExistingCount) {
                                        // Skip updating count, only add "sold now" to remark
                                        const soldNowText = `Sold now: ${billNumbers}`;
                                        if (item.Remark && item.Remark.trim() !== '') {
                                            // Remove any previous "sold now" entries before adding new one
                                            item.Remark = item.Remark.replace(/\s*\|\s*Sold now:[^|]*/g, '');
                                            item.Remark += ` | ${soldNowText}`;
                                        } else {
                                            item.Remark = soldNowText;
                                        }
                                    } else {
                                        // Check if this is a re-processing of sales data (overwrite mode)
                                        const hasPreviousSales = item.ReasonFinal && item.ReasonFinal.includes('Sales:');
                                        
                                        if (hasPreviousSales) {
                                            // Overwrite previous sales data instead of adding up
                                            // First, remove previous sales count addition
                                            const previousSalesMatch = item.ReasonFinal.match(/Sales: (\d+) units added/);
                                            if (previousSalesMatch) {
                                                const previousSalesQty = parseInt(previousSalesMatch[1], 10);
                                                item.Recount = Math.max(0, item.Recount - previousSalesQty);
                                            }
                                            
                                            // Remove previous sales bill numbers from remarks
                                            if (item.Remark) {
                                                item.Remark = item.Remark.replace(/\s*\|\s*Bills:[^|]*/g, '');
                                                item.Remark = item.Remark.replace(/^Bills:[^|]*\s*\|\s*/, '');
                                                item.Remark = item.Remark.replace(/^Bills:[^|]*$/, '');
                                            }
                                        }
                                          // Apply new sales data
                                        item.Recount = (item.Recount || 0) + sale.totalQty;
                                        item.FinalDiff = item.Recount - item.SOH;
                                        
                                        // Update reason to indicate sales during count with SOH tracking
                                        const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(item.SKU);
                                        const salesReason = `Sales: ${sale.totalQty} units added`;
                                        item.ReasonFinal = wasSohUpdated ? `SOHupdated-${salesReason}` : salesReason;
                                        
                                        // Add bill numbers to remarks
                                        if (billNumbers) {
                                            if (item.Remark && item.Remark.trim() !== '') {
                                                item.Remark += ` | Bills: ${billNumbers}`;
                                            } else {
                                                item.Remark = `Bills: ${billNumbers}`;
                                            }
                                        }
                                    }
                                }
                            });                        
                        }                        // Update reconciledData if it exists - enhanced sales integration with same conditions
                        if (state.reconciledData.length > 0) {
                            state.reconciledData.forEach(item => {
                                const sale = salesSummary.find(s => s.sku === item.SKU);
                                if (sale) {
                                    const billNumbers = sale.bills.filter(bill => bill.trim() !== '').join(', ');
                                    
                                    // Check if this item already has any count (manual, first count, or recount)
                                    const hasExistingCount = (
                                        // Has been manually counted
                                        (item.ReasonFinal && (item.ReasonFinal.includes('Manual') || item.ReasonFinal.includes('Re-Scan') || item.ReasonFinal.includes('Scan'))) ||
                                        // Has been counted in first count (Scan1 > 0 or has Reason1)
                                        (item.Scan1 > 0 || (item.Reason1 && item.Reason1.trim() !== '')) ||
                                        // Has been recounted (Recount different from initial and not due to previous sales)
                                        (item.Recount !== item.Scan1 && !item.ReasonFinal?.includes('Sales:')) ||
                                        // Has any counting reason that's not sales-related (excluding uncounted items)
                                        (item.ReasonFinal && !item.ReasonFinal.includes('Sales:') && item.ReasonFinal.trim() !== '' && item.ReasonFinal !== 'DEMO-N/A' && !item.ReasonFinal.includes('N/A'))
                                    );
                                    
                                    if (hasExistingCount) {
                                        // Skip updating count, only add "sold now" to remark
                                        const soldNowText = `Sold now: ${billNumbers}`;
                                        if (item.Remark && item.Remark.trim() !== '') {
                                            // Remove any previous "sold now" entries before adding new one
                                            item.Remark = item.Remark.replace(/\s*\|\s*Sold now:[^|]*/g, '');
                                            item.Remark += ` | ${soldNowText}`;
                                        } else {
                                            item.Remark = soldNowText;
                                        }
                                    } else {
                                        // Check if this is a re-processing of sales data (overwrite mode)
                                        const hasPreviousSales = item.ReasonFinal && item.ReasonFinal.includes('Sales:');
                                        
                                        if (hasPreviousSales) {
                                            // Overwrite previous sales data instead of adding up
                                            // First, remove previous sales count addition
                                            const previousSalesMatch = item.ReasonFinal.match(/Sales: (\d+) units added/);
                                            if (previousSalesMatch) {
                                                const previousSalesQty = parseInt(previousSalesMatch[1], 10);
                                                item.Recount = Math.max(0, item.Recount - previousSalesQty);
                                            }
                                            
                                            // Remove previous sales bill numbers from remarks
                                            if (item.Remark) {
                                                item.Remark = item.Remark.replace(/\s*\|\s*Bills:[^|]*/g, '');
                                                item.Remark = item.Remark.replace(/^Bills:[^|]*\s*\|\s*/, '');
                                                item.Remark = item.Remark.replace(/^Bills:[^|]*$/, '');
                                            }
                                        }
                                          // Add sales count directly to final count (not reducing SOH)
                                        item.Recount = (item.Recount || 0) + sale.totalQty;
                                        item.FinalDiff = item.Recount - item.SOH;
                                          // Update reason to indicate sales during count with SOH tracking
                                        const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(item.SKU);
                                        const salesReason = `Sales: ${sale.totalQty} units added`;
                                        item.ReasonFinal = wasSohUpdated ? `SOHupdated-${salesReason}` : salesReason;
                                        
                                        // Add bill numbers to remarks
                                        if (billNumbers) {
                                            if (item.Remark && item.Remark.trim() !== '') {
                                                item.Remark += ` | Bills: ${billNumbers}`;
                                            } else {
                                                item.Remark = `Bills: ${billNumbers}`;
                                            }
                                        }
                                    }
                                }
                            });
                            applyFinalReportView();
                            renderFinalReportCharts();
                        }
                    }                    
                    // Display results
                    const resultsEl = getEl('sales-processing-results');
                    
                    // Create matched sales table
                    const matchedSales = salesSummary.filter(sale => sale.matched);
                    const matchedSalesTable = matchedSales.length > 0 ? `
                        <div class="mt-4">
                            <h5 class="font-medium text-slate-700 mb-2">📋 Matched Sales Records</h5>
                            <div class="max-h-64 overflow-y-auto border border-slate-200 rounded-lg">
                                <table class="w-full text-xs">
                                    <thead class="bg-slate-50 sticky top-0">
                                        <tr>
                                            <th class="p-2 text-left font-medium text-slate-600">SKU</th>
                                            <th class="p-2 text-center font-medium text-slate-600">Qty</th>
                                            <th class="p-2 text-left font-medium text-slate-600">Bill Numbers</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${matchedSales.map(sale => `
                                            <tr class="border-b border-slate-100 hover:bg-slate-50">
                                                <td class="p-2 font-mono text-slate-700">${sale.sku}</td>
                                                <td class="p-2 text-center text-orange-600 font-medium">${sale.totalQty}</td>
                                                <td class="p-2 text-slate-600 text-xs">${sale.bills.filter(bill => bill.trim() !== '').join(', ') || 'N/A'}</td>
                                            </tr>
                                        `).join('')}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    ` : '';
                    
                    resultsEl.innerHTML = `
                        <div class="space-y-2">
                            <div class="flex justify-between">
                                <span>🖥️ Total Sales Records:</span>
                                <span class="font-bold text-blue-600">${salesSummary.length}</span>
                            </div>
                            <div class="flex justify-between">
                                <span>✅ SKUs Matched:</span>
                                <span class="font-bold text-green-600">${matchedCount}</span>
                            </div>
                            <div class="flex justify-between">
                                <span>❌ SKUs Not Matched:</span>
                                <span class="font-bold text-orange-600">${unmatchedCount}</span>
                            </div>
                            <div class="flex justify-between">
                                <span>🔖 Items with Sales Data:</span>
                                <span class="font-bold text-green-600">${adjustedItems}</span>
                            </div>
                            ${matchedSalesTable}
                            ${unmatchedCount > 0 ? `
                            <div class="mt-3 text-xs text-slate-600">
                                <details class="cursor-pointer">
                                    <summary class="font-medium text-orange-600">Debug: Unmatched SKUs (Top 5)</summary>
                                    <div class="mt-2 space-y-1 max-h-32 overflow-y-auto">
                                        ${salesSummary.filter(sale => !sale.matched).slice(0, 5).map(sale => 
                                            `<div class="text-xs text-orange-600">
                                                <div>Original: "${sale.originalSerial}"</div>
                                                <div>Processed: "${sale.sku}"</div>
                                                <div class="text-slate-400 mb-1">---</div>
                                            </div>`
                                        ).join('')}
                                    </div>
                                </details>
                            </div>
                            ` : ''}
                        </div>
                    `;
                    resultsEl.classList.remove('hidden');

                    setUnsavedChanges(true);
                    showModal("Success", `Sales data processed successfully. ${adjustedItems} items now have sales tracking data and bill number references added to remarks.`);
                } catch (error) {
                    showModal("Error", `Sales data processing failed: ${error.message}`);
                } finally {
                    hideLoader();
                }
            }
              function generateRecountMasterFile() {
                // Include items that need recounting:
                // 1. Items with discrepancies (Diff1 !== 0)
                // 2. Items that were never counted (Scan1 === 0 && !Reason1)
                // 3. Exclude DEMO items (!isDemo)
                const itemsToRecount = state.netDiffData.filter(item => 
                    !item.isDemo && (item.Diff1 !== 0 || (item.Scan1 === 0 && !item.Reason1))
                );
                
                if (!itemsToRecount.length) {
                    return showModal("Info", "No non-DEMO items require a recount.");
                }
                
                // Show preview of what will be included
                const discrepancyCount = itemsToRecount.filter(item => item.Diff1 !== 0).length;
                const uncountedCount = itemsToRecount.filter(item => item.Scan1 === 0 && !item.Reason1).length;
                const totalSOH = itemsToRecount.reduce((sum, item) => sum + item.SOH, 0);
                
                const previewMessage = `
                    <div class="text-left">
                        <p class="mb-2"><strong>Items to be included in recount:</strong></p>
                        <ul class="list-disc pl-5 space-y-1">
                            <li>Items with discrepancies: <span class="font-medium text-blue-600">${discrepancyCount}</span></li>
                            <li>Items not counted: <span class="font-medium text-red-600">${uncountedCount}</span></li>
                            <li><strong>Total items: <span class="text-green-600">${itemsToRecount.length}</span></strong></li>
                            <li><strong>Total SOH: <span class="text-purple-600">${formatNumber(totalSOH)}</span></strong></li>
                        </ul>
                    </div>
                `;
                showModal("Generate Recount Master File", previewMessage, {
                    onConfirm: () => {
                        // Use new file naming convention: Master_ReCount_branchcode_date.csv
                        const branchInfo = state.branchCode ? `${state.branchCode}_${state.countDate}` : `${state.branchName.replace(/\s+/g, '_')}_${state.countDate}`;
                        const fileName = `Master_ReCount_${branchInfo}.csv`;
                        
                        const rowsForCsv = itemsToRecount.map(item => [item.SKU, item.Description, item.Price, item.Age, item.SOH]);
                        downloadFile(Papa.unparse(rowsForCsv, { header: false }), fileName);
                        showModal("Success", `Recount master file generated with ${itemsToRecount.length} items.`);
                    },
                    onCancel: () => {},
                    confirmText: "Generate File",
                    cancelText: "Cancel"
                });
            }            
            async function handleLatestSohUpload(e) {
                const file = e.target.files[0]; if (!file) return;
                getEl('latestSohFileName').textContent = file.name;
                showLoader("Updating SOH...");
                try {
                    const latestSohRaw = await parseExcelFile(file);
                    if (!latestSohRaw?.length) throw new Error("Latest SOH file is empty or invalid.");
                    const { lookup: latestSohProcessedLookup } = processAndSeparateSoh(latestSohRaw);
                    if (Object.keys(latestSohProcessedLookup).length === 0) throw new Error("No valid stock items found in the latest SOH file.");
                    
                    // Track SKUs with updated SOH
                    const sohUpdatedSkus = new Set();
                    let updatedCount = 0;
                    state.netDiffData.forEach(item => {
                        if (latestSohProcessedLookup[item.SKU] !== undefined) {
                            const oldSoh = item.SOH;
                            const newSoh = latestSohProcessedLookup[item.SKU].SOH;
                            
                            // Skip updating SKUs that had diff = 0 in first count
                            const originalDiff1 = item.Scan1 - oldSoh;
                            if (originalDiff1 === 0) {
                                // Skip this item - it was counted correctly in first count
                                return;
                            }
                            
                            if (oldSoh !== newSoh) { 
                                item.SOH = newSoh; 
                                item.Diff1 = item.Scan1 - item.SOH; 
                                sohUpdatedSkus.add(item.SKU);
                                updatedCount++; 
                            }
                        }
                    });
                    Object.values(state.sohLookup).forEach(item => {
                        if (latestSohProcessedLookup[item.SKU] !== undefined) {
                            const oldSoh = item.SOH;
                            const newSoh = latestSohProcessedLookup[item.SKU].SOH;
                            
                            // Skip updating SKUs that had diff = 0 in first count (check if this item exists in netDiffData)
                            const netDiffItem = state.netDiffData.find(ndItem => ndItem.SKU === item.SKU);
                            if (netDiffItem) {
                                const originalDiff1 = netDiffItem.Scan1 - oldSoh;
                                if (originalDiff1 === 0) {
                                    // Skip this item - it was counted correctly in first count
                                    return;
                                }
                            }
                            
                            if (oldSoh !== newSoh) {
                                item.SOH = newSoh;
                                sohUpdatedSkus.add(item.SKU);
                            }
                        }
                    });
                    if (state.reconciledData.length > 0) {
                        state.reconciledData.forEach(item => {
                            if (latestSohProcessedLookup[item.SKU] !== undefined) { 
                                const oldSoh = item.SOH;
                                const newSoh = latestSohProcessedLookup[item.SKU].SOH;
                                
                                // Skip updating SKUs that had diff = 0 in first count
                                const originalDiff1 = item.Scan1 - oldSoh;
                                if (originalDiff1 === 0) {
                                    // Skip this item - it was counted correctly in first count
                                    return;
                                }
                                
                                if (oldSoh !== newSoh) {
                                    item.SOH = newSoh; 
                                    item.FinalDiff = item.Recount - item.SOH;
                                    sohUpdatedSkus.add(item.SKU);
                                      // Update reason to include SOHupdated
                                    if (!item.ReasonFinal || item.ReasonFinal === 'DEMO-N/A' || item.ReasonFinal === 'N/A Re-Scan') {
                                        item.ReasonFinal = 'SOHupdated';
                                    } else if (!item.ReasonFinal.includes('SOHupdated')) {
                                        item.ReasonFinal = `SOHupdated-${item.ReasonFinal}`;
                                    }
                                } else {
                                    item.SOH = newSoh; 
                                    item.FinalDiff = item.Recount - item.SOH;
                                }
                            }
                        });
                        applyFinalReportView(); renderFinalReportCharts();
                    }
                    // Store SOH updated SKUs for future reference
                    if (!state.sohUpdatedSkus) state.sohUpdatedSkus = new Set();
                    sohUpdatedSkus.forEach(sku => state.sohUpdatedSkus.add(sku));
                    
                    // Count skipped items (those with diff = 0 in first count)
                    let skippedCount = 0;
                    state.netDiffData.forEach(item => {
                        if (latestSohProcessedLookup[item.SKU] !== undefined) {
                            const originalDiff1 = item.Scan1 - item.SOH;
                            if (originalDiff1 === 0) {
                                skippedCount++;
                            }
                        }
                    });
                    
                    const totalAvailable = Object.keys(latestSohProcessedLookup).length;
                    const message = skippedCount > 0 
                        ? `SOH updated for ${updatedCount} items. ${skippedCount} items with correct first count were skipped (no update needed). Total items in latest SOH: ${totalAvailable}.`
                        : `SOH updated for ${updatedCount} items. You can now generate a new recount file or finalize the report.`;
                    
                    showModal("Success", message);
                    setUnsavedChanges(true);
                } catch (error) { showModal("Error Updating SOH", error.message);
                } finally { hideLoader(); e.target.value = ''; getEl('latestSohFileName').textContent = ''; }
            }
            
            async function processSecondCount() {
                showLoader('Processing Recount...');
                try {
                    const logFiles = getEl('secondScanLogfile').files;
                    const masterFile = getEl('secondMasterFile').files[0];
                    
                    if (!logFiles.length && !masterFile) {
                        throw new Error("Please upload at least one file (Logfile or Master.csv) for the recount.");
                    }
                    
                    let recountData = [];
                    
                    // Process Logfile(s) if uploaded
                    if (logFiles.length > 0) {
                        const logfileData = await (async function(files){ 
                            const p = Array.from(files).map(f => new Promise((res, rej) => { 
                                Papa.parse(f, { 
                                    skipEmptyLines: true, 
                                    complete: r => { 
                                        const d = r.data.map(row => { 
                                            if(!row || row.length < 3 || !row[2]) return null; 
                                            const sku = String(row[2]).trim(); 
                                            const qty = parseInt(String(row[4] ?? 1).replace(/,/g,''), 10); 
                                            return {sku, qty: isNaN(qty) ? 1: qty};
                                        }).filter(Boolean); 
                                        res(d); 
                                    }, 
                                    error: rej
                                }); 
                            })); 
                            return Promise.all(p).then(r => r.flat()); 
                        })(logFiles);
                        recountData = recountData.concat(logfileData);
                    }
                    
                    // Process Master.csv if uploaded
                    if (masterFile) {
                        const masterData = await new Promise((resolve, reject) => {
                            Papa.parse(masterFile, {
                                skipEmptyLines: true,
                                complete: result => {
                                    try {
                                        const data = result.data.map(row => {
                                            if (!row || row.length < 6 || !row[0]) return null;
                                            const sku = String(row[0]).trim(); // Column 1: Part No.
                                            const qty = parseInt(String(row[5] || '0').replace(/,/g, ''), 10); // Column 6: Actual Qty
                                            // Only include items that were actually counted (qty > 0)
                                            if (isNaN(qty) || qty <= 0) return null;
                                            return { sku, qty };
                                        }).filter(Boolean);
                                        resolve(data);
                                    } catch (error) {
                                        reject(error);
                                    }
                                },
                                error: reject
                            });
                        });
                        recountData = recountData.concat(masterData);
                    }
                    
                    // Convert recount data array to SKU-keyed object for easier lookup
                    const recountCounts = {};
                    recountData.forEach(item => {
                        if (recountCounts[item.sku]) {
                            recountCounts[item.sku] += item.qty; // Sum if same SKU appears multiple times
                        } else {
                            recountCounts[item.sku] = item.qty;
                        }
                    });                    state.reconciledData = state.netDiffData.map(item => {
                        const newItem = {...item};
                        
                        // Check if item has been manually edited in final table
                        const existingReconciledItem = state.reconciledData.find(r => r.SKU === item.SKU);
                        const hasManualEdit = existingReconciledItem && (
                            existingReconciledItem.ReasonFinal === 'Manual Edit' ||
                            existingReconciledItem.ReasonFinal === 'SOHupdated-Manual Edit'
                        );
                        
                        if (hasManualEdit) {
                            // Skip updating - preserve manual edit
                            return existingReconciledItem;
                        }
                        
                        // Check if item has existing sales data that should be preserved
                        const hasSalesData = existingReconciledItem && 
                            existingReconciledItem.ReasonFinal && 
                            existingReconciledItem.ReasonFinal.includes('Sales:');
                        
                        if (hasSalesData) {
                            // Preserve existing sales data and only update if this item was recounted
                            if (recountCounts[newItem.SKU] !== undefined) {
                                // Item was recounted - add recount data to existing sales count
                                const salesMatch = existingReconciledItem.ReasonFinal.match(/Sales: (\d+) units added/);
                                const salesQty = salesMatch ? parseInt(salesMatch[1], 10) : 0;
                                
                                // Set base count from recount, then add sales on top
                                newItem.Recount = recountCounts[newItem.SKU] + salesQty;
                                newItem.FinalDiff = newItem.Recount - newItem.SOH;
                                
                                // Update reason to combine recount and sales info
                                const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(newItem.SKU);
                                const baseRecountReason = wasSohUpdated ? 'SOHupdated-Re-Scan' : 'Re-Scan';
                                newItem.ReasonFinal = `${baseRecountReason} + ${existingReconciledItem.ReasonFinal}`;
                                
                                // Preserve existing remarks (which contain bill numbers)
                                newItem.Remark = existingReconciledItem.Remark || '';
                            } else {
                                // Item was not recounted - preserve all existing sales data
                                return existingReconciledItem;
                            }
                        } else {
                            // No existing sales data - proceed with normal recount logic
                            // Initialize Recount and ReasonFinal for all items
                            if (!newItem.isDemo && newItem.Diff1 !== 0) {
                                // Items that need recounting
                                const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(newItem.SKU);                            
                                if (recountCounts[newItem.SKU] !== undefined) { 
                                    newItem.Recount = recountCounts[newItem.SKU]; 
                                    newItem.ReasonFinal = wasSohUpdated ? 'SOHupdated-Re-Scan' : 'Re-Scan';                            
                                } else { 
                                    newItem.Recount = 0; 
                                    newItem.ReasonFinal = wasSohUpdated ? 'SOHupdated-N/A Re-Scan' : 'N/A Re-Scan'; 
                                }
                            } else if (newItem.isDemo) {
                                // Demo items: get current count from demo panel
                                const demoCount = state.demoCounts[newItem.SKU];
                                const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(newItem.SKU);                            
                                if (demoCount && typeof demoCount.qty === 'number') {
                                    newItem.Recount = demoCount.qty;
                                    const baseReason = demoCount.reason || 'DEMO-Manual';
                                    newItem.ReasonFinal = wasSohUpdated ? `SOHupdated-${baseReason}` : baseReason;                            
                                } else {
                                    const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(newItem.SKU);
                                    newItem.Recount = 0;
                                    newItem.ReasonFinal = wasSohUpdated ? 'SOHupdated-DEMO-N/A' : 'DEMO-N/A';
                                }} else {
                                // Items that don't need recounting (items with no difference)
                                newItem.Recount = newItem.Counted1 || 0;
                                // Keep the original reason for items that don't need recounting
                                // Don't change to "No Recount Needed" - preserve the original counting reason
                            }
                            
                            newItem.FinalDiff = newItem.Recount - newItem.SOH;
                        }
                        
                        return newItem;
                    });                    
                    applyFinalReportView(); 
                    renderFinalReportCharts();
                    
                    // Only show final report if on workflow tab
                    const currentTab = document.querySelector('.tab-button.active')?.id;
                    if (currentTab === 'main-tab-workflow') {
                        getEl('final-report-container').classList.remove('hidden');
                        getEl('final-report-container').scrollIntoView({ behavior: 'smooth' });
                    }
                    setUnsavedChanges(true);
                    
                    // Generate success message showing what files were processed
                    let processedFiles = [];
                    if (logFiles.length > 0) processedFiles.push(`${logFiles.length} Logfile(s)`);
                    if (masterFile) processedFiles.push('Master.csv');
                    const message = `Recount processed successfully using: ${processedFiles.join(' and ')}. Final report is now available.`;
                    
                    showModal("Success", message);
                } catch (error) { 
                    showModal("Error", "Recount processing failed: " + error.message);
                } finally { 
                    hideLoader(); 
                }
            }            
            function applyFinalReportView() {
                if (!state.reconciledData.length) return;
                
                // Populate filter dropdowns dynamically
                populateFinalReportFilters();
                
                const searchValue = getEl('finalSearchInput')?.value?.toUpperCase() || '';
                const filterValue = getEl('finalFilterSelect')?.value || 'all';
                const groupCodeFilter = getEl('finalGroupCodeFilter')?.value || 'all';
                const ageFilter = getEl('finalAgeFilter')?.value || 'all';
                const subclassFilter = getEl('finalSubclassFilter')?.value || 'all';
                  let dataView = state.reconciledData.filter(item => {
                    // Text search filter
                    if (!(item.SKU.toUpperCase().includes(searchValue) || item.Description.toUpperCase().includes(searchValue))) return false;
                    
                    // Status filter
                    if (filterValue !== 'all') {
                        if (filterValue === 'discrepancy' && item.FinalDiff === 0) return false;
                        if (filterValue === 'demo' && !item.isDemo) return false;
                        if (filterValue === 'normal' && item.isDemo) return false;
                    }
                    
                    // GROUP_CODE filter
                    if (groupCodeFilter !== 'all' && item.GROUP_CODE !== groupCodeFilter) return false;
                    
                    // Age filter
                    if (ageFilter !== 'all') {
                        const age = parseInt(item.Age) || 0;
                        if (ageFilter === 'new' && age >= 300) return false;
                        if (ageFilter === 'old' && age < 300) return false;
                    }
                    
                    // SUBCLASS filter
                    if (subclassFilter !== 'all' && item.SUBCLASS_CODE !== subclassFilter) return false;
                    
                    return true;                });
                const { column, direction } = state.finalReportSort;                dataView.sort((a, b) => {
                    // First level sort: non-DEMO items first, then DEMO items
                    if (a.isDemo !== b.isDemo) {
                        return a.isDemo - b.isDemo;
                    }
                    
                    // Second level sort: by the selected column
                    let valA = column === 'FinalDiff' ? Math.abs(a[column]) : a[column];
                    let valB = column === 'FinalDiff' ? Math.abs(b[column]) : b[column];
                    
                    // Handle field name mapping for certain columns
                    if (column === 'SRP') {
                        valA = a.Price || 0;
                        valB = b.Price || 0;
                    } else if (column === 'FinalCount') {
                        valA = a.Recount || 0;
                        valB = b.Recount || 0;
                    }
                    
                    // Handle null/undefined values for string columns
                    if (column === 'ReasonFinal' || column === 'Remark') {
                        valA = valA || '';
                        valB = valB || '';
                    }
                    
                    if (typeof valA === 'string') return direction === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                    return direction === 'asc' ? valA - valB : valB - valA;
                });
                renderFinalReportTable(dataView);
                updateFinalReportSummary();
            }              function renderFinalReportTable(data) {
                const container = getEl('final-report-table-container');
                const cardsContainer = getEl('final-report-cards');
                
                if (!data.length) { 
                    container.innerHTML = '<p class="text-center p-10 text-slate-500">No data matches the current filter.</p>'; 
                    cardsContainer.innerHTML = '<p class="text-center p-10 text-slate-500">No data matches the current filter.</p>';
                    return; 
                }
                
                // Desktop table view
                const headers = `<thead><tr><th class="p-2 text-center w-12">NO.</th><th class="p-2 text-left" data-sort-by="SKU">SKU<span class="sort-indicator"></span></th><th class="p-2 text-left" data-sort-by="Description">Description<span class="sort-indicator"></span></th><th class="p-2 text-center" data-sort-by="SRP">SRP<span class="sort-indicator"></span></th><th class="p-2 text-center" data-sort-by="Age">Age<span class="sort-indicator"></span></th><th class="p-2 text-center" data-sort-by="SOH">SOH<span class="sort-indicator"></span></th><th class="p-2 text-center" data-sort-by="FinalCount">Final Count<span class="sort-indicator"></span></th><th class="p-2 text-center" data-sort-by="FinalDiff">Final Diff<span class="sort-indicator"></span></th><th class="p-2 text-left" data-sort-by="ReasonFinal">Reason<span class="sort-indicator"></span></th><th class="p-2 text-left" data-sort-by="Remark">Remark<span class="sort-indicator"></span></th></tr></thead>`;
                const body = `<tbody>${data.map((item, idx) => renderFinalReportRow(item, idx)).join('')}</tbody>`;
                container.innerHTML = `<table class="w-full text-sm">${headers}${body}</tbody></table>`;
                
                // Mobile card view
                cardsContainer.innerHTML = data.map((item, idx) => renderFinalReportCard(item, idx)).join('');
                
                // Update sort indicators with colors
                const sortingTh = container.querySelector(`th[data-sort-by="${state.finalReportSort.column}"]`);
                if (sortingTh) { 
                    const indicator = sortingTh.querySelector('.sort-indicator');
                    indicator.textContent = state.finalReportSort.direction === 'asc' ? '▲' : '▼'; 
                    // Add color: green for ascending, red for descending
                    indicator.style.color = state.finalReportSort.direction === 'asc' ? '#22c55e' : '#ef4444';
                }
            }            function renderFinalReportRow(item, idx) {
                const { rowClass, statusDotColor } = getRowVisuals(item.FinalDiff, item.isDemo);
                return `<tr class="border-b border-slate-200 ${rowClass}" data-sku="${item.SKU}">
                    <td class="p-2 text-center">${idx + 1}</td>
                    <td class="p-2 font-medium text-slate-800">${item.SKU}</td>
                    <td class="p-2 text-slate-600">${item.Description}</td>
                    <td class="p-2 text-center">${item.Price ?? 0}</td>
                    <td class="p-2 text-center text-slate-600">${item.Age || 'N/A'}</td>
                    <td class="p-2 text-center">${item.SOH}</td>
                    <td class="p-2 text-center w-24"><input type="number" value="${item.Recount}" class="w-full text-center p-1.5 border border-slate-300 rounded-md"/></td>
                    <td class="p-2 font-bold text-center ${getDiffColorClass(item.FinalDiff)}">${item.FinalDiff > 0 ? '+' : ''}${item.FinalDiff}</td>
                    <td class="p-2 text-slate-600">${item.ReasonFinal || 'N/A'}</td>
                    <td class="p-2 w-40"><input type="text" value="${item.Remark || ''}" class="w-full p-1.5 border border-slate-300 rounded-md"/></td>
                </tr>`;}

            function renderFinalReportCard(item, idx) {
                const diffClass = item.FinalDiff === null ? 'diff-null' : item.FinalDiff > 0 ? 'diff-positive' : item.FinalDiff < 0 ? 'diff-negative' : 'diff-zero';
                const diffText = item.FinalDiff > 0 ? `+${item.FinalDiff}` : item.FinalDiff;
                
                const categoryBadge = getCategoryBadge(item);
                const branchTypeBadge = getBranchTypeBadge(item);
                
                return `
                    <div class="stock-card ${diffClass}" data-sku="${item.SKU}">
                        <div class="stock-card-header">
                            <span class="stock-card-number">#${idx + 1}</span>
                            <span class="stock-card-sku">${item.SKU}</span>
                            ${branchTypeBadge}
                        </div>
                        
                        <div class="stock-card-description">
                            ${item.Description}
                        </div>
                        
                        <div class="stock-card-meta">
                            <div class="stock-card-field">
                                <label>SRP</label>
                                <span class="stock-card-value">${item.Price ?? 0}</span>
                            </div>
                            <div class="stock-card-field">
                                <label>Age</label>
                                <span class="stock-card-value">${item.Age || 'N/A'}</span>
                            </div>
                            <div class="stock-card-field">
                                <label>SOH</label>
                                <span class="stock-card-value">${item.SOH}</span>
                            </div>
                            <div class="stock-card-field">
                                <label>Final Diff</label>
                                <span class="stock-card-value font-bold ${getDiffColorClass(item.FinalDiff)}">${diffText}</span>
                            </div>
                        </div>
                        
                        <div class="stock-card-controls">
                            <div class="stock-card-field">
                                <label>Final Count</label>
                                <input type="number" value="${item.Recount}" 
                                       class="stock-card-input" 
                                       onchange="updateFinalCount('${item.SKU}', this.value)" />
                            </div>
                            <div class="stock-card-field">
                                <label>Remark</label>
                                <input type="text" value="${item.Remark ?? ''}" 
                                       class="stock-card-input" 
                                       onchange="updateRemark('${item.SKU}', this.value)" />
                            </div>
                        </div>
                        
                        <div class="mt-3 pt-3 border-t border-slate-200">
                            <div class="text-xs text-slate-500">
                                <div><strong>Reason:</strong> ${item.ReasonFinal || 'N/A'}</div>
                            </div>
                        </div>
                    </div>
                `;
            }

            function updateTableRowVisuals(row, diff, isDemo = false) {
                // Remove row highlighting for performance - keep rows white
                row.className = `border-b border-slate-200 bg-white`;
                // Note: .status-dot element doesn't exist in table rows, so no need to update it
            }
            function updateFinalCount(sku, value) {
                const item = state.reconciledData.find(i => i.SKU === sku); if (!item) return;
                const newCount = value === '' ? 0 : parseInt(value, 10);
                item.Recount = isNaN(newCount) ? 0 : newCount;
                item.FinalDiff = item.Recount - item.SOH; 
                
                // Handle SOH updated reason tracking
                const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(sku);
                if (wasSohUpdated) {
                    item.ReasonFinal = 'SOHupdated-Manual Edit';                } else {
                    item.ReasonFinal = 'Manual Edit';
                }
                
                // Update desktop table row display
                const row = getEl('final-report-table-container').querySelector(`tr[data-sku="${sku}"]`);                
                if(row) {
                    // Update Final Count column (index 6) with the new count value
                    row.cells[6].querySelector('input[type="number"]').value = item.Recount;                    // Update Final Diff column (index 7) with the calculated difference
                    row.cells[7].textContent = item.FinalDiff > 0 ? `+${item.FinalDiff}` : item.FinalDiff;
                    row.cells[7].className = `p-2 font-bold text-center ${getDiffColorClass(item.FinalDiff)}`;
                    // Update Reason column (index 8)
                    row.cells[8].textContent = item.ReasonFinal;
                    updateTableRowVisuals(row, item.FinalDiff, item.isDemo);
                }
                
                // Update mobile card display
                const card = getEl('final-report-cards').querySelector(`[data-sku="${sku}"]`);
                if (card) {
                    const diffClass = item.FinalDiff === null ? 'diff-null' : item.FinalDiff > 0 ? 'diff-positive' : item.FinalDiff < 0 ? 'diff-negative' : 'diff-zero';
                    
                    // Update card class
                    card.className = `stock-card ${diffClass}`;
                    
                    // Update final diff value
                    const diffValueEl = card.querySelector('.stock-card-field:nth-of-type(4) .stock-card-value');
                    if (diffValueEl) {
                        diffValueEl.textContent = item.FinalDiff > 0 ? `+${item.FinalDiff}` : item.FinalDiff;
                        diffValueEl.className = `stock-card-value font-bold ${getDiffColorClass(item.FinalDiff)}`;
                    }
                    
                    // Update final count input value
                    const countInput = card.querySelector('input[type="number"]');
                    if (countInput) countInput.value = item.Recount;
                    
                    // Update reason text
                    const reasonEl = card.querySelector('.mt-3 .text-xs div');
                    if (reasonEl) reasonEl.innerHTML = `<strong>Reason:</strong> ${item.ReasonFinal || 'N/A'}`;
                }
                
                updateFinalReportSummary();
                updateDemoSummary();
                renderFinalReportCharts();
                setUnsavedChanges(true);
            }            
            function updateRemark(sku, value) {
                const item = state.reconciledData.find(i => i.SKU === sku); if (item) { 
                    item.Remark = value; setUnsavedChanges(true); 
                }
            }

            function updateDemoRemark(sku, value) {
                const item = state.demoMaster.find(i => i.SKU === sku);
                if (item) {
                    item.remark = value;
                    setUnsavedChanges(true);
                }
            }

            function updateFinalReportSummary() {
                const summaryEl = getEl('final-summary');
                if (!state.reconciledData.length) {
                    summaryEl.innerHTML = ''; return; 
                }
                const summary = state.reconciledData.reduce((acc, item) => {
                    const diffCost = item.FinalDiff * item.Price;
                    if (item.FinalDiff > 0) {
                        acc.overQty += item.FinalDiff; acc.overCost += diffCost; 
                    } 
                    else if (item.FinalDiff < 0) {
                        acc.shortQty += item.FinalDiff; acc.shortCost += diffCost; 
                    }
                    acc.totalCountedQty += item.Recount; acc.totalCountedCost += item.Recount * item.Price;
                    acc.totalSOHPrice += item.SOH * (item.Price ?? 0);
                    acc.totalSOHQty += item.SOH;
                    return acc;
                }, { 
                    overQty: 0, overCost: 0, shortQty: 0, shortCost: 0, totalCountedQty: 0, totalCountedCost: 0, totalSOHPrice: 0, totalSOHQty: 0 
                });
                finalSummaryData = summary; // Save for JSON export
                finalSummaryData.netDiffCost = summary.overCost + summary.shortCost;

                // Calculate net diff values for dynamic coloring
                const netDiffQty = summary.overQty + summary.shortQty;
                const netDiffCost = finalSummaryData.netDiffCost;
                
                // Determine colors for Net Diff based on values
                const getNetDiffColor = (value) => {
                    if (value === 0) return 'text-green-600';
                    if (value > 0) return 'text-yellow-600'; // dark yellow for positive differences
                    return 'text-red-600'; // red for negative differences
                };

                summaryEl.innerHTML = `<h4 class="font-semibold text-center mb-1 text-slate-700">Report Summary</h4><div class="grid grid-cols-2 gap-x-4">
                    <div class="text-yellow-600"><strong>Over Qty:</strong> ${formatNumber(summary.overQty)}</div>
                    <div class="text-yellow-600"><strong>Over Cost:</strong> ${formatNumber(summary.overCost)}</div>
                    <div class="text-red-600"><strong>Short Qty:</strong> ${formatNumber(summary.shortQty)}</div>
                    <div class="text-red-600"><strong>Short Cost:</strong> ${formatNumber(summary.shortCost)}</div>
                    <div class="col-span-2 border-t pt-1 mt-1"></div>
                    <div class="text-black"><strong>Total SOH Qty:</strong> ${formatNumber(summary.totalSOHQty)}</div>
                    <div class="text-black"><strong>Total SOH Value:</strong> ${formatNumber(summary.totalSOHPrice)}</div>
                    <div class="text-blue-600"><strong>Total Counted Qty:</strong> ${formatNumber(summary.totalCountedQty)}</div>
                    <div class="text-blue-600"><strong>Total Counted Cost:</strong> ${formatNumber(summary.totalCountedCost)}</div>
                    <div class="font-bold col-span-2 border-t pt-1 mt-1"></div>
                    <div class="font-bold ${getNetDiffColor(netDiffQty)}"><strong>Net Diff Qty:</strong> ${formatNumber(netDiffQty)}</div>
                    <div class="font-bold ${getNetDiffColor(netDiffCost)}"><strong>Net Diff Cost:</strong> ${formatNumber(netDiffCost)}</div>
                </div>`;
            }            
            function renderFinalReportCharts() {
                if (!state.reconciledData.length) return;
                Object.values(state.charts).forEach(chart => chart?.destroy());
                const summary = state.reconciledData.reduce((acc, item) => {
                    if (item.FinalDiff !== 0) {
                        const cat = item.CLASS_NAME || 'UNCATEGORIZED'; 
                        if (!acc.byCategory[cat]) {
                            acc.byCategory[cat] = { over: 0, short: 0 };
                        }
                        if (item.FinalDiff > 0) {
                            acc.byCategory[cat].over += item.FinalDiff;
                        } else {
                            acc.byCategory[cat].short += Math.abs(item.FinalDiff);
                        }
                    }
                    return acc;
                }, { 
                    byCategory: {} 
                });
                
                const chartOptions = {
                    responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'top' } } 
                };
                
                // Only create category bar chart
                const categoryEntries = Object.entries(summary.byCategory)
                    .map(([name, data]) => [name, data.over + data.short, data]) // [name, totalDiff, {over, short}]
                    .sort(([,a],[,b]) => b - a) // Sort by total difference
                    .slice(0, 15);
                
                const categoryLabels = categoryEntries.map(([name]) => name.substring(0, 15));
                const overageData = categoryEntries.map(([,, data]) => data.over);
                const shortageData = categoryEntries.map(([,, data]) => data.short);
                  state.charts.category = new Chart(getEl('categoryChart'), { 
                    type: 'bar', 
                    data: { 
                        labels: categoryLabels, 
                        datasets: [
                            { 
                                label: 'Overage', 
                                data: overageData, 
                                backgroundColor: 'rgba(217, 119, 6, 0.7)',
                                borderColor: 'rgba(217, 119, 6, 1)',
                                borderWidth: 1,
                                barThickness: 25,
                                maxBarThickness: 30
                            },
                            { 
                                label: 'Shortage', 
                                data: shortageData, 
                                backgroundColor: 'rgba(239, 68, 68, 0.7)',
                                borderColor: 'rgba(239, 68, 68, 1)',
                                borderWidth: 1,
                                barThickness: 25,
                                maxBarThickness: 30
                            }
                        ] 
                    }, 
                    options: { 
                        ...chartOptions, 
                        indexAxis: 'y',
                        layout: {
                            padding: {
                                top: 10,
                                bottom: 10,
                                left: 10,
                                right: 10
                            }
                        },
                        scales: { 
                            x: { 
                                beginAtZero: true,
                                stacked: false,
                                grid: {
                                    display: true,
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            },
                            y: {
                                stacked: false,
                                categoryPercentage: 0.9,
                                barPercentage: 0.8,
                                grid: {
                                    display: false
                                },
                                ticks: {
                                    maxRotation: 0,
                                    font: {
                                        size: 11
                                    }
                                }
                            }
                        },
                        plugins: {
                            ...chartOptions.plugins,
                            legend: {
                                position: 'top',
                                labels: {
                                    padding: 20,
                                    usePointStyle: true,
                                    font: {
                                        size: 12
                                    }
                                }
                            },
                            tooltip: {
                                backgroundColor: 'rgba(0, 0, 0, 0.8)',
                                titleColor: 'white',
                                bodyColor: 'white',
                                borderColor: 'rgba(255, 255, 255, 0.1)',
                                borderWidth: 1,
                                callbacks: {
                                    afterLabel: function(context) {
                                        const categoryIndex = context.dataIndex;
                                        const categoryData = categoryEntries[categoryIndex][2];
                                        const total = categoryData.over + categoryData.short;
                                        const net = categoryData.over - categoryData.short;
                                        return `Total: ${total}, Net: ${net > 0 ? '+' : ''}${net}`;
                                    }
                                }
                            }
                        }
                    } 
                });
            }            function exportFinalReport() {
                if (!state.reconciledData.length) return showModal("Info", "No data to export.");
                
                // Sort data to ensure non-DEMO items appear first, then DEMO items
                const sortedData = [...state.reconciledData].sort((a, b) => a.isDemo - b.isDemo);
                
                const dataToExport = sortedData.map((item, idx) => ({
                    NO: idx + 1, 
                    SKU: item.SKU, 
                    Description: item.Description, 
                    SRP: item.Price, 
                    Age: item.Age, 
                    SOH: item.SOH, 
                    Scan: item.Scan1, 
                    Recount: item.Recount, 
                    FinalDiff: item.FinalDiff, 
                    Remark: item.Remark || '', 
                    Reason: item.ReasonFinal,
                    Flag: item.isDemo ? 'DEMO' : 'NONE'
                }));
                const branchInfo = state.branchCode ? `${state.branchCode}_${state.branchName.replace(/\s+/g, '_')}` : state.branchName.replace(/\s+/g, '_');
                downloadFile(Papa.unparse(dataToExport, { header: true }), `${state.countDate}_Report_${branchInfo}.csv`);
            }            function exportStockCountToJSON() {
                if (!state.reconciledData.length) {
                    alert('กรุณาประมวลผลข้อมูลให้ถึงขั้นตอนสุดท้ายก่อนทำการ Export');
                    return;
                }
                
                // Sort data to ensure non-DEMO items appear first, then DEMO items
                const sortedData = [...state.reconciledData].filter(item => item.FinalDiff !== 0).sort((a, b) => a.isDemo - b.isDemo);
                
                const exportData = {
                    tool: 'stock-count',
                    details: {
                        branch: state.branchName,
                        branchCode: state.branchCode,
                        date: state.countDate,
                    },
                    summary: finalSummaryData,
                    data: sortedData
                };
                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const branchInfo = state.branchCode ? `${state.branchCode}_${state.branchName.replace(/\s+/g, '_')}` : state.branchName.replace(/\s+/g, '_');
                a.download = `${state.countDate}_Stock-Count_${branchInfo}.json`;
                document.body.appendChild(a);
                a.click();                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            // Fallback PDF generation method using direct jsPDF
            async function generateFallbackPDF(summary, filteredData) {
                const { jsPDF } = window.jspdf;
                const pdf = new jsPDF('p', 'mm', 'a4');
                
                let yPosition = 20;
                const pageHeight = 297;
                const pageWidth = 210;
                const margin = 15;
                
                // Simple header
                pdf.setFontSize(16);
                pdf.setTextColor(0, 0, 0);
                pdf.text('Stock Count Report', pageWidth / 2, yPosition, { align: 'center' });
                yPosition += 10;
                
                pdf.setFontSize(10);
                pdf.text(`Branch: ${state.branchName || 'N/A'}`, margin, yPosition);
                yPosition += 5;
                pdf.text(`Date: ${state.countDate || new Date().toLocaleDateString()}`, margin, yPosition);
                yPosition += 15;
                
                // Summary
                pdf.setFontSize(12);
                pdf.text('Summary', margin, yPosition);
                yPosition += 8;
                
                pdf.setFontSize(9);
                const summaryLines = [
                    `Total Items: ${summary.totalItems}`,
                    `Items with Discrepancies: ${summary.discrepancyItems}`,
                    `Overage: ${summary.overageQty} pcs`,
                    `Shortage: ${summary.shortageQty} pcs`,
                    `Demo Items: ${summary.demoItems}`
                ];
                
                summaryLines.forEach(line => {
                    pdf.text(line, margin, yPosition);
                    yPosition += 4;
                });
                
                yPosition += 10;
                  // Table header
                pdf.setFontSize(8);
                pdf.text('No.', margin, yPosition);
                pdf.text('SKU', margin + 15, yPosition);
                pdf.text('Description', margin + 40, yPosition);
                pdf.text('SOH', margin + 85, yPosition);
                pdf.text('Count', margin + 105, yPosition);
                pdf.text('Diff', margin + 125, yPosition);
                pdf.text('Reason', margin + 145, yPosition);
                
                yPosition += 8;
                
                // Data rows (limited to prevent overflow)
                const maxRows = Math.min(filteredData.length, 30);
                for (let i = 0; i < maxRows; i++) {
                    const item = filteredData[i];
                    if (yPosition > pageHeight - 20) {
                        pdf.addPage();
                        yPosition = 20;
                    }
                    
                    pdf.text((i + 1).toString(), margin, yPosition);
                    pdf.text(item.SKU.substring(0, 12), margin + 15, yPosition);
                    pdf.text(item.Description.substring(0, 22), margin + 40, yPosition);
                    pdf.text(item.SOH.toString(), margin + 85, yPosition);
                    pdf.text((item.Recount || 0).toString(), margin + 105, yPosition);
                    pdf.text(item.FinalDiff.toString(), margin + 125, yPosition);
                    pdf.text((item.ReasonFinal || '').substring(0, 12), margin + 145, yPosition);
                    
                    yPosition += 5;
                }
                
                // Save
                const branchInfo = state.branchCode ? 
                    `${state.branchCode}_${state.branchName.replace(/[^a-zA-Z0-9ก-๙\s]/g, '').replace(/\s+/g, '_')}` : 
                    state.branchName.replace(/[^a-zA-Z0-9ก-๙\s]/g, '').replace(/\s+/g, '_');
                const dateStr = state.countDate || new Date().toISOString().substring(0, 10);
                const fileName = `Stock-Count_${branchInfo}_${dateStr}_Simple.pdf`;
                
                pdf.save(fileName);
                showModal("Success", `PDF exported using simple format!\nNote: Formatting is simplified due to technical limitations.`);
            }            async function exportToPDF() {
                if (!state.reconciledData || state.reconciledData.length === 0) {
                    showModal("Info", "No data available to export to PDF.");
                    return;
                }

                // Get button reference and store original content OUTSIDE try block
                const exportBtn = document.getElementById('export-pdf-btn');
                const originalContent = exportBtn ? exportBtn.innerHTML : `
                    <!-- PDF icon -->
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M7 21h10a2 2 0 002-2V9.414a1 1 0 00-.293-.707l-5.414-5.414A1 1 0 0012.586 3H7a2 2 0 00-2 2v14a2 2 0 002 2z" />
                    </svg>
                    Export เป็น PDF
                `;

                try {
                    // Show loading
                    if (exportBtn) {
                        exportBtn.innerHTML = `
                            <svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            กำลังสร้าง PDF...
                        `;
                        exportBtn.disabled = true;
                    }

                    // Validate required libraries
                    if (typeof window.jspdf === 'undefined') {
                        throw new Error('jsPDF library not loaded');
                    }
                    if (typeof html2canvas === 'undefined') {
                        throw new Error('html2canvas library not loaded');
                    }

                    // Calculate summary data
                    const summary = state.reconciledData.reduce((acc, item) => {
                        acc.totalItems++;
                        acc.totalSOH += item.SOH;
                        acc.totalCounted += item.Recount || 0;
                        
                        if (item.FinalDiff !== 0) {
                            acc.discrepancyItems++;
                            const diffCost = item.FinalDiff * (item.Price || 0);
                            if (item.FinalDiff > 0) {
                                acc.overageQty += item.FinalDiff;
                                acc.overageCost += diffCost;
                            } else {
                                acc.shortageQty += Math.abs(item.FinalDiff);
                                acc.shortageCost += Math.abs(diffCost);
                            }
                        }
                        
                        if (item.isDemo) {
                            acc.demoItems++;
                            acc.demoSOH += item.SOH;
                            acc.demoCounted += item.Recount || 0;
                        }
                        
                        return acc;
                    }, {
                        totalItems: 0,
                        totalSOH: 0,
                        totalCounted: 0,
                        discrepancyItems: 0,
                        overageQty: 0,
                        shortageQty: 0,
                        overageCost: 0,
                        shortageCost: 0,
                        demoItems: 0,
                        demoSOH: 0,
                        demoCounted: 0
                    });

                    // Filter and sort data - show discrepancies first, then demo items
                    const sortedData = [...state.reconciledData].sort((a, b) => {
                        // First sort by discrepancy status (discrepancies first)
                        const aDiff = a.FinalDiff !== 0 ? 0 : 1;
                        const bDiff = b.FinalDiff !== 0 ? 0 : 1;
                        if (aDiff !== bDiff) return aDiff - bDiff;
                        
                        // Then by demo status (regular items first)
                        if (a.isDemo !== b.isDemo) return a.isDemo - b.isDemo;
                        
                        // Finally by SKU
                        return a.SKU.localeCompare(b.SKU);
                    });
                      // Only include items with discrepancies or demo items
                    const filteredData = sortedData.filter(item => 
                        item.FinalDiff !== 0 || item.isDemo
                    );

                    // Limit data size to prevent canvas issues
                    const maxItemsForCanvas = 50; // Limit to prevent PNG corruption
                    const limitedData = filteredData.slice(0, maxItemsForCanvas);
                    const isDataLimited = filteredData.length > maxItemsForCanvas;                    // Create temporary div for PDF content
                    const pdfContent = document.createElement('div');
                    pdfContent.style.width = '210mm';
                    pdfContent.style.maxWidth = '210mm';
                    pdfContent.style.padding = '15mm 20mm';
                    pdfContent.style.backgroundColor = 'white';
                    pdfContent.style.fontFamily = 'Sarabun, sans-serif';
                    pdfContent.style.fontSize = '12pt';
                    pdfContent.style.lineHeight = '1.4';
                    pdfContent.style.position = 'absolute';
                    pdfContent.style.left = '-9999px';
                    pdfContent.style.top = '0';
                    pdfContent.style.overflow = 'hidden';
                    pdfContent.style.wordWrap = 'break-word';
                    pdfContent.style.boxSizing = 'border-box';

                    // Add header and content using the standard format
                    pdfContent.innerHTML = `
                        <div style="text-align: center; margin-bottom: 30px; border-bottom: 2px solid #000; padding-bottom: 15px;">
                            <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
                                <div style="text-align: left; font-size: 10pt; font-weight: bold;">
                                    Operation Audit Division<br>
                                    (ฝ่ายตรวจสอบปฏิบัติการ)
                                </div>
                                <div style="text-align: right; font-size: 8pt; max-width: 280px;">
                                    บริษัท เอส พี วี ไอ จำกัด (มหาชน)<br>
                                    เลขที่ 2 อาคารพรีเมียร์เพลซ ชั้น 3 ซอยพรีเมียร์ 2 ถนนศรีนครินทร์<br>
                                    แขวงหนองบอน เขตประเวศ กรุงเทพมหานคร 10250<br>
                                    โทร. (66) 61-417-9777  Line ID : iStudio by spvi
                                </div>
                            </div>
                            <h1 style="font-size: 18pt; font-weight: bold; margin: 0;">รายงานการตรวจนับสินค้า</h1>
                            <p style="font-size: 12pt; color: #666; margin: 5px 0 0 0;">Stock Count Report</p>
                        </div>
                        
                        <div style="margin-bottom: 25px;">
                            <h2 style="font-size: 14pt; font-weight: bold; margin-bottom: 15px; border-bottom: 1px solid #ccc; padding-bottom: 5px;">รายละเอียดการตรวจสอบ</h2>
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                                <div><strong>สาขา/Branch:</strong> ${state.branchName || 'N/A'}${state.branchCode ? ` (${state.branchCode})` : ''}</div>
                                <div><strong>วันที่ตรวจนับ/Count Date:</strong> ${state.countDate || 'N/A'}</div>
                                <div><strong>วันที่รายงาน/Report Date:</strong> ${new Date().toLocaleDateString('th-TH')}</div>
                            </div>
                        </div>

                        <div style="margin-bottom: 25px;">
                            <h3 style="font-size: 12pt; font-weight: bold; margin-bottom: 15px; color: #1e40af;">สรุปผลการตรวจนับ</h3>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                                <div>
                                    <h4 style="font-size: 11pt; font-weight: bold; margin-bottom: 10px;">ข้อมูลทั่วไป</h4>
                                    <div style="background: #f8fafc; padding: 10px; border-radius: 5px; font-size: 10pt;">
                                        <div>จำนวนรายการทั้งหมด: ${summary.totalItems.toLocaleString()} รายการ</div>
                                        <div>ยอด SOH รวม: ${summary.totalSOH.toLocaleString()} ชิ้น</div>
                                        <div>ยอดนับได้รวม: ${summary.totalCounted.toLocaleString()} ชิ้น</div>
                                        <div>รายการที่มีผลต่าง: ${summary.discrepancyItems.toLocaleString()} รายการ</div>
                                        <div>รายการ Demo: ${summary.demoItems.toLocaleString()} รายการ</div>
                                    </div>
                                </div>
                                <div>
                                    <h4 style="font-size: 11pt; font-weight: bold; margin-bottom: 10px;">ผลการกระทบยอด</h4>
                                    <div style="background: #f8fafc; padding: 10px; border-radius: 5px; font-size: 10pt;">
                                        <div style="color: #16a34a;">เกิน: ${summary.overageQty.toLocaleString()} ชิ้น (${summary.overageCost.toLocaleString()} บาท)</div>
                                        <div style="color: #dc2626;">ขาด: ${summary.shortageQty.toLocaleString()} ชิ้น (${summary.shortageCost.toLocaleString()} บาท)</div>
                                        <div style="border-top: 1px solid #ccc; margin-top: 5px; padding-top: 5px; font-weight: bold;">
                                            สุทธิ: ${(summary.overageQty - summary.shortageQty).toLocaleString()} ชิ้น 
                                            (${(summary.overageCost - summary.shortageCost).toLocaleString()} บาท)
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>`;

                    // Add count details table if there are items to show
                    if (filteredData.length > 0) {
                        pdfContent.innerHTML += `
                            <div style="margin-bottom: 25px; page-break-inside: avoid;">
                                <h3 style="font-size: 12pt; font-weight: bold; margin-bottom: 15px; color: #1e40af;">รายละเอียดรายการที่มีผลต่าง</h3>                                <table style="width: 100%; border-collapse: collapse; font-size: 9pt;">
                                    <thead>
                                        <tr style="background: #f8fafc;">
                                            <th style="border: 1px solid #e2e8f0; padding: 6px; text-align: center; width: 30px;">No.</th>
                                            <th style="border: 1px solid #e2e8f0; padding: 6px; text-align: left;">SKU</th>
                                            <th style="border: 1px solid #e2e8f0; padding: 6px; text-align: left;">รายการ</th>
                                            <th style="border: 1px solid #e2e8f0; padding: 6px; text-align: center;">SOH</th>
                                            <th style="border: 1px solid #e2e8f0; padding: 6px; text-align: center;">นับได้</th>
                                            <th style="border: 1px solid #e2e8f0; padding: 6px; text-align: center;">ผลต่าง</th>
                                            <th style="border: 1px solid #e2e8f0; padding: 6px; text-align: left;">เหตุผล</th>
                                            <th style="border: 1px solid #e2e8f0; padding: 6px; text-align: left;">หมายเหตุ</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${filteredData.map((item, index) => `
                                            <tr style="${item.isDemo ? 'background: #faf5ff;' : ''}">
                                                <td style="border: 1px solid #e2e8f0; padding: 6px; text-align: center; font-size: 8pt;">${index + 1}</td>
                                                <td style="border: 1px solid #e2e8f0; padding: 6px; font-size: 8pt;">${item.SKU}</td>
                                                <td style="border: 1px solid #e2e8f0; padding: 6px; font-size: 8pt;">${item.Description.substring(0, 40)}${item.Description.length > 40 ? '...' : ''}</td>
                                                <td style="border: 1px solid #e2e8f0; padding: 6px; text-align: center;">${item.SOH.toLocaleString()}</td>
                                                <td style="border: 1px solid #e2e8f0; padding: 6px; text-align: center;">${(item.Recount || 0).toLocaleString()}</td>
                                                <td style="border: 1px solid #e2e8f0; padding: 6px; text-align: center; color: ${item.FinalDiff > 0 ? '#16a34a' : item.FinalDiff < 0 ? '#dc2626' : '#374151'}; font-weight: bold;">
                                                    ${item.FinalDiff > 0 ? '+' : ''}${item.FinalDiff.toLocaleString()}
                                                </td>
                                                <td style="border: 1px solid #e2e8f0; padding: 6px; font-size: 8pt;">${(item.ReasonFinal || '').substring(0, 15)}</td>
                                                <td style="border: 1px solid #e2e8f0; padding: 6px; font-size: 8pt;">${(item.Remark || '').substring(0, 20)}</td>
                                            </tr>
                                        `).join('')}
                                    </tbody>
                                </table>
                                <div style="margin-top: 10px; font-size: 9pt; color: #666;">
                                    * แสดงเฉพาะรายการที่มีผลต่างและรายการ Demo | Total: ${filteredData.length} รายการ
                                </div>
                            </div>`;
                    }                    // Add legal declaration
                    pdfContent.innerHTML += `
                        <div style="margin-top: 40px;">
                            <div style="border: 2px solid #222; border-radius: 8px; background: #f7f7f7; padding: 15px; text-align: center; margin-bottom: 30px;">
                                <p style="margin: 0; font-size: 11pt; line-height: 1.4;">
                                    <strong>คำรับรองและคำประกาศความถูกต้อง</strong><br>
                                    ข้าพเจ้าขอรับรองว่าข้อมูลในรายงานนี้ถูกต้องและครบถ้วนตามสภาพความเป็นจริง<br>
                                    และได้ปฏิบัติตามมาตรฐานการตรวจสอบของบริษัทอย่างเคร่งครัด
                                </p>
                                <p style="margin: 10px 0 0 0; font-size: 10pt; color: #666;">
                                    I certify that the information in this report is accurate and complete<br>
                                    and conducted in accordance with company audit standards
                                </p>
                            </div>
                            
                            <div style="display: flex; justify-content: space-between; margin-top: 40px;">
                                <div style="text-align: center; width: 45%;">
                                    <div style="height: 60px; border-bottom: 1px solid #000; margin-bottom: 10px;"></div>
                                    <div style="margin-bottom: 5px; font-weight: bold;">ลายเซ็นผู้จัดการสาขา</div>
                                    <div style="margin-bottom: 20px; font-size: 10pt;">Branch Manager Signature</div>
                                    <div>วันที่ / Date: _______________</div>
                                </div>
                                <div style="text-align: center; width: 45%;">
                                    <div style="height: 60px; border-bottom: 1px solid #000; margin-bottom: 10px;"></div>
                                    <div style="margin-bottom: 5px; font-weight: bold;">ลายเซ็นผู้ตรวจสอบ</div>
                                    <div style="margin-bottom: 20px; font-size: 10pt;">Auditor Signature</div>
                                    <div>วันที่ / Date: _______________</div>
                                </div>
                            </div>
                        </div>`;                    document.body.appendChild(pdfContent);

                    // Wait for content to render
                    await new Promise(resolve => setTimeout(resolve, 100));                    // Generate PDF with improved html2canvas settings
                    const canvas = await html2canvas(pdfContent, {
                        scale: 1.5, // Reduced scale to prevent memory issues
                        useCORS: true,
                        allowTaint: true,
                        backgroundColor: 'white',
                        width: pdfContent.scrollWidth,
                        height: pdfContent.scrollHeight,
                        logging: false,
                        scrollX: 0,
                        scrollY: 0,
                        windowWidth: 1200,
                        windowHeight: 1600,
                        onclone: (clonedDoc) => {
                            // Ensure fonts are loaded in cloned document
                            const fontLink = clonedDoc.createElement('link');
                            fontLink.href = 'https://fonts.googleapis.com/css2?family=Sarabun:wght@400;500;600;700&display=swap';
                            fontLink.rel = 'stylesheet';
                            clonedDoc.head.appendChild(fontLink);
                        }
                    });

                    // Validate canvas before proceeding
                    if (!canvas || canvas.width === 0 || canvas.height === 0) {
                        throw new Error('Failed to generate canvas - content may be empty or too large');
                    }                    const { jsPDF } = window.jspdf;
                    const pdf = new jsPDF('p', 'mm', 'a4');
                    
                    const imgWidth = 210; // A4 width in mm
                    const pageHeight = 295; // A4 height in mm (slightly less to account for margins)
                    const imgHeight = (canvas.height * imgWidth) / canvas.width;
                    
                    // Generate image data with error handling
                    let imageData;
                    try {
                        imageData = canvas.toDataURL('image/png', 0.92); // Slight compression to reduce size
                        
                        // Validate the image data
                        if (!imageData || imageData === 'data:,') {
                            throw new Error('Failed to generate image data from canvas');
                        }
                    } catch (canvasError) {
                        throw new Error('Canvas to image conversion failed: ' + canvasError.message);
                    }

                    // Add first page
                    try {
                        pdf.addImage(imageData, 'PNG', 0, 0, imgWidth, imgHeight);
                        
                        // Only add additional pages if content significantly exceeds one page
                        if (imgHeight > pageHeight + 5) { // 5mm tolerance
                            let heightLeft = imgHeight - pageHeight;

                            // Add additional pages if needed
                            while (heightLeft > 5) { // Only continue if significant content remains
                                pdf.addPage();
                                const yPosition = -(imgHeight - heightLeft);
                                pdf.addImage(imageData, 'PNG', 0, yPosition, imgWidth, imgHeight);
                                heightLeft -= pageHeight;
                            }
                        }
                    } catch (pdfError) {
                        throw new Error('PDF generation failed: ' + pdfError.message);
                    }

                    // Clean up
                    document.body.removeChild(pdfContent);

                    // Generate filename and download PDF
                    const branchInfo = state.branchCode ? 
                        `${state.branchCode}_${state.branchName.replace(/[^a-zA-Z0-9ก-๙\s]/g, '').replace(/\s+/g, '_')}` : 
                        state.branchName.replace(/[^a-zA-Z0-9ก-๙\s]/g, '').replace(/\s+/g, '_');
                    const dateStr = state.countDate || new Date().toISOString().substring(0, 10);
                    const fileName = `Stock-Count_${branchInfo}_${dateStr}.pdf`;
                    
                    pdf.save(fileName);
                    
                    showModal("Success", `PDF report exported successfully!\n\nItems included:\n• Total items: ${filteredData.length}\n• Discrepancy items: ${summary.discrepancyItems}\n• Demo items: ${summary.demoItems}`);                } catch (error) {
                    console.error('Error generating PDF:', error);
                    
                    // Try fallback method for canvas/PNG errors
                    if (error.message.includes('PNG') || error.message.includes('canvas') || error.message.includes('image')) {
                        console.log('Attempting fallback PDF generation method...');
                        try {
                            // Clean up previous attempt
                            if (document.body.contains(pdfContent)) {
                                document.body.removeChild(pdfContent);
                            }
                            
                            // Use direct jsPDF text method as fallback
                            await generateFallbackPDF(summary, filteredData);
                            return;
                        } catch (fallbackError) {
                            console.error('Fallback method also failed:', fallbackError);
                        }
                    }
                    
                    let errorMessage = 'เกิดข้อผิดพลาดในการสร้าง PDF: ';
                    
                    if (error.message.includes('jsPDF') || error.message.includes('html2canvas')) {
                        errorMessage += 'ไลบรารีที่จำเป็นไม่ได้โหลด กรุณารีเฟรชหน้าและลองใหม่';
                    } else if (error.message.includes('PNG') || error.message.includes('canvas')) {
                        errorMessage += 'ข้อมูลมีขนาดใหญ่เกินไป กรุณาลดจำนวนรายการหรือลองใหม่';
                    } else if (error.message.includes('memory') || error.message.includes('size')) {
                        errorMessage += 'หน่วยความจำไม่เพียงพอ กรุณาปิดแท็บอื่นและลองใหม่';
                    } else {
                        errorMessage += error.message || 'ข้อผิดพลาดไม่ทราบสาเหตุ';
                    }
                    
                    showModal("Error", errorMessage);                } finally {
                    // Restore button to original state
                    if (exportBtn) {
                        exportBtn.innerHTML = originalContent;
                        exportBtn.disabled = false;
                    }
                }
            }
            
            let audioCtx;
            function playSound(type) {
                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if (!audioCtx) return;
                const oscillator = audioCtx.createOscillator(); const gainNode = audioCtx.createGain();
                oscillator.connect(gainNode); gainNode.connect(audioCtx.destination);                if (type === 'success') { oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(600, audioCtx.currentTime); gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime); oscillator.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.05); } 
                else { oscillator.type = 'square'; oscillator.frequency.setValueAtTime(200, audioCtx.currentTime); gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime); oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1); }
                oscillator.start(audioCtx.currentTime); oscillator.stop(audioCtx.currentTime + 0.15);
            }

            let currentScanner = 'barcode'; // Legacy - kept for compatibility
            
            const startTextScanner = async () => {
                try {
                    if (activeStream) {
                        activeStream.getTracks().forEach(track => track.stop());
                    }
                    
                    // Enhanced camera constraints for iPad Gen10 and Apple product scanning
                    const cameraConstraints = {
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 1920, max: 1920 },
                            height: { ideal: 1080, max: 1080 },
                            frameRate: { ideal: 30, max: 30 },
                            focusMode: 'continuous',
                            exposureMode: 'continuous',
                            whiteBalanceMode: 'continuous'
                        }
                    };
                    
                    activeStream = await navigator.mediaDevices.getUserMedia(cameraConstraints);
                    textScannerVideo.srcObject = activeStream;
                    textScannerVideo.play();
                } catch (err) {
                    scannerResultsEl.innerHTML = `<p class="text-red-500">Camera error: ${err.message}</p>`;
                }
            };
            
            function stopTextScanner() {
                // Stop all video tracks from the video element, not just activeStream
                const video = document.getElementById('text-scanner-video');
                if (video && video.srcObject) {
                    const tracks = video.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    video.srcObject = null;
                }
                activeStream = null;
            }
            
            const captureAndRecognize = async () => {
                if (!activeStream || !cvReady) {
                    scannerResultsEl.innerHTML = `<p class="text-red-500">Camera or OpenCV is not ready.</p>`;
                    return;
                }
                scannerResultsEl.innerHTML = `<p class="text-blue-500">กำลังประมวลผลตัวอักษร...</p>`;
                captureBtn.disabled = true;

                const video = textScannerVideo;
                const canvas = document.createElement('canvas');

                // Crop a very narrow, focused region (centered)
                const cropHeightPercentage = 0.10; // Even narrower band (10% of height)
                const cropWidthPercentage = 0.55;  // Focus on center 55% of width
                const sWidth = video.videoWidth * cropWidthPercentage;
                const sHeight = video.videoHeight * cropHeightPercentage;
                const sx = video.videoWidth * (1 - cropWidthPercentage) / 2;
                const sy = video.videoHeight * 0.45; // Centered vertically

                canvas.width = sWidth;
                canvas.height = sHeight;

                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);

                // OpenCV preprocessing: grayscale, contrast, denoise, adaptive threshold
                let src = cv.imread(canvas);
                let gray = new cv.Mat();
                let denoised = new cv.Mat();
                let thresh = new cv.Mat();

                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                cv.equalizeHist(gray, gray); // Contrast
                cv.GaussianBlur(gray, denoised, new cv.Size(3, 3), 0, 0, cv.BORDER_DEFAULT); // Denoise
                cv.adaptiveThreshold(
                    denoised, thresh, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 15, 8
                );

                cv.imshow(canvas, thresh);

                src.delete();
                gray.delete();
                denoised.delete();
                thresh.delete();

                try {
                    const result = await Tesseract.recognize(canvas, 'eng', {
                        logger: m => {
                            if (m.status === 'recognizing text') {
                                scannerResultsEl.innerHTML = `<p class="text-blue-500">${m.status} (${(m.progress * 100).toFixed(0)}%)...</p>`;
                            }
                        },
                        tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-',
                    });

                    // Post-process: Remove spaces, filter by length/pattern
                    let recognizedText = result.data.text.replace(/\s/g, '').toUpperCase();
                    // Accept only if matches expected pattern (8+ alphanum, adjust as needed)
                    const match = recognizedText.match(/[A-Z0-9\-]{8,}/);
                    if (match) {
                        recognizedText = match[0];
                        scannerResultsEl.innerHTML = `<p>Found text: ${recognizedText}</p>`;
                        processScannedCode(recognizedText, 'DEMO-Text Scan');
                    } else {
                        scannerResultsEl.innerHTML = `<p class="text-red-500">ไม่พบตัวอักษรที่ชัดเจน</p>`;
                    }
                } catch (err) {
                    scannerResultsEl.innerHTML = `<p class="text-red-500">OCR Error: ${err.message}</p>`;
                } finally {
                    captureBtn.disabled = false;
                }
            };

            const startOcrStreaming = () => {
                if (ocrStreaming) return;
                ocrStreaming = true;
                scannerResultsEl.innerHTML = '<p class="text-blue-500">กำลังสแกนแบบเรียลไทม์...</p>';
                ocrStreamInterval = setInterval(processOcrFrame, 700); // every 700ms
            };

            const stopOcrStreaming = () => {
                ocrStreaming = false;
                if (ocrStreamInterval) clearInterval(ocrStreamInterval);
                ocrStreamInterval = null;
            };            const processOcrFrame = async () => {
                if (!ocrStreaming || !activeStream || !cvReady) return;
                const video = textScannerVideo;
                if (video.readyState < 2) return;
                
                const startTime = performance.now();
                ocrTotalAttempts++;
                
                const canvas = document.createElement('canvas');
                
                // --- Enhanced Crop Settings for Apple Products ---
                // Optimized crop for Apple serial numbers typically found on back/bottom
                const cropY = video.videoHeight * 0.45;        // Higher up for better Apple serial scanning
                const cropHeight = video.videoHeight * 0.18;   // Taller crop for better text capture
                const cropX = video.videoWidth * 0.05;         // Slight left margin for better frame
                const cropWidth = video.videoWidth * 0.90;     // Wider crop for better coverage
                
                canvas.width = cropWidth;
                canvas.height = cropHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

                // Show cropped preview
                const preview = document.getElementById('ocr-crop-preview');
                if (preview) {
                    preview.width = canvas.width;
                    preview.height = canvas.height;
                    preview.getContext('2d').drawImage(canvas, 0, 0);
                }

                // Check cache first
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const cacheKey = generateCacheKey(imageData, ocrSettings.demo);
                if (ocrResultsCache.has(cacheKey)) {
                    ocrCacheHits++;
                    const cachedResult = ocrResultsCache.get(cacheKey);
                    
                    if (cachedResult.text && cachedResult.text.match(/[A-Z0-9\-]{8,}/)) {
                        scannerResultsEl.innerHTML = `<p>Serial Number: <b>${cachedResult.text}</b> (cached)</p>`;
                        processScannedCode(cachedResult.text, 'DEMO-Text Scan');
                        stopOcrStreaming();
                        return;
                    }
                }

                // --- Enhanced Lighting Detection for Apple Products ---
                let total = 0;
                let pixelCount = 0;
                let contrastSum = 0;
                let prevPixel = 0;
                
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const pixel = (imageData.data[i] + imageData.data[i+1] + imageData.data[i+2]) / 3;
                    total += pixel;
                    pixelCount++;
                    
                    // Calculate contrast for better lighting assessment
                    if (pixelCount > 1) {
                        contrastSum += Math.abs(pixel - prevPixel);
                    }
                    prevPixel = pixel;
                }
                
                const avgBrightness = total / pixelCount;
                const avgContrast = contrastSum / (pixelCount - 1);
                
                // Enhanced lighting feedback for Apple products
                if (avgBrightness < 55) {
                    scannerResultsEl.innerHTML = `<p class="text-yellow-600">ภาพมืดเกินไป กรุณาเพิ่มแสงสว่าง (${avgBrightness.toFixed(0)})</p>`;
                    return;
                } else if (avgBrightness > 220) {
                    scannerResultsEl.innerHTML = `<p class="text-yellow-600">ภาพสว่างเกินไป กรุณาลดแสงสว่าง (${avgBrightness.toFixed(0)})</p>`;
                    return;
                } else if (avgContrast < 15) {
                    scannerResultsEl.innerHTML = `<p class="text-yellow-600">ภาพไม่ชัดเจน กรุณาปรับโฟกัส (${avgContrast.toFixed(0)})</p>`;
                    return;
                }

                // --- Enhanced Preprocessing Algorithms for Apple Products ---
                let src = cv.imread(canvas);
                let dst = new cv.Mat();
                
                if (ocrSettings.demo.preprocessing === 'basic') {
                    // Basic Apple-optimized preprocessing
                    cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);
                    
                    // Apply mild sharpening for Apple serial text
                    const sharpKernel = cv.matFromArray(3, 3, cv.CV_32FC1, [0, -1, 0, -1, 5, -1, 0, -1, 0]);
                    cv.filter2D(dst, dst, -1, sharpKernel);
                    sharpKernel.delete();
                    
                    cv.threshold(dst, dst, 0, 255, cv.THRESH_OTSU | cv.THRESH_BINARY_INV);
                } else if (ocrSettings.demo.preprocessing === 'enhanced') {
                    // Enhanced Apple-optimized preprocessing
                    cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);
                    
                    // CLAHE for better contrast on Apple products
                    const clahe = new cv.CLAHE(2.0, new cv.Size(8, 8));
                    clahe.apply(dst, dst);
                    clahe.delete();
                    
                    // Bilateral filter for noise reduction while preserving edges
                    cv.bilateralFilter(dst, dst, 9, 75, 75);
                    
                    // Unsharp masking for Apple text enhancement
                    const blurred = new cv.Mat();
                    cv.GaussianBlur(dst, blurred, new cv.Size(3, 3), 0, 0, cv.BORDER_DEFAULT);
                    cv.addWeighted(dst, 1.5, blurred, -0.5, 0, dst);
                    blurred.delete();
                    
                    cv.threshold(dst, dst, 0, 255, cv.THRESH_OTSU | cv.THRESH_BINARY_INV);
                } else if (ocrSettings.demo.preprocessing === 'aggressive') {
                    // Aggressive Apple-optimized preprocessing
                    cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);
                    
                    // Advanced CLAHE for difficult lighting
                    const clahe = new cv.CLAHE(3.0, new cv.Size(6, 6));
                    clahe.apply(dst, dst);
                    clahe.delete();
                    
                    // Multiple denoising passes for Apple products
                    cv.fastNlMeansDenoising(dst, dst, 10, 7, 21);
                    
                    // Adaptive bilateral filtering
                    cv.bilateralFilter(dst, dst, 11, 80, 80);
                    
                    // Multi-scale sharpening for Apple text
                    const sharp1 = new cv.Mat();
                    const sharp2 = new cv.Mat();
                    cv.GaussianBlur(dst, sharp1, new cv.Size(3, 3), 0, 0, cv.BORDER_DEFAULT);
                    cv.GaussianBlur(dst, sharp2, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);
                    cv.addWeighted(dst, 2.0, sharp1, -0.5, 0, dst);
                    cv.addWeighted(dst, 1.0, sharp2, -0.5, 0, dst);
                    sharp1.delete();
                    sharp2.delete();
                    
                    // Adaptive thresholding with morphological operations
                    cv.adaptiveThreshold(dst, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 6);
                    
                    // Morphological operations optimized for Apple text
                    const kernel1 = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2, 2));
                    const kernel2 = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 1));
                    cv.morphologyEx(dst, dst, cv.MORPH_CLOSE, kernel1);
                    cv.morphologyEx(dst, dst, cv.MORPH_OPEN, kernel2);
                    kernel1.delete();
                    kernel2.delete();
                }
                  cv.imshow(canvas, dst);
                src.delete();
                dst.delete();
                
                try {
                    if (!tesseractWorker) {
                        await initTesseract(ocrSettings.demo.language, true);
                    }
                    
                    // --- Enhanced OCR Processing for Apple Products ---
                    const result = await tesseractWorker.recognize(canvas);
                    const processingTime = performance.now() - startTime;
                    
                    let text = result.data.text.replace(/\s/g, '').toUpperCase();
                    let confidence = result.data.confidence;
                    
                    // --- Apple-specific Text Post-processing ---
                    // Remove common OCR artifacts for Apple serials
                    text = text.replace(/[|]/g, 'I')      // Common OCR mistake
                             .replace(/[0]/g, 'O')       // Zero to O confusion
                             .replace(/[8]/g, 'B')       // Eight to B confusion
                             .replace(/[5]/g, 'S')       // Five to S confusion
                             .replace(/[1]/g, 'I')       // One to I confusion
                    
                    // Update performance tracking
                    ocrPerformanceHistory.push({ time: processingTime, confidence, success: false });
                    if (ocrPerformanceHistory.length > 50) ocrPerformanceHistory.shift();
                    
                    // Process validation results
                    
                    // --- Enhanced Apple Serial Validation ---
                    const appleSerialMatch = text.match(/[A-Z0-9\-]{8,}/);
                    const isValidAppleSerial = appleSerialMatch && (
                        text.length >= 8 && text.length <= 14 &&
                        /[A-Z]/.test(text) &&      // Must contain letters
                        /[0-9]/.test(text) &&      // Must contain numbers
                        !/[^A-Z0-9\-]/.test(text)  // Only valid characters
                    );
                    
                    if (isValidAppleSerial && confidence >= ocrSettings.demo.confidence) {
                        const finalText = appleSerialMatch[0];
                        
                        // Cache successful result
                        ocrResultsCache.set(cacheKey, { text: finalText, confidence, timestamp: Date.now() });
                        
                        // Learn successful pattern
                        learnSuccessPattern(finalText, confidence, processingTime);
                        
                        // Update success tracking
                        ocrSuccessCount++;
                        ocrPerformanceHistory[ocrPerformanceHistory.length - 1].success = true;
                        
                        
                        scannerResultsEl.innerHTML = `<p>Apple Serial: <b>${finalText}</b></p>`;
                        processScannedCode(finalText, 'DEMO-Text Scan');
                        stopOcrStreaming();
                    } else {
                        scannerResultsEl.innerHTML = `<p class='text-blue-500'>Scanning Apple products... (${confidence.toFixed(1)}%)</p>`;
                    }
                    
                    // Adaptive settings based on performance
                    if (ocrPerformanceHistory.length > 0 && ocrPerformanceHistory.length % 10 === 0) {
                        adaptiveOcrSettings(ocrPerformanceHistory, true);
                    }
                } catch (err) {
                    handleOcrError(err, true);
                    scannerResultsEl.innerHTML = `<p class='text-red-500'>Apple OCR Error: ${err.message}</p>`;
                }
            };

            const startBarcodeScanner = () => {
                 Quagga.init({ inputStream: { name: "Live", type: "LiveStream", target: getEl('qr-reader'), constraints: { facingMode: "environment" } }, decoder: { readers: [ "code_128_reader", "ean_reader", "ean_8_reader", "code_39_reader", "upc_reader", "upc_e_reader" ] }, locate: true }, (err) => { if (err) { scannerResultsEl.innerHTML = `<p class="text-red-500">Camera error: ${err.message}</p>`; return; } Quagga.start(); });
                 Quagga.onDetected(onBarcodeDetected);
            };
            
            function stopBarcodeScanner() {
                if (typeof Quagga !== 'undefined' && Quagga.running) {
                    Quagga.offDetected(onBarcodeDetected);
                    Quagga.stop();
                }
                // Extra cleanup: stop video tracks from Quagga's video element
                const quaggaVideo = document.querySelector('#qr-reader video');
                if (quaggaVideo && quaggaVideo.srcObject) {
                    quaggaVideo.srcObject.getTracks().forEach(track => track.stop());
                    quaggaVideo.srcObject = null;
                }
            }
              const openScannerModal = () => {
                openFloatingScanner('demo');
            };            const closeScannerModal = () => {
                // Legacy function - now handled by floating scanner
                closeFloatingScanner();
            };const processScannedCode = (code, reason) => {
                const scannedText = code.toUpperCase();
                
                // Use shared matching function for enhanced Apple product matching
                let item = findItemByScannedText(state.demoMaster, scannedText);

                if (item) {
                    playSound('success');
                    let currentCount = typeof item.counted === 'number' ? item.counted : 0;
                    item.counted = currentCount + 1;
                    state.demoCounts[item.SKU] = { qty: item.counted, reason: reason };                    applyDemoView();
                    const row = getEl('demo-count-container').querySelector(`tr[data-sku="${item.SKU}"]`);
                    if (row) {
                        row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        row.classList.add('ring-2', 'ring-offset-2', 'ring-green-500');
                        setTimeout(() => row.classList.remove('ring-2', 'ring-offset-2', 'ring-green-500'), 800);
                    }
                    
                    // Also highlight mobile card
                    const card = getEl('demo-count-cards').querySelector(`[data-sku="${item.SKU}"]`);
                    if (card) {
                        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        card.classList.add('ring-2', 'ring-offset-2', 'ring-green-500');
                        setTimeout(() => card.classList.remove('ring-2', 'ring-offset-2', 'ring-green-500'), 800);
                    }
                    
                    const diff = item.counted - item.SOH;
                    let statusText = (diff === 0) ? 'Matched' : (diff > 0) ? 'Overage' : 'Shortage';
                    let statusColor = (diff === 0) ? 'text-green-600' : (diff > 0) ? 'text-yellow-600' : 'text-blue-600';
                    scannerResultsEl.innerHTML = `<div class="text-left w-full space-y-1"><p class="font-medium text-slate-800">${item.Description}</p><p class="text-sm text-slate-500">SKU: ${item.SKU}</p><div class="flex justify-between items-baseline pt-1"><span class="text-lg font-bold text-slate-700">Count: <span class="text-blue-600">${item.counted}</span> / ${item.SOH}</span><span class="text-lg font-bold ${statusColor}">${statusText}</span></div></div>`;
                } else {
                    playSound('error');
                    scannerResultsEl.innerHTML = `<div class="text-center w-full"><p class="font-bold text-red-600">SKU Not Found</p><p class="text-sm text-slate-500">${scannedText}</p></div>`;
                }
            };
            
            const scanCooldown = {};
            const onBarcodeDetected = (result) => {
                const code = result.codeResult.code.trim();
                const now = Date.now(); if (scanCooldown[code] && now - scanCooldown[code] < 10000) return;
                scanCooldown[code] = now;
                processScannedCode(code, 'DEMO-Barcode');
            };
              function initializeAppListeners() {
                function addListener(id, event, handler) {
                    const el = getEl(id);
                    if (el) {
                        el.addEventListener(event, handler);
                    }
                }

                // Export SOH Excel functionality
                function exportSohExcel() {
                    try {
                        // Use the same processed data as the app (sohLookup)
                        const allItems = Object.values(state.sohLookup).filter(item => item.SOH > 0);
                          if (allItems.length === 0) {
                            showModal("Warning", "No SOH data available to export");
                            return;
                        }                        // Sort to ensure non-DEMO items appear first, then DEMO items, then by SKU within each group
                        allItems.sort((a, b) => {
                            // First sort by isDemo flag (non-DEMO first)
                            if (a.isDemo !== b.isDemo) {
                                return a.isDemo - b.isDemo;
                            }
                            // Then sort by SKU alphabetically within each group
                            return a.SKU.localeCompare(b.SKU);
                        });

                        // Debug logging to verify sorting
                        console.log('SOH Excel Export Debug:');
                        console.log(`Total items: ${allItems.length}`);
                        const demoCount = allItems.filter(item => item.isDemo).length;
                        const nonDemoCount = allItems.length - demoCount;
                        console.log(`Non-DEMO items: ${nonDemoCount}, DEMO items: ${demoCount}`);
                        console.log('First 5 items:', allItems.slice(0, 5).map(item => ({ SKU: item.SKU, isDemo: item.isDemo })));
                        console.log('Last 5 items:', allItems.slice(-5).map(item => ({ SKU: item.SKU, isDemo: item.isDemo })));
                          // Prepare data for export - use existing isDemo flag
                        const rows = allItems.map(item => {
                            return {
                                SKU: item.SKU,
                                Description: item.Description,
                                SRP: item.Price,
                                Age: item.Age,
                                SOH: item.SOH,
                                FAMILY: item.isDemo ? 'DEMO' : 'NONE'
                            };
                        });
                        const ws = XLSX.utils.json_to_sheet(rows);
                        const wb = XLSX.utils.book_new();
                        XLSX.utils.book_append_sheet(wb, ws, "SOH Export");
                        
                        // Use new file naming convention: countdate_function_branchcode_branchname
                        const branchInfo = state.branchCode ? `${state.branchCode}_${state.branchName.replace(/\s+/g, '_')}` : state.branchName.replace(/\s+/g, '_');
                        const filename = `${state.countDate || new Date().toISOString().split('T')[0]}_SOH_Export_${branchInfo}.xlsx`;
                        XLSX.writeFile(wb, filename);
                          showModal("Success", `Successfully exported ${allItems.length} items to ${filename}`);
                    } catch (error) {
                        // Export SOH Excel error handled silently for production
                        showModal("Error", "Failed to export SOH Excel file");
                    }
                }
                  addListener('newJobButton', 'click', startNewJob);
                addListener('save-progress-button', 'click', handleSaveProgressToFile);
                addListener('main-tab-demo', 'click', () => switchMainTab('demo'));
                addListener('main-tab-workflow', 'click', () => switchMainTab('workflow'));
                addListener('main-tab-spp', 'click', () => switchMainTab('spp'));
                addListener('downloadMasterForScan', 'click', downloadMasterForScan);
                addListener('processFirstCount', 'click', processFirstCount);
                addListener('finalizeFromFirstCount', 'click', finalizeFromFirstCount);
                addListener('generateRecountMasterFile', 'click', generateRecountMasterFile);
                addListener('processSecondCount', 'click', processSecondCount);
                addListener('exportCsvButton', 'click', exportFinalReport);
                addListener('exportJsonButton', 'click', exportStockCountToJSON);
                addListener('refreshChartsButton', 'click', renderFinalReportCharts);                addListener('exportDemoCsvButton', 'click', exportDemoTable);
                addListener('importDemoCsvButton', 'click', () => getEl('importDemoCsvFile').click());
                addListener('importDemoCsvFile', 'change', importDemoCountCsv);
                addListener('debugDataButton', 'click', debugDataCategorization);
                addListener('exportSohExcelBtn', 'click', exportSohExcel);
                addListener('openScannerBtn', 'click', openScannerModal);
                addListener('openScannerBtn-spp-spare-parts', 'click', () => openFloatingScanner('spp-spare-parts'));
                addListener('openScannerBtn-spp-glue', 'click', () => openFloatingScanner('spp-glue'));
                addListener('openScannerBtn-spp-tools', 'click', () => openFloatingScanner('spp-tools'));                addListener('final-openScannerBtn', 'click', finalOpenScannerModal);
                // closeScannerBtn removed - handled by floating scanner
                addListener('export-pdf-btn', 'click', exportToPDF);                
                // Scanner tab switching removed - handled by floating scanner
                // Capture button removed - handled by floating scanner                
                // Add debounced search event listeners for better performance
                let searchDebounceTimers = {};
                
                function debounceSearch(searchInputId, viewFunction, delay = 300) {
                    return function() {
                        clearTimeout(searchDebounceTimers[searchInputId]);
                        searchDebounceTimers[searchInputId] = setTimeout(viewFunction, delay);
                    };
                }
                
                addListener('demoSearchInput', 'keyup', debounceSearch('demo', applyDemoView));
                addListener('demoFilterSelect', 'change', applyDemoView);
                addListener('demoGroupCodeFilter', 'change', applyDemoView);
                addListener('demoAgeFilter', 'change', applyDemoView);
                addListener('demoSubclassFilter', 'change', applyDemoView);
                
                addListener('finalSearchInput', 'keyup', debounceSearch('final', applyFinalReportView));
                addListener('finalFilterSelect', 'change', applyFinalReportView);
                addListener('finalGroupCodeFilter', 'change', applyFinalReportView);
                addListener('finalAgeFilter', 'change', applyFinalReportView);
                addListener('finalSubclassFilter', 'change', applyFinalReportView);                
                // SPP Search and Filter Event Listeners
                addListener('sppSparePartsSearchInput', 'keyup', debounceSearch('sppSpareParts', applySppSparePartsView));
                addListener('sppSparePartsFilterSelect', 'change', applySppSparePartsView);
                addListener('sppSparePartsGroupCodeFilter', 'change', applySppSparePartsView);
                addListener('sppSparePartsAgeFilter', 'change', applySppSparePartsView);
                addListener('sppSparePartsSubclassFilter', 'change', applySppSparePartsView);
                
                addListener('sppGlueSearchInput', 'keyup', applySppGlueView);
                addListener('sppGlueFilterSelect', 'change', applySppGlueView);
                addListener('sppGlueGroupCodeFilter', 'change', applySppGlueView);
                addListener('sppGlueAgeFilter', 'change', applySppGlueView);
                addListener('sppGlueSubclassFilter', 'change', applySppGlueView);
                
                addListener('sppToolsSearchInput', 'keyup', applySppToolsView);
                addListener('sppToolsFilterSelect', 'change', applySppToolsView);
                addListener('sppToolsGroupCodeFilter', 'change', applySppToolsView);
                addListener('sppToolsAgeFilter', 'change', applySppToolsView);
                addListener('sppToolsSubclassFilter', 'change', applySppToolsView);                
                // SPP CSV Export Event Listeners
                addListener('exportSppSparePartsCsvButton', 'click', exportSppSparePartsTable);
                addListener('exportSppGlueCsvButton', 'click', exportSppGlueTable);
                addListener('exportSppToolsCsvButton', 'click', exportSppToolsTable);
                
                // SPP CSV Import Event Listeners
                addListener('importSppSparePartsCsvButton', 'click', () => getEl('importSppSparePartsCsvFile').click());
                addListener('importSppGlueCsvButton', 'click', () => getEl('importSppGlueCsvFile').click());
                addListener('importSppToolsCsvButton', 'click', () => getEl('importSppToolsCsvFile').click());
                addListener('importSppSparePartsCsvFile', 'change', importSppSparePartsCsv);
                addListener('importSppGlueCsvFile', 'change', importSppGlueCsv);
                addListener('importSppToolsCsvFile', 'change', importSppToolsCsv);
                
                addListener('load-progress-file', 'change', handleLoadProgressFromFile);
                addListener('initialSohFile', 'change', handleSohFileUpload);                
                addListener('firstScanLogfile', 'change', () => updateFirstCountButton());
                addListener('firstMasterFile', 'change', () => updateFirstCountButton());
                addListener('salesDataFile', 'change', () => getEl('processSalesData').disabled = getEl('salesDataFile').files.length === 0);
                addListener('processSalesData', 'click', processSalesData);
                addListener('latestSohFile', 'change', handleLatestSohUpload);                
                addListener('secondScanLogfile', 'change', () => updateSecondCountButton());
                addListener('secondMasterFile', 'change', () => updateSecondCountButton());

                function updateSecondCountButton() {
                    const logFiles = getEl('secondScanLogfile').files.length > 0;
                    const masterFile = getEl('secondMasterFile').files.length > 0;
                    
                    // Enable button if at least one file type is uploaded
                    getEl('processSecondCount').disabled = !(logFiles || masterFile);
                }                function updateFirstCountButton() {
                    const logFiles = getEl('firstScanLogfile').files.length > 0;
                    const masterFile = getEl('firstMasterFile').files.length > 0;
                      // Enable button if at least one file type is uploaded
                    getEl('processFirstCount').disabled = !(logFiles || masterFile);
                }

                addListener('wf-step-tabs', 'click', e => { if (e.target.id.startsWith('wf-tab-btn-')) changeWorkflowTab(e.target.id.slice(-1)); });
                addListener('demo-count-container', 'click', e => { const header = e.target.closest('th[data-sort-by]'); if (header) handleSort('demoSort', header.dataset.sortBy, applyDemoView); });
                addListener('demo-count-container', 'input', e => { const { target: input } = e; const sku = input.closest('tr').dataset.sku; if (input.matches('input[type="number"]')) updateDemoCount(sku, input.value); else if (input.matches('input[type="text"]')) updateDemoRemark(sku, input.value); });
                addListener('final-report-table-container', 'click', e => { const header = e.target.closest('th[data-sort-by]'); if (header) handleSort('finalReportSort', header.dataset.sortBy, applyFinalReportView); });
                addListener('final-report-table-container', 'input', e => { const { target: input } = e; const sku = input.closest('tr').dataset.sku; if (input.matches('input[type="number"]')) updateFinalCount(sku, input.value); else if (input.matches('input[type="text"]')) updateRemark(sku, input.value); });
                
                // SPP Table Event Listeners
                addListener('spp-spare-parts-container', 'click', e => { const header = e.target.closest('th[data-sort-by]'); if (header) handleSort('sppSparePartsSort', header.dataset.sortBy, applySppSparePartsView); });
                addListener('spp-spare-parts-container', 'input', e => { const { target: input } = e; const sku = input.closest('tr').dataset.sku; if (input.matches('input[type="number"]')) updateSppSparePartsCount(sku, input.value); else if (input.matches('input[type="text"]')) updateSppSparePartsRemark(sku, input.value); });
                
                addListener('spp-glue-container', 'click', e => { const header = e.target.closest('th[data-sort-by]'); if (header) handleSort('sppGlueSort', header.dataset.sortBy, applySppGlueView); });
                addListener('spp-glue-container', 'input', e => { const { target: input } = e; const sku = input.closest('tr').dataset.sku; if (input.matches('input[type="number"]')) updateSppGlueCount(sku, input.value); else if (input.matches('input[type="text"]')) updateSppGlueRemark(sku, input.value); });
                  addListener('spp-tools-container', 'click', e => { const header = e.target.closest('th[data-sort-by]'); if (header) handleSort('sppToolsSort', header.dataset.sortBy, applySppToolsView); });                addListener('spp-tools-container', 'input', e => { const { target: input } = e; const sku = input.closest('tr').dataset.sku; if (input.matches('input[type="number"]')) updateSppToolsCount(sku, input.value); else if (input.matches('input[type="text"]')) updateSppToolsRemark(sku, input.value); });
                
                // SPP Mobile Card Event Listeners
                addListener('spp-spare-parts-cards', 'input', e => { 
                    const { target: input } = e; 
                    const sku = input.closest('[data-sku]').dataset.sku; 
                    if (input.matches('input[type="number"]')) updateSppSparePartsCount(sku, input.value); 
                    else if (input.matches('input[type="text"]')) updateSppSparePartsRemark(sku, input.value); 
                });
                
                addListener('spp-glue-cards', 'input', e => { 
                    const { target: input } = e; 
                    const sku = input.closest('[data-sku]').dataset.sku; 
                    if (input.matches('input[type="number"]')) updateSppGlueCount(sku, input.value); 
                    else if (input.matches('input[type="text"]')) updateSppGlueRemark(sku, input.value); 
                });
                  addListener('spp-tools-cards', 'input', e => { 
                    const { target: input } = e; 
                    const sku = input.closest('[data-sku]').dataset.sku; 
                    if (input.matches('input[type="number"]')) updateSppToolsCount(sku, input.value); 
                    else if (input.matches('input[type="text"]')) updateSppToolsRemark(sku, input.value);
                });
                
                // Demo and Final Report Mobile Card Event Listeners
                addListener('demo-count-cards', 'input', e => { 
                    const { target: input } = e; 
                    const sku = input.closest('[data-sku]').dataset.sku; 
                    if (input.matches('input[type="number"]')) updateDemoCount(sku, input.value); 
                    else if (input.matches('input[type="text"]')) updateDemoRemark(sku, input.value); 
                });
                
                addListener('final-report-cards', 'input', e => { 
                    const { target: input } = e; 
                    const sku = input.closest('[data-sku]').dataset.sku; 
                    if (input.matches('input[type="number"]')) updateFinalCount(sku, input.value); 
                    else if (input.matches('input[type="text"]')) updateRemark(sku, input.value); 
                });

                // === Enter Key Handling ===
                const handleEnter = (event) => { if (event.key === 'Enter') { const allInputs = Array.from(event.currentTarget.querySelectorAll('input[type="number"], input[type="text"]')); const currentIndex = allInputs.indexOf(event.target); if (currentIndex > -1 && currentIndex < allInputs.length - 1) allInputs[currentIndex + 1].focus(); } };
                addListener('demo-count-container', 'keydown', handleEnter);
                addListener('final-report-table-container', 'keydown', handleEnter);
                  // Add Enter key handling for SPP tables
                addListener('spp-spare-parts-container', 'keydown', handleEnter);
                addListener('spp-glue-container', 'keydown', handleEnter);
                addListener('spp-tools-container', 'keydown', handleEnter);
                  // Add Enter key handling for SPP mobile cards
                addListener('spp-spare-parts-cards', 'keydown', handleEnter);
                addListener('spp-glue-cards', 'keydown', handleEnter);
                addListener('spp-tools-cards', 'keydown', handleEnter);
                
                // Add Enter key handling for Demo and Final Report mobile cards
                addListener('demo-count-cards', 'keydown', handleEnter);
                addListener('final-report-cards', 'keydown', handleEnter);

                // === OCR Enhancement Event Listeners ===
                // Demo scanner OCR controls
                addListener('ocr-confidence-slider', 'input', (e) => {
                    ocrSettings.demo.confidence = parseInt(e.target.value);
                    document.getElementById('ocr-confidence-value').textContent = e.target.value + '%';
                });
                addListener('ocr-speed-select', 'change', (e) => {
                    ocrSettings.demo.speed = parseInt(e.target.value);
                    if (ocrStreamInterval) {
                        clearInterval(ocrStreamInterval);
                        ocrStreamInterval = setInterval(processOcrFrame, ocrSettings.demo.speed);
                    }
                });                addListener('ocr-language-select', 'change', async (e) => {
                    ocrSettings.demo.language = e.target.value;
                    if (tesseractWorker) {
                        await initTesseract(ocrSettings.demo.language, true);
                    }
                });
                
                addListener('ocr-preprocessing-select', 'change', (e) => {
                    ocrSettings.demo.preprocessing = e.target.value;
                });

                // Final scanner OCR controls
                addListener('final-ocr-confidence-slider', 'input', (e) => {
                    ocrSettings.final.confidence = parseInt(e.target.value);
                    document.getElementById('final-ocr-confidence-value').textContent = e.target.value + '%';
                });
                addListener('final-ocr-speed-select', 'change', (e) => {
                    ocrSettings.final.speed = parseInt(e.target.value);
                    if (finalOcrStreaming) {
                        clearInterval(finalOcrStreamInterval);
                        finalOcrStreamInterval = setInterval(finalProcessOcrFrame, ocrSettings.final.speed);
                    }
                });
                addListener('final-ocr-language-select', 'change', async (e) => {
                    ocrSettings.final.language = e.target.value;                    if (finalTesseractWorker) {
                        await initTesseract(ocrSettings.final.language, false);
                    }
                });
                
                addListener('final-ocr-preprocessing-select', 'change', (e) => {
                    ocrSettings.final.preprocessing = e.target.value;
                });

                window.addEventListener('beforeunload', (e) => { if (hasUnsavedChanges) e.preventDefault(); });
            }
            
            initializeAppListeners();
            
            // === Initialize Floating Scanner ===
            
            function setupFloatingScanner() {
                floatingScanner = document.getElementById('floating-scanner');
                if (floatingScanner) {
                    // Call the actual initialization function
                    initializeFloatingScanner();
                } else {
                    // Floating scanner element not found - handled silently for production
                    // Retry after a short delay in case DOM is still loading
                    setTimeout(() => {
                        floatingScanner = document.getElementById('floating-scanner');
                        if (floatingScanner) {
                            initializeFloatingScanner();
                        }                    }, 100);
                }
            }
            
            // Initialize floating scanner after DOM is ready
            setupFloatingScanner();
            
            // --- Final Report Scanner Logic ---
              function finalOpenScannerModal() {
                openFloatingScanner('final');
            }

            function finalCloseScannerModal() {
                // Legacy function - now handled by floating scanner
                closeFloatingScanner();
            }

            const finalScanCooldown = {};
            function finalOnBarcodeDetected(result) {
                const code = result.codeResult.code.trim();
                const now = Date.now();
                if (finalScanCooldown[code] && now - finalScanCooldown[code] < 10000) return;
                finalScanCooldown[code] = now;
                processFinalScannedCode(code, 'Barcode');            }
            
            function processFinalScannedCode(code, reason) {
                const scannedText = code.toUpperCase();
                  // Use shared matching function for enhanced Apple product matching
                let item = findItemByScannedText(state.reconciledData, scannedText);
                
                if (item) {
                    playSound('success');
                    finalScannerResultsEl.innerHTML = `<div class="text-left w-full space-y-1"><p class="font-medium text-slate-800">${item.Description}</p><p class="text-sm text-slate-500">SKU: ${item.SKU}</p><div class="flex justify-between items-baseline pt-1"><span class="text-lg font-bold text-slate-700">Counted: <span class="text-blue-600">${item.Recount}</span> / ${item.SOH}</span><span class="text-lg font-bold">${item.FinalDiff === 0 ? '<span class="text-green-600">Matched</span>' : item.FinalDiff > 0 ? '<span class="text-yellow-600">Overage</span>' : '<span class="text-blue-600">Shortage</span>'}</span></div></div>`;
                    const row = document.querySelector(`#final-report-table-container tr[data-sku="${item.SKU}"]`);
                    if (row) {
                        row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        row.classList.add('ring-2', 'ring-offset-2', 'ring-green-500');
                        setTimeout(() => row.classList.remove('ring-2', 'ring-offset-2', 'ring-green-500'), 800);
                    }
                    
                    // Also highlight mobile card
                    const card = document.querySelector(`#final-report-cards [data-sku="${item.SKU}"]`);
                    if (card) {
                        card.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        card.classList.add('ring-2', 'ring-offset-2', 'ring-green-500');
                        setTimeout(() => card.classList.remove('ring-2', 'ring-offset-2', 'ring-green-500'), 800);
                    }
                } else {                    playSound('error');
                    finalScannerResultsEl.innerHTML = `<div class="text-center w-full"><p class="font-bold text-red-600">SKU Not Found</p><p class="text-sm text-slate-500">${scannedText}</p></div>`;
                }
            }
            // Debug function to verify data categorization
            function debugDataCategorization() {
                console.group('Data Categorization Debug');
                
                console.log('Demo Master Count:', state.demoMaster?.length || 0);
                console.log('SPP Spare Parts Master Count:', state.sppSparePartsMaster?.length || 0);
                console.log('SPP Glue Master Count:', state.sppGlueMaster?.length || 0);
                console.log('SPP Tools Master Count:', state.sppToolsMaster?.length || 0);
                console.log('Reconciled Data Count:', state.reconciledData?.length || 0);
                
                if (state.demoMaster?.length > 0) {
                    const demoFlags = state.demoMaster.map(item => item.isDemo);
                    console.log('Demo Master isDemo flags:', [...new Set(demoFlags)]);
                    
                    const nonDemoInDemo = state.demoMaster.filter(item => !item.isDemo);
                    if (nonDemoInDemo.length > 0) {
                        console.warn('Found non-DEMO items in DEMO master:', nonDemoInDemo.map(item => ({ SKU: item.SKU, isDemo: item.isDemo })));
                    }
                }
                
                if (state.sppSparePartsMaster?.length > 0) {
                    const sppFlags = state.sppSparePartsMaster.map(item => item.isDemo);
                    console.log('SPP Spare Parts isDemo flags:', [...new Set(sppFlags)]);
                    
                    const demoInSpp = state.sppSparePartsMaster.filter(item => item.isDemo);
                    if (demoInSpp.length > 0) {
                        console.warn('Found DEMO items in SPP Spare Parts master:', demoInSpp.map(item => ({ SKU: item.SKU, isDemo: item.isDemo })));
                    }
                }
                
                if (state.reconciledData?.length > 0) {
                    const demoCount = state.reconciledData.filter(item => item.isDemo).length;
                    const nonDemoCount = state.reconciledData.filter(item => !item.isDemo).length;
                    console.log(`Reconciled Data: ${demoCount} DEMO, ${nonDemoCount} non-DEMO items`);
                }
                
                console.groupEnd();
            }        });        
        
        // Initialize authentication and tool access
        document.addEventListener('DOMContentLoaded', async function() {
            try {
                // Initialize Firebase first
                await SPViAuth.initializeFirebase();
                
                // Check authentication - redirect to login if not authenticated
                const isAuthenticated = await SPViAuth.checkAuthentication();
                if (!isAuthenticated) {
                    window.location.href = '../index.html';
                    return;
                }
                
                // Initialize dev tools protection
                SPViAuth.setupDevToolsProtection();                // Check tool access permission after authentication is confirmed
                if (window.SPViSessionManager && window.SPViSessionManager.checkToolAccess) {
                    const hasAccess = await window.SPViSessionManager.checkToolAccess('stockCount');
                    if (!hasAccess) {
                        // Access denied - modal will be shown by checkToolAccess function
                        // Optionally hide main content
                        document.querySelector('main')?.style.setProperty('display', 'none');
                    }
                }
            } catch (error) {
                // Authentication error handled silently for production
                // If authentication fails, redirect to login
                window.location.href = '../index.html';
            }
        });
    </script>
</body>
</html>