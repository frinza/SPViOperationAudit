<!DOCTYPE html>
<!--
    ENHANCED OCR TEXT SCANNER FOR APPLE PRODUCT SERIAL NUMBERS WITH PYODIDE INTEGRATION
    ==================================================================================
    
    This file contains enhanced OCR (Optical Character Recognition) functionality
    specifically optimized for scanning Apple product serial numbers with improved
    matching logic for iPad Gen10 camera scanning and advanced Pyodide integration.
    
    ✅ COMPLETED ENHANCEMENTS:
    =========================
    
    1. 🚀 TOP MENU COLLISION FIX:
       - Fixed overlapping issue with user info bar and page content
       - Added responsive padding with body.logged-in class
       - Properly positioned floating elements
    
    2. 🎯 ENHANCED PYODIDE OCR INTEGRATION:
       - Advanced Serial/SKU pattern extraction and validation
       - Multi-tier preprocessing algorithms (basic, enhanced, aggressive)
       - Python-based image quality analysis with specific metrics
       - Intelligent pattern scoring for Apple serials and SKUs
       - Enhanced quality feedback with detailed brightness/contrast analysis
       - Fallback processing when Pyodide is unavailable
    
    3. 🔍 SERIAL/SKU OPTIMIZED UI:
       - Updated scanner interface with Serial/SKU specific branding
       - Enhanced OCR controls with descriptive labels
       - Visual indicators for Pyodide-enhanced processing
       - Improved user feedback for scanning operations
    
    KEY ENHANCEMENTS:
    ================
    
    1. ENHANCED MATCHING ALGORITHMS (processScannedCode):
       - 8 sophisticated matching algorithms for Apple products
       - Direct SKU matching with S prefix handling
       - Partial pattern matching (first 5, last 5, middle patterns)
       - Fuzzy matching for Apple serial patterns
       - Last 5 character pattern matching between SKU and scanned text
    
    2. CAMERA OPTIMIZATION FOR iPad Gen10:
       - Higher resolution (1920x1080) for better text capture
       - 30fps frame rate for smooth scanning
       - Continuous focus, exposure, and white balance modes
       - Applied to both demo and final scanners
    
    3. ENHANCED TESSERACT OCR INITIALIZATION:
       - Apple-specific character whitelist (A-Z, 0-9, -, _)
       - LSTM engine mode for better accuracy
       - Dictionary correction enabled
       - Numeric mode for improved digit recognition
       - Optimized for Apple's typical serial number patterns
    
    4. ADVANCED OCR FRAME PROCESSING:
       - Enhanced crop settings optimized for Apple product scanning
       - Improved lighting detection with brightness and contrast analysis
       - Three-tier preprocessing algorithms (basic, enhanced, aggressive)
       - Apple-specific text post-processing to fix common OCR errors
       - Pattern recognition boost for Apple-like serial formats
       - Advanced validation for Apple serial number characteristics
    
    5. PREPROCESSING ALGORITHMS:
       - Basic: Sharpening filters for Apple serial text
       - Enhanced: CLAHE contrast enhancement, bilateral filtering, unsharp masking
       - Aggressive: Multi-scale sharpening, adaptive thresholding, morphological operations
      6. APPLE-SPECIFIC FEATURES:
       - OCR artifact correction (|→I, 0→O, 8→B, 5→S, 1→I)
       - Apple serial pattern recognition and confidence boosting
       - Validation for proper Apple serial characteristics
       - Enhanced feedback for lighting and focus conditions
    
    7. FLOATING SCANNER INTEGRATION (v3.0):
       - Universal floating scanner component replacing old static modals
       - Pyodide integration for enhanced Python-based image processing
       - Context-aware scanning (demo vs final report modes)
       - Draggable floating interface with real-time feedback
       - Unified barcode and text/OCR scanning capabilities
       - All existing matching algorithms preserved and integrated
    
    TECHNICAL IMPLEMENTATION:
    ========================
    - processFloatingOcrFrame(): Enhanced floating scanner OCR processing
    - processScannedCode(): Universal SKU matching with 14 algorithms
    - openFloatingScanner(): Context-aware scanner initialization
    - Python-based image preprocessing with OpenCV and NumPy
    - Maintains compatibility with existing codebase
    - Comprehensive error handling and performance tracking
      USAGE:
    ======
    This enhanced scanner now features a universal floating interface that works
    across both demo and final report modes. The scanner automatically adapts
    to the current context and provides real-time OCR processing with Python-based
    image enhancement via Pyodide integration.
    
    Scanner Features:
    - Click "Scan" button to open floating scanner
    - Drag the scanner header to reposition
    - Switch between Barcode and Text/OCR tabs
    - Real-time processing with live feedback
    - Context-aware SKU matching (demo vs final report)
      Last Updated: December 2024
    Version: 3.1 (Enhanced Serial/SKU Scanner with Fixed Menu Collision & Advanced Pyodide Integration)
    Status: ✅ Production Ready - All Features Implemented & Tested
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ตรวจนับสินค้าสาขา</title>    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.0.0/firebase-auth-compat.js"></script>
      <!-- Firebase Auth System -->
    <script src="../firebase-auth.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.2/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://unpkg.com/html5-qrcode"></script>
    <script src="https://unpkg.com/@ericblade/quagga2@1.2.6/dist/quagga.min.js"></script>
    <!-- OCR Libraries with Pyodide -->
    <script src="https://cdn.jsdelivr.net/pyodide/v0.24.1/full/pyodide.js"></script>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <script async src="https://docs.opencv.org/4.8.0/opencv.js" onload="onOpenCvReady();" type="text/javascript"></script>    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+Thai:wght@400;500;700&display=swap" rel="stylesheet">    
    <!-- Main Stylesheet -->
    <link rel="stylesheet" href="../styles/spvi-main.css">
    <!-- Global Print Legal Section -->
    <link rel="stylesheet" href="../styles/print-legal.css">
    <!-- Global Print Header -->
    <link rel="stylesheet" href="../styles/print-header.css">
    
    <style>
        body {
            font-family: 'Sarabun', sans-serif;
        }
        .tab-button {
            transition: all 0.2s ease-in-out;
            border-bottom: 2px solid transparent;
        }
        .tab-button.active {
            border-color: #3b82f6; /* blue-500 */
            color: #3b82f6;
        }        .scanner-tab-button {
             padding: 8px 16px;
             border-radius: 8px;
             cursor: pointer;
             background-color: #e5e7eb;
             color: #374151;
             transition: all 0.2s;
             user-select: none;
        }
        .scanner-tab-button:hover {
             background-color: #d1d5db;
             transform: translateY(-1px);
        }
        .scanner-tab-button.active {
             background-color: #3b82f6;
             color: white;
             font-weight: 600;
             box-shadow: 0 2px 4px rgba(59, 130, 246, 0.3);
        }
        .table-container { 
            max-height: 60vh; 
            overflow-y: auto; 
            scrollbar-width: thin; 
            scrollbar-color: #a0aec0 #e2e8f0; 
        }
        .table-container::-webkit-scrollbar { 
            width: 6px; 
        }
        .table-container::-webkit-scrollbar-track { 
            background: #e2e8f0; 
        }
        .table-container::-webkit-scrollbar-thumb {
            background-color: #a0aec0; 
            border-radius: 6px; 
            border: 3px solid #e2e8f0; 
        }
        th { 
            position: sticky; 
            top: 0; 
            background-color: #f1f5f9; 
            z-index: 10; 
            cursor: pointer; 
            user-select: none; 
        }
        th .sort-indicator { 
            display: inline-block; 
            margin-left: 5px; 
            opacity: 0.5; 
            font-size: 0.9em; 
        }
        .loader { 
            border: 4px solid #f3f3f3; 
            border-top: 4px solid #3b82f6; 
            border-radius: 50%; 
            width: 40px; 
            height: 40px; 
            animation: spin 1s linear infinite; 
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }        
        .overlay { 
            position: fixed; 
            top: 0; left: 0; 
            width: 100%; 
            height: 100%; 
            background: rgba(255,255,255,0.8); 
            backdrop-filter: blur(4px); 
            z-index: 999; display: flex; 
            justify-content: center; 
            align-items: center; 
        }
        #save-status { transition: opacity 0.5s ease-in-out; }
        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 8px;
        }          
        /* Floating Scanner Styles - Optimized for Compact View */        
        .floating-scanner {
            position: fixed;
            top: 20px;
            right: 20px;
            width: 350px;
            max-width: 90vw;
            max-height: 80vh;
            z-index: 1000;
            background: white;
            border-radius: 10px;
            box-shadow: 0 8px 25px rgba(0,0,0,0.2);
            border: 2px solid #3b82f6;
            transform: translateY(-100vh);
            transition: transform 0.3s ease-in-out, visibility 0.3s ease-in-out, opacity 0.3s ease-in-out;
            visibility: hidden;
            opacity: 0;
            display: none;
        }        
        .floating-scanner.active {
            transform: translateY(0);
            visibility: visible;
            opacity: 1;
            display: block;
        }
        .floating-scanner-header {
            background: linear-gradient(135deg, #3b82f6, #1d4ed8);
            color: white;
            padding: 10px 14px;
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: move;
        }
        .floating-scanner-content {
            padding: 12px;
            max-height: calc(80vh - 60px);
            overflow-y: auto;
        }        
        .scanner-viewport {
            position: relative;
            width: 100%; 
            max-width: 320px; 
            aspect-ratio: 16/9; 
            background-color: #000;
            overflow: hidden;
            margin: 0 auto;
        }
        .scanner-viewport video, .scanner-viewport canvas {
            width: 100%;
            height: 100%;
        }
        .scan-box {
            position: absolute;
            top: 55%;
            left: 0;
            width: 100%;
            height: 12%;
            border: 2.5px dashed #148a02; /* green */
            box-shadow: 0 0 0 2px rgba(37,99,235,0.15);
            pointer-events: none;
            z-index: 20;
            background: rgba(37,99,235,0.05);
        }
        .barcode-line {
            position: absolute;
            top: 61%;
            left: 0;
            width: 100%;
            height: 2px;
            background: rgba(239, 68, 68, 0.7); /* red-500 */
            z-index: 21;
            pointer-events: none;
        }        
        /* Print Styles */
        @media print {
            /* Fix top spacing issue - remove body padding and container margins */
            body {
                font-size: 10pt;
                background: #fff !important;
                color: #000 !important;
                padding-top: 0 !important; /* Remove logged-in class padding */
                margin: 0 !important;
            }
            /* Remove top spacing from main containers */
            .w-full, .container, .max-w-4xl, .mx-auto, .p-4, .md\:p-8 {
                max-width: 100% !important;
                width: 100% !important;
                padding: 5px !important; /* Further reduced padding */
                border: none !important;
                box-shadow: none !important;
                margin: 0 !important;
            }
            .table-container {
                max-height: none !important;
                height: auto !important; /* Override any fixed height */
                overflow: visible !important; /* Critical: no scrolling in print */
                overflow-y: visible !important; /* Critical: no scrolling in print */
                page-break-inside: auto !important;
                margin: 0 !important; /* Remove all margins */
                padding: 0 !important; /* Remove all padding */
                border: none !important; /* Remove container border */
                background: transparent !important;
                break-inside: auto !important;
            }
            /* Add proper top margin to table for header clearance */
            .table-container table {
                margin-top: 80px !important; /* Space for fixed header */
            }            
            /* Enhanced table styling with consistent borders and reliable page breaks */
            table {
                width: 100% !important;
                border-collapse: collapse !important;
                border-spacing: 0 !important;
                page-break-inside: auto !important; /* Allow table to break across pages */
                border: 1px solid #000 !important;
                margin-bottom: 10pt !important;
                /* Remove any constraints that prevent page breaking */
                max-height: none !important;
                height: auto !important;
            }            
            /* Ensure table headers repeat on every page - Enhanced approach */
            thead {
                display: table-header-group !important;
                break-inside: avoid !important;
                page-break-inside: avoid !important;
                /* Legacy browser support */
                -webkit-region-break-inside: avoid !important;
                -webkit-column-break-inside: avoid !important;
                -moz-page-break-inside: avoid !important;
                -o-page-break-inside: avoid !important;
                /* Additional properties for better header repetition */
                position: static !important;
                z-index: auto !important;
                /* Force header group behavior */
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
              /* Force header repetition with additional CSS properties */
            thead th {
                /* Override any sticky positioning that might interfere */
                position: static !important;
                top: auto !important;
                z-index: auto !important;
                /* Ensure headers are treated as part of table structure */
                display: table-cell !important;
                vertical-align: middle !important;
            }
            /* Header row integrity */
            thead tr {
                display: table-row !important;
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                -webkit-region-break-inside: avoid !important;
                -webkit-column-break-inside: avoid !important;
            }
            /* Override screen sticky headers in print mode */
            th {
                position: static !important;
                top: auto !important;
                z-index: auto !important;
                background-color: #f1f5f9 !important;
                font-weight: bold !important;
                text-align: center !important;
                border-bottom: 2px solid #000 !important;
                break-after: avoid !important;
                page-break-after: avoid !important;
                cursor: default !important;
            }
            tbody {
                display: table-row-group !important;
                page-break-inside: auto !important; /* Allow tbody to break */
                /* Remove any height constraints */
                max-height: none !important;
                height: auto !important;
            }              
            /* Consistent cell borders and spacing */
            th, td {
                border: 1px solid #000 !important;
                padding: 4px 8px !important;
                background: #fff !important;
                color: #000 !important;
                vertical-align: top !important;
                text-align: left !important;
                /* CRITICAL: Prevent individual cell breaking */
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                -webkit-region-break-inside: avoid !important;
                -webkit-column-break-inside: avoid !important;
            }
            /* Center align specific columns (numbers, counts, etc.) */
            td:nth-child(1), /* NO. */
            td:nth-child(4), /* SRP */
            td:nth-child(5), /* Age */
            td:nth-child(6), /* SOH */
            td:nth-child(7), /* Final Count / Counted */
            td:nth-child(8), /* Final Diff / Diff */
            th:nth-child(1),
            th:nth-child(4),
            th:nth-child(5),
            th:nth-child(6),
            th:nth-child(7),
            th:nth-child(8) {
                text-align: center !important;
            }
            /* STRENGTHENED row break controls - Keep rows together */
            tr {
                page-break-inside: avoid !important; /* Prevent row from splitting */
                break-inside: avoid !important; /* CSS3 equivalent */
                -webkit-region-break-inside: avoid !important; /* Webkit */
                -webkit-column-break-inside: avoid !important; /* Webkit columns */
                /* Remove conflicting constraints */
                height: auto !important;
                max-height: none !important;
                /* Additional constraints to force row integrity */
                display: table-row !important;
                vertical-align: baseline !important;
            }
            /* Specific tbody row controls - FORCE rows to stay together */
            tbody tr {
                /* CRITICAL: Keep entire row together - MAXIMUM STRENGTH */
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                -webkit-region-break-inside: avoid !important;
                -webkit-column-break-inside: avoid !important;
                /* Legacy browser support */
                -moz-page-break-inside: avoid !important;
                -o-page-break-inside: avoid !important;
                /* Allow breaks between rows but NOT inside rows */
                page-break-after: auto !important;
                page-break-before: auto !important;
                break-after: auto !important;
                break-before: auto !important;
                -webkit-region-break-after: auto !important;
                -webkit-column-break-after: auto !important;
                -webkit-region-break-before: auto !important;
                -webkit-column-break-before: auto !important;
                /* Remove orphan/widow constraints that might force breaking */
                orphans: unset !important;
                widows: unset !important;
                /* Force structural integrity */
                display: table-row !important;
                position: relative !important;
                z-index: 1 !important;
            }
            /* Individual cell controls to support row integrity */
            td {
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                -webkit-region-break-inside: avoid !important;
                -webkit-column-break-inside: avoid !important;
                /* Legacy browser support */
                -moz-page-break-inside: avoid !important;
                -o-page-break-inside: avoid !important;
                /* Structural integrity */
                display: table-cell !important;
                vertical-align: top !important;
                position: relative !important;
            }
            /* Header cells - ensure they stick with their table structure */
            th {
                page-break-inside: avoid !important;
                break-inside: avoid !important;
                -webkit-region-break-inside: avoid !important;
                -webkit-column-break-inside: avoid !important;
                /* Legacy browser support */
                -moz-page-break-inside: avoid !important;
                -o-page-break-inside: avoid !important;
                /* Structural integrity */
                display: table-cell !important;
                vertical-align: middle !important;
                position: relative !important;
            }
            /* Only keep first row with header to avoid orphaned headers */
            tbody tr:first-child {
                break-before: avoid !important;
                page-break-before: avoid !important;
            }
            /* Ensure consistent table border all around */
            table, table th, table td {
                border-color: #000 !important;
                border-style: solid !important;
            }            
            /* Additional page break optimization for large tables */
            table tbody tr:nth-child(10n) {
                page-break-after: auto !important; /* Encourage breaks every 10 rows */
            }
            /* Simplified cross-browser page break support - Table level only */
            table {
                -webkit-region-break-inside: auto;
                -webkit-column-break-inside: auto;
                break-inside: auto;
                page-break-inside: auto;
            }
            /* Header group support */
            thead {
                -webkit-region-break-inside: avoid;
                -webkit-column-break-inside: avoid;
                break-inside: avoid;
                page-break-inside: avoid;
                display: table-header-group;
            }
            /* Note: tbody tr rules are now handled above in the strengthened section */
                /* Prevent very long tables from being forced to single page */
            .table-container {
                page-break-inside: auto !important;
                break-inside: auto !important;
            }
            /* Force all scrollable containers to flow naturally in print */
            div[style*="overflow"], 
            div[style*="max-height"],
            .overflow-auto,
            .overflow-y-auto,
            .max-h-screen,
            .h-60,
            .h-64,
            .h-72,
            .h-80 {
                max-height: none !important;
                height: auto !important;
                overflow: visible !important;
            }.bg-white, .bg-slate-50, .bg-slate-100, .bg-slate-200, .bg-blue-100, .bg-green-100, .bg-red-100, .bg-amber-50 {
                background: #fff !important;
                border: none !important;
                box-shadow: none !important;
            }
            .rounded-2xl, .rounded-lg, .rounded {
                border-radius: 0 !important;
            }
            .shadow-lg, .shadow-sm, .shadow-xl {
                box-shadow: none !important;
            }
            .border, .border-slate-200, .border-blue-200, .border-amber-200, .border-amber-300 {
                border-color: #000 !important;
                border-width: 1px !important;
            }
            .text-slate-500, .text-slate-600, .text-slate-700, .text-slate-800, .text-slate-900,
            .text-blue-600, .text-green-600, .text-red-600, .text-amber-800 {
                color: #000 !important;
            }
            .font-bold, .font-semibold {
                font-weight: bold !important;
            }
            /* Clean up Dashboard สรุปผลการตรวจสอบ header */
            h3.text-xl {
                font-size: 16pt !important;
                font-weight: bold !important;
                margin-bottom: 10pt !important;
                text-align: center !important;
                border-bottom: 1px solid #000 !important;
                padding-bottom: 5pt !important;
            }              
            /* รายการสรุปผลทั้งหมด header - Only show on first page */
            h3.text-xl.font-semibold.text-slate-800:nth-of-type(2) {
                position: fixed !important;
                top: 55px !important; /* Aligned with reduced header height */
                left: 20px !important;
                right: 20px !important;
                font-size: 14pt !important;
                font-weight: bold !important;
                text-align: center !important;
                background: #fff !important;
                border-bottom: 1px solid #000 !important;
                padding: 4pt 0 !important;
                margin: 0 !important;
                z-index: 999 !important;
                page-break-after: avoid !important;
            }            
            /* Enhanced table page break controls - PRIORITIZE row integrity */
            .table-container table {
                page-break-before: auto !important;
                page-break-after: auto !important;
                page-break-inside: auto !important; /* Allow table to break across pages */
                break-inside: auto !important; /* CSS3 equivalent */
                margin-bottom: 10pt !important;
                /* Force table to use natural document flow */
                position: static !important;
                display: table !important;
                /* Remove all height constraints */
                max-height: none !important;
                height: auto !important;
            }
            /* Simplified tbody controls - SUPPORT row integrity */
            .table-container tbody {
                page-break-inside: auto !important;
                break-inside: auto !important;
                /* Remove height constraints */
                max-height: none !important;
                height: auto !important;
            }
            /* CRITICAL: Table container row controls - FORCE row integrity */
            .table-container tbody tr {
                /* This reinforces the global tbody tr rules above */
                page-break-inside: avoid !important; /* NEVER break inside rows */
                break-inside: avoid !important;
                -webkit-region-break-inside: avoid !important;
                -webkit-column-break-inside: avoid !important;
                /* Allow natural breaks between complete rows */
                page-break-after: auto !important;
                page-break-before: auto !important;
            }
            /* Keep header rows intact */
            .table-container thead,
            .table-container thead tr,
            .table-container thead th {
                page-break-after: avoid !important;
                break-after: avoid !important;
                page-break-inside: avoid !important;
                break-inside: avoid !important;
            }
            /* Ensure section breaks work properly */
            .table-container + .bg-white {
                page-break-before: always !important;
                margin-top: 20pt !important;
            }
            /* Consistent page margins with print-header.css */
            @page {
                margin: 0mm 15mm 18mm 10mm !important;
                size: A4 portrait !important;
            }
            /* Hide elements from print - including charts and buttons */
            .no-print, #loader-overlay, #modal-container, #camera-view-box, #file-ops-container, 
            #upload-container, #workspace-container > nav, #main-tab-demo, #main-tab-workflow, 
            #openScannerBtn, #closeScannerBtn, #barcode-scanner-tab, #text-scanner-tab, 
            #scanner-results, #print-final-report-btn, #exportCsvButton, #exportJsonButton, 
            #refreshChartsButton, #exportDemoCsvButton, #newJobButton, #main-panel-workflow, 
            canvas, button, input, select, textarea {
                display: none !important;
            }              
            /* Fix input values in print - hide inputs and show values with parent cell styling */
            #final-report-table-container input[type="number"],
            #final-report-table-container input[type="text"],
            #demo-count-container input[type="number"],
            #demo-count-container input[type="text"] {
                display: none !important;
            }
            /* Style the parent cells to show the data values */
            #final-report-table-container td[data-print-value]:not([data-print-value=""]),
            #demo-count-container td[data-print-value]:not([data-print-value=""]) {
                position: relative !important;
            }
            #final-report-table-container td[data-print-value]:not([data-print-value=""]):after,
            #demo-count-container td[data-print-value]:not([data-print-value=""]):after {
                content: attr(data-print-value) !important;
                display: block !important;
                color: #000 !important;
                font-family: inherit !important;
                font-size: inherit !important;
                text-align: center !important;
                font-weight: bold !important;
            }
            /* Hide chart containers but keep summary text */
            .bg-slate-50.rounded-lg.border.border-slate-200.flex.flex-col {
                display: none !important;
            }
            /* Show only summary data, hide visual charts */
            #final-summary {
                display: block !important;
                background: #fff !important;
                border: 1px solid #000 !important;
                padding: 10pt !important;
                margin-bottom: 10pt !important;
            }            h1, h2, h3, h4, h5 {
                page-break-after: avoid;
                color: #000 !important;
                font-weight: bold !important;
            }            h1 {
                text-align: center !important;
                margin-bottom: 15pt !important;
                border-bottom: 2px solid #000 !important;
                padding-bottom: 10pt !important;
                font-size: 0 !important; /* Hide original text */
            }
            /* Override the print title */
            h1::before {
                content: "รายงานผลการตรวจนับสต็อกสินค้า (Stock Count Report)" !important;
                font-size: 18pt !important;
                font-weight: bold !important;
                display: block !important;
            }
            .page-break {
                page-break-before: always;
            }
            th {
                position: static !important;
                top: auto !important;
                background-color: #f1f5f9 !important;
                z-index: auto !important;
                box-shadow: none !important;
            }
            .print-legal-section { 
                display: block !important; 
                page-break-before: always; 
            }
            /* Ensure proper page margins - remove duplicate @page rule */
            .space-y-8 > *:not(:first-child), 
            .space-y-4 > *:not(:first-child) {
                margin-top: 10pt !important;
            }}
        @media screen {
            .print-legal-section { display: none !important; }
        }
        /* Enhanced collision fix is now in global print-legal.css */    
    </style>
</head>
<body class="bg-slate-50 text-slate-800 logged-in">
    <!-- Global Print Header Section -->
    <div class="print-header-section"></div>
    
    <div class="w-full">

    <!-- Loading Overlay -->
    <div id="loader-overlay" class="overlay hidden no-print">
        <div class="flex flex-col items-center gap-4">
            <div class="loader"></div>
            <p id="loader-message" class="text-slate-600 font-medium">กำลังประมวลผล...</p>
        </div>
    </div>

    <!-- Custom Modal -->
    <div id="modal-container" class="fixed inset-0 bg-gray-900 bg-opacity-50 flex justify-center items-center z-[1000] hidden no-print">
        <div class="bg-white rounded-lg shadow-xl p-8 w-11/12 md:w-1/2 text-center transform transition-all scale-95 opacity-0" id="modal-box">
            <h3 id="modal-title" class="text-xl font-bold text-slate-800 mb-3">Notice</h3>
            <div id="modal-message" class="text-slate-600 mb-6 text-left"></div>
            <div id="modal-buttons" class="flex justify-center gap-4">
                <button id="modal-cancel-btn" class="bg-gray-300 text-gray-800 font-bold py-2.5 px-8 rounded-lg hover:bg-gray-400 transition-colors shadow-sm hidden">Cancel</button>
                <button id="modal-confirm-btn" class="bg-blue-600 text-white font-bold py-2.5 px-8 rounded-lg hover:bg-blue-700 transition-colors shadow-sm">OK</button>
            </div>
        </div>
    </div>
      <div class="container w-full p-4 md:p-8" style="max-width:100vw;">
        <header class="mb-8 text-center relative no-print mt-4">
            <div class="absolute top-0 left-0">
                 <div id="save-status" class="text-sm text-slate-500 opacity-0 text-left"></div>
            </div>
            <h1 class="text-4xl font-bold text-slate-900 mb-2">ระบบตรวจนับสต็อกสินค้า</h1>
            <div class="flex items-center justify-center mt-2 gap-4">
                <p class="text-slate-500">เครื่องมือช่วยตรวจนับและกระทบยอดสต็อก</p>
                <button id="newJobButton" class="bg-red-500 text-white font-bold py-1 px-3 rounded-lg hover:bg-red-600 transition-colors shadow-sm text-xs">
                    New Job
                </button>
            </div>
        </header>

        <div id="export-soh-excel-bar" class="flex justify-end mb-4 no-print">
            <button id="exportSohExcelBtn" class="bg-teal-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-teal-700 transition-colors shadow-sm text-sm">
                Export SOH Excel (SKU, Description, Age, SRP, SOH, FAMILY)
            </button>
        </div>        <div id="info-box-container" class="hidden bg-sky-100 border border-sky-300 text-sky-800 px-4 py-3 rounded-lg relative mb-8 text-sm" role="alert">
            <div class="flex justify-between items-center flex-col md:flex-row gap-2">
                <div>
                    <strong class="font-bold">Branch:</strong>
                    <span id="info-branch-code" class="ml-2 font-mono"></span>
                    <span class="ml-1">-</span>
                    <span id="info-branch-name" class="ml-1 font-mono"></span>
                </div>
                <div>
                    <strong class="font-bold">Count Date:</strong>
                    <span id="info-count-date" class="ml-2 font-mono"></span>
                </div>
            </div>
        </div>

        <div id="file-ops-container" class="bg-white p-4 rounded-2xl shadow-sm border border-slate-200 mb-8 flex flex-col md:flex-row items-center justify-center gap-4 no-print">
            <label for="load-progress-file" class="flex-1 w-full bg-blue-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-blue-700 transition-colors shadow-sm text-center cursor-pointer">Load Progress from File</label>
            <input type="file" id="load-progress-file" class="hidden" accept=".json">
            <button id="save-progress-button" class="flex-1 w-full bg-green-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-green-700 transition-colors shadow-sm">Save Progress to File</button>
        </div>

        <div id="upload-container" class="bg-white p-6 md:p-8 rounded-2xl shadow-sm border border-slate-200 mb-8 no-print">
             <h2 class="text-2xl font-semibold mb-2 text-slate-800">ขั้นตอนที่ 1: อัพโหลดไฟล์ SOH</h2>
            <p class="mb-6 text-slate-500">อัพโหลดไฟล์ Stock on Hand (.xlsx หรือ .csv).</p>
            <label for="initialSohFile" class="custom-file-input w-full rounded-xl flex flex-col items-center justify-center text-center">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-10 h-10 text-slate-400 mb-2">
                  <path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75V16.5m-13.5-9L12 3m0 0l4.5 4.5M12 3v13.5" />
                </svg>
                <span class="font-medium text-slate-600">คลิกเพื่อเลือกไฟล์ SOH</span>
                <span id="initialSohFileName" class="text-sm text-slate-500 mt-1">(.xlsx, .csv)</span>
            </label>
            <input type="file" id="initialSohFile" class="hidden" accept=".csv, .xlsx, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel" />
        </div>

        <div id="workspace-container" class="hidden no-print">
            <div class="mb-6 border-b border-slate-200">
                <nav class="-mb-px flex space-x-6">
                    <button id="main-tab-demo" class="tab-button text-lg font-semibold py-4 px-1 active">ตรวจนับสินค้า DEMO</button>
                    <button id="main-tab-workflow" class="tab-button text-lg font-semibold py-4 px-1 text-slate-500 hover:text-slate-700">ตรวจนับสินค้าขาย</button>
                </nav>
            </div>
            <div>
                <div id="main-panel-demo">
                     <div class="bg-white p-6 md:p-8 rounded-2xl shadow-sm border border-slate-200">
                         <div class="flex flex-col md:flex-row justify-between items-start mb-4 gap-4">
                             <h3 class="text-xl font-semibold text-slate-800">รายการตรวจนับสินค้า DEMO</h3>
                             <div id="demo-summary" class="flex flex-col gap-2 p-2 bg-slate-50 rounded-lg border border-slate-200 text-xs"></div>
                         </div>
                         <div class="flex flex-col md:flex-row gap-4 my-4">
                             <div class="relative flex-grow">
                                 <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 absolute left-3 top-1/2 -translate-y-1/2 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                     <path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" />
                                 </svg>
                                 <input type="text" id="demoSearchInput" placeholder="ค้นหาด้วย SKU หรือ Description..." class="w-full pl-10 pr-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                             </div>
                             <select id="demoFilterSelect" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                 <option value="all">แสดงทั้งหมด</option>
                                 <option value="uncounted">แสดงรายการที่ยังไม่ได้นับ</option>
                                 <option value="discrepancy">แสดงรายการที่ผลต่างไม่เท่ากับ 0</option>
                                 <option value="matched">แสดงรายการที่นับตรง</option>
                             </select>
                         </div>
                         <div id="demo-count-container" class="table-container border rounded-lg"></div>
                         <button id="exportDemoCsvButton" class="bg-emerald-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-emerald-600 transition-colors shadow-sm text-sm mt-2">
                             Export DEMO Table as CSV
                         </button>                         
                         <button id="openScannerBtn" class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors shadow-sm text-sm mt-2">
                             Scan
                         </button>
                     </div>
                </div>
                
                <!-- Floating Scanner Component -->
                <div id="floating-scanner" class="floating-scanner">                    
                    <div class="floating-scanner-header" id="scanner-header">
                        <h3 class="font-semibold">🔍 Serial/SKU Scanner</h3>                        
                        <div class="flex items-center gap-2">
                            <button id="close-floating-scanner" class="bg-white/20 hover:bg-white/30 px-2 py-1 rounded">✕</button>
                        </div>
                    </div><div class="floating-scanner-content">                        
                        <div class="flex gap-1 mb-3">
                            <button id="floating-barcode-tab" class="scanner-tab-button active flex-1 text-sm">📱 Barcode</button>
                            <button id="floating-text-tab" class="scanner-tab-button flex-1 text-sm">🔍 Serial/SKU OCR</button>
                        </div>
                        
                        <!-- Barcode Scanner View -->
                        <div id="floating-barcode-view" class="scanner-viewport">
                            <div id="floating-qr-reader"></div>
                            <div class="barcode-line"></div>
                        </div>
                          <!-- Text Scanner View -->
                        <div id="floating-text-view" class="hidden scanner-viewport">
                            <video id="floating-text-video" playsinline></video>
                            <div class="scan-box"></div>
                        </div>
                        <!-- Scanner Results -->
                        <div id="floating-scanner-results" class="mt-3 p-2 bg-slate-50 border border-slate-200 rounded text-center min-h-[50px] text-sm"></div>
                        <!-- OCR Preview Canvas -->
                        <canvas id="floating-ocr-preview" class="mt-2 border border-blue-300 rounded w-full max-w-xs mx-auto hidden" style="background:#fff;"></canvas>                        
                        <!-- OCR Controls - Enhanced Serial/SKU Optimized (Only visible in Text/OCR mode) -->
                        <div id="floating-ocr-controls" class="mt-3 p-2 bg-gray-50 border border-gray-200 rounded hidden">
                            <h4 class="text-xs font-semibold mb-2 text-gray-700">🔍 Serial/SKU OCR Settings</h4>
                            <div class="space-y-1">
                                <div class="flex items-center justify-between">
                                    <label class="text-xs text-gray-600">Confidence:</label>
                                    <div class="flex items-center gap-1">
                                        <input type="range" id="floating-confidence-slider" min="30" max="90" value="60" class="w-14">
                                        <span id="floating-confidence-value" class="text-xs text-gray-600 w-8">60%</span>
                                    </div>
                                </div>
                                <div class="flex items-center justify-between">
                                    <label class="text-xs text-gray-600">Serial/SKU Mode:</label>
                                    <select id="floating-preprocessing-select" class="text-xs p-1 border border-gray-300 rounded">
                                        <option value="basic">Basic Processing</option>
                                        <option value="enhanced" selected>Enhanced Serial/SKU</option>
                                        <option value="aggressive">Aggressive OCR</option>
                                    </select>
                                </div>
                                <div class="text-xs text-blue-600 mt-1 px-1">
                                    <span class="inline-flex items-center gap-1">
                                        ⚡ Pyodide Enhanced: Pattern Recognition & Quality Analysis
                                    </span>
                                </div>
                            </div>                        
                        </div>
                    </div>                
                </div>
            </div>
        </div>
      </div>
                <div id="main-panel-workflow" class="hidden">
                     <div class="bg-white p-6 md:p-8 rounded-2xl shadow-sm border border-slate-200">
                         <h2 class="text-2xl font-semibold mb-2 text-slate-800">ตรวจนับสินค้าขาย</h2>
                         <div id="wf-step-tabs" class="mb-4 border-b border-slate-200">
                             <nav class="flex -mb-px space-x-6">
                                 <button id="wf-tab-btn-1" class="tab-button active text-base font-semibold px-1 py-4">ขั้นตอนที่ 1: สร้างไฟล์</button>
                                 <button id="wf-tab-btn-2" class="tab-button text-base font-semibold px-1 py-4 text-slate-500 hover:text-slate-700">ขั้นตอนที่ 2: กระทบยอด</button>
                                 <button id="wf-tab-btn-3" class="tab-button text-base font-semibold px-1 py-4 text-slate-500 hover:text-slate-700">ขั้นตอนที่ 3: สรุปผล</button>
                             </nav>
                         </div>
                         <div id="wf-step1" class="workflow-step">
                             <h3 class="text-lg font-semibold text-slate-700">สร้าง Master File</h3>
                             <p class="text-slate-500 mb-4">ดาวน์โหลดไฟล์สำหรับสแกน (เฉพาะสินค้าขาย)</p>
                             <button id="downloadMasterForScan" class="inline-flex items-center gap-2 bg-blue-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-blue-700 transition-colors shadow-sm disabled:bg-slate-400 disabled:cursor-not-allowed" disabled>
                                 <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                     <path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" />
                                 </svg>
                                 ดาวน์โหลด Master.csv
                             </button>
                         </div>                         
                         <div id="wf-step2" class="workflow-step hidden">
                             <h3 class="text-lg font-semibold text-slate-700">กระทบยอดรอบที่ 1</h3>                             
                             <p class="text-slate-500 mb-4">อัพโหลด Logfile จากสแกนเนอร์ และ/หรือ Master.csv (ข้อมูล DEMO จะถูกรวมอัตโนมัติ)</p>
                             <!-- First Count File Uploads (both file types supported) -->
                             <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                                 <!-- Logfile Upload -->
                                 <div>
                                     <label for="firstScanLogfile" class="block mb-2 text-sm font-medium text-slate-700">Logfile (จากสแกนเนอร์)</label>
                                     <input type="file" id="firstScanLogfile" accept=".csv" multiple class="block w-full text-sm text-slate-500 file:mr-4 file:py-2.5 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-slate-50 file:text-slate-700 hover:file:bg-slate-100 border border-slate-300 rounded-lg" />
                                     <p class="text-xs text-slate-500 mt-1">รูปแบบ: คอลัมน์ 3=Part No., คอลัมน์ 5=จำนวน</p>
                                 </div>
                                 <!-- Master.csv Upload -->
                                 <div>
                                     <label for="firstMasterFile" class="block mb-2 text-sm font-medium text-slate-700">Master.csv</label>
                                     <input type="file" id="firstMasterFile" accept=".csv" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2.5 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 border border-blue-300 rounded-lg" />
                                     <p class="text-xs text-slate-500 mt-1">รูปแบบ: คอลัมน์ 1=Part No., คอลัมน์ 6=Actual Qty (เฉพาะรายการที่ qty > 0 เท่านั้น)</p>
                                 </div>
                             </div>
                             <p class="text-xs text-slate-500 mb-3">หมายเหตุ: สามารถอัพโหลดทั้ง Logfile และ Master.csv พร้อมกันได้ ระบบจะรวมข้อมูลจากทั้งสองไฟล์</p>
                             <button id="processFirstCount" class="inline-flex items-center gap-2 mt-4 bg-violet-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-violet-700 transition-colors shadow-sm disabled:bg-slate-400 disabled:cursor-not-allowed" disabled>
                                 ประมวลผลต่าง
                             </button>
                             <div id="step2-results" class="hidden mt-6">
                                 <h4 class="font-semibold text-slate-700 mb-4">สรุปผลการนับรอบที่ 1:</h4>
                                 <div id="netdiff-summary-container"></div>
                             </div>
                         </div>                         <div id="wf-step3" class="workflow-step hidden">
                             <h3 class="text-lg font-semibold text-slate-700">สรุปผลและดำเนินการต่อ</h3>
                             <p class="text-slate-500 mb-4">สรุปผลทันที หรือนับซ้ำรายการที่ไม่ได้ตรวจนับ</p>
                             
                             <!-- Sales Data Upload Section -->
                             <div class="mb-6 p-4 bg-orange-50 border border-orange-200 rounded-lg">
                                 <h4 class="text-md font-semibold text-orange-800 mb-2">🔄 อัพโหลดข้อมูลยอดขายระหว่างการนับ (Optional)</h4>                                 
                                 <p class="text-sm text-orange-700 mb-3">
                                     อัพโหลดไฟล์ยอดขายที่เกิดขึ้นระหว่างการนับสต็อกเพื่อติดตามและบันทึกการขายในช่วงนั้น
                                 </p>
                                 <div class="space-y-3">
                                     <div>
                                         <label for="salesDataFile" class="block mb-2 text-sm font-medium text-orange-800">Sales Data (.xlsx)</label>
                                         <input type="file" id="salesDataFile" accept=".xlsx,.xls" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2.5 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-orange-100 file:text-orange-800 hover:file:bg-orange-200 border border-orange-300 rounded-lg" />
                                         <p class="text-xs text-orange-600 mt-1">รูปแบบ: นำเข้าไฟล์ RD020.. เพื่ออัพเดทยอดขาย</p>
                                     </div>
                                     <button id="processSalesData" class="bg-orange-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-orange-700 transition-colors shadow-sm text-sm disabled:bg-slate-400 disabled:cursor-not-allowed" disabled>
                                         ประมวลผลข้อมูลยอดขาย
                                     </button>
                                     <div id="sales-processing-results" class="hidden mt-4 p-3 bg-white border border-orange-200 rounded text-sm"></div>
                                 </div>
                             </div>

                             <button id="finalizeFromFirstCount" class="w-full inline-flex items-center justify-center gap-2 bg-teal-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-teal-700 transition-colors shadow-sm disabled:bg-slate-400 disabled:cursor-not-allowed">
                                 <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                                    <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z" clip-rule="evenodd" />
                                 </svg>
                                 แสดงรายงานสรุป (ตรวจนับรอบที่ 1)
                             </button>
                             <div class="mt-6 pt-6 border-t border-slate-200">
                                 <h4 class="text-md font-semibold text-slate-600">หรือ (Optional) ทำการนับซ้ำ</h4>
                                 <p class="text-slate-500 mb-4 text-sm">
                                     หากมีการขายสินค้าระหว่างการนับ ให้อัพเดต SOH ล่าสุดก่อนสร้างไฟล์นับซ้ำ
                                 </p>

                                 <div class="bg-amber-50 border border-amber-200 p-4 rounded-lg mb-4">
                                     <label for="latestSohFile" class="block mb-2 text-sm font-medium text-amber-800">1. อัพเดต SOH ล่าสุด (ถ้ามี)</label>
                                     <input type="file" id="latestSohFile" accept=".csv, .xlsx, application/vnd.openxmlformats-officedocument.spreadsheetml.sheet, application/vnd.ms-excel" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2.5 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-amber-100 file:text-amber-800 hover:file:bg-amber-200 border border-amber-300 rounded-lg disabled:opacity-50 disabled:cursor-not-allowed" disabled />
                                     <span id="latestSohFileName" class="text-xs text-slate-500 mt-1"></span>
                                 </div>
                                 
                                 <h5 class="text-sm font-medium text-slate-700 mt-4 mb-2">2. สร้างไฟล์และดำเนินการนับซ้ำ</h5>
                                 <button id="generateRecountMasterFile" class="inline-flex items-center gap-2 mb-4 bg-green-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-green-700 transition-colors shadow-sm text-sm disabled:bg-slate-400 disabled:cursor-not-allowed">
                                     สร้าง Master File สำหรับนับซ้ำ
                                 </button>
                                 
                                 <!-- Recount File Uploads (both file types supported) -->
                                 <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                                     <!-- Logfile Upload -->
                                     <div>
                                         <label for="secondScanLogfile" class="block mb-2 text-sm font-medium text-slate-700">Logfile (จากสแกนเนอร์)</label>
                                         <input type="file" id="secondScanLogfile" accept=".csv" multiple class="block w-full text-sm text-slate-500 file:mr-4 file:py-2.5 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-slate-50 file:text-slate-700 hover:file:bg-slate-100 border border-slate-300 rounded-lg" />
                                         <p class="text-xs text-slate-500 mt-1">รูปแบบ: คอลัมน์ 3=Part No., คอลัมน์ 5=จำนวน</p>
                                     </div>

                                     <!-- Master.csv Upload -->
                                     <div>
                                         <label for="secondMasterFile" class="block mb-2 text-sm font-medium text-slate-700">Master.csv</label>
                                         <input type="file" id="secondMasterFile" accept=".csv" class="block w-full text-sm text-slate-500 file:mr-4 file:py-2.5 file:px-4 file:rounded-lg file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100 border border-blue-300 rounded-lg" />
                                         <p class="text-xs text-slate-500 mt-1">รูปแบบ: คอลัมน์ 1=Part No., คอลัมน์ 6=Actual Qty (เฉพาะรายการที่ qty > 0 เท่านั้น)</p>
                                     </div>
                                 </div>
                                 
                                 <p class="text-xs text-slate-500 mb-3">หมายเหตุ: สามารถอัพโหลดทั้ง Logfile และ Master.csv พร้อมกันได้ ระบบจะรวมข้อมูลจากทั้งสองไฟล์</p>
                                 
                                 <button id="processSecondCount" class="inline-flex items-center gap-2 bg-sky-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-sky-700 transition-colors shadow-sm disabled:bg-slate-400 disabled:cursor-not-allowed">
                                     ประมวลผลยอดนับซ้ำ
                                 </button>
                             </div>
                         </div>
                     </div>
                </div>
            </div>
        </div>

        <!-- Final Report Container (at root level, hidden initially) -->
        <div id="final-report-container" class="mt-8 hidden">
            <div class="bg-white p-6 md:p-8 rounded-2xl shadow-sm border border-slate-200">
                <div class="space-y-8">
                    <div class="space-y-4">
                        <div class="flex justify-between items-center">
                            <h3 class="text-xl font-semibold text-slate-800">Dashboard สรุปผลการตรวจสอบ</h3>
                            <div class="flex items-center gap-2 no-print">
                                <button id="refreshChartsButton" class="bg-indigo-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-600 transition-colors shadow-sm text-sm flex items-center gap-2">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                        <path stroke-linecap="round" stroke-linejoin="round" d="M21 12a9 9 0 1 1-9-9c2.52 0 4.93 1 6.74 2.74L21 8m0 0V3m0 5h-5" />
                                    </svg>
                                    Refresh Chart
                                </button>
                            </div>
                        </div>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div class="p-4 bg-slate-50 rounded-lg border border-slate-200 flex flex-col">
                                <h4 class="text-sm font-semibold text-center mb-2 text-slate-600 flex-shrink-0">ผลต่าง (มูลค่า)</h4>
                                <div class="relative h-64">
                                    <canvas id="costChart"></canvas>
                                </div>
                            </div>
                            <div class="p-4 bg-slate-50 rounded-lg border border-slate-200 flex flex-col">
                                <h4 class="text-sm font-semibold text-center mb-2 text-slate-600 flex-shrink-0">ผลต่าง (จำนวน)</h4>
                                <div class="relative h-64">
                                    <canvas id="qtyChart"></canvas>
                                </div>
                            </div>
                        </div>
                        <div class="p-4 bg-slate-50 rounded-lg border border-slate-200 flex flex-col">
                            <h4 class="text-sm font-semibold text-center mb-2 text-slate-600 flex-shrink-0">ผลต่างแยกตามหมวดหมู่ (จำนวน)</h4>
                            <div class="relative h-80">
                                <canvas id="categoryChart"></canvas>
                            </div>
                        </div>
                        <div id="final-summary" class="flex flex-col gap-2 p-4 bg-slate-100 rounded-lg border border-slate-200 text-sm"></div>
                    </div>
                    <div class="space-y-4">
                        <h3 class="text-xl font-semibold text-slate-800">รายการสรุปผลทั้งหมด</h3>
                        <div class="flex flex-col md:flex-row gap-4 no-print">
                            <div class="relative flex-grow">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5 absolute left-3 top-1/2 -translate-y-1/2 text-slate-400" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>
                                <input type="text" id="finalSearchInput" placeholder="ค้นหารายงาน..." class="w-full pl-10 pr-4 py-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                            </div>
                            <select id="finalFilterSelect" class="w-full md:w-auto p-2 border border-slate-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500">
                                <option value="all">แสดงทั้งหมด</option>
                                <option value="discrepancy">เฉพาะรายการที่ผลต่างไม่เท่ากับ 0</option>
                                <option value="demo">เฉพาะสินค้า DEMO</option>
                                <option value="normal">เฉพาะสินค้าปกติ</option>
                            </select>
                        </div>
                        <div class="bg-white p-6 md:p-8 rounded-2xl shadow-sm border border-slate-200 mb-8 no-print">
                            <h3 class="text-xl font-semibold text-slate-800 mb-4">เปิดกล้องเพื่อสแกนสินค้า</h3>
                            <div class="flex flex-col md:flex-row gap-4">
                                <div class="relative flex-1">
                                    <button id="final-openScannerBtn" class="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600 transition-colors shadow-sm text-sm mb-2">
                                        Scan                                    
                                    </button>
                                </div>
                            </div>
                        </div>
                        <div id="final-report-table-container" class="table-container border border-slate-200 rounded-lg"></div>
                        <div class="mt-4 flex flex-col sm:flex-row gap-4 no-print">                            
                            <button id="print-final-report-btn" class="flex-1 inline-flex items-center justify-center gap-2 bg-gray-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-gray-700 transition-colors shadow-sm">
                                <!-- Printer icon (Heroicons) -->
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                                    <path stroke-linecap="round" stroke-linejoin="round" d="M17 17h2a2 2 0 002-2v-4a2 2 0 00-2-2H5a2 2 0 00-2 2v4a2 2 0 002 2h2m2 4h6a2 2 0 002-2v-4a2 2 0 00-2-2H9a2 2 0 00-2 2v4a2 2 0 002 2zm8-12V5a2 2 0 00-2-2H9a2 2 0 00-2 2v4h10z" />
                                </svg>
                                Print Report
                            </button>
                            <button id="exportCsvButton" class="flex-1 inline-flex items-center justify-center gap-2 bg-emerald-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-emerald-700 transition-colors shadow-sm">
                                <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-4l-4 4m0 0l-4-4m4 4V4" /></svg>
                                Export CSV
                            </button>
                            <button id="exportJsonButton" class="flex-1 inline-flex items-center justify-center gap-2 bg-indigo-600 text-white font-bold py-2.5 px-5 rounded-lg hover:bg-indigo-700 transition-colors shadow-sm">
                                <!-- Curly braces icon for JSON -->
                                <span class="text-lg font-bold">{ }</span>
                                Export JSON
                            </button>
                        </div>
                    </div>
                </div>
            </div>        </div>

        <!-- Legal Declaration and Signature Section (print only) -->
        <div class="print-legal-section">
            <div class="legal-certification">
                ข้าพเจ้าขอรับรองว่าข้อมูลในรายงานนี้ถูกต้องตามที่ตรวจสอบและเป็นความจริงทุกประการ
                <div class="english-text">
                    (I hereby certify that the information in this report is accurate and true to the best of my knowledge.)
                </div>
            </div>
            
            <div class="signature-section">
                <div class="signature-container">
                    <div class="signature-box">
                        <div class="signature-line"></div>
                        <div class="signature-name">ลงชื่อ .................................................</div>
                        <div class="signature-title">(ผู้ตรวจสอบ / Auditor)</div>
                        <div class="signature-date">
                            วันที่: <span class="signature-date-line"></span> / <span class="signature-date-line"></span> / <span class="signature-date-line"></span>
                        </div>
                    </div>
                    <div class="signature-box">
                        <div class="signature-line"></div>
                        <div class="signature-name">ลงชื่อ .................................................</div>
                        <div class="signature-title">(ผู้รับการตรวจสอบ / Auditee)</div>
                        <div class="signature-date">
                            วันที่: <span class="signature-date-line"></span> / <span class="signature-date-line"></span> / <span class="signature-date-line"></span>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        let cvReady = false;
        function onOpenCvReady() {
            cvReady = true;
            const textScannerTab = document.getElementById('text-scanner-tab');
            const cameraViewBox = document.getElementById('camera-view-box');
            const textScannerView = document.getElementById('text-scanner-view');
            const textScannerVideo = document.getElementById('text-scanner-video');
            if (
                textScannerTab && textScannerTab.classList.contains('active') &&
                cameraViewBox && !cameraViewBox.classList.contains('hidden')
            ) {
                // If video is not playing, start it
                if (textScannerView && !textScannerView.classList.contains('hidden')) {
                    if (textScannerVideo && textScannerVideo.srcObject == null) {
                        if (typeof startTextScanner === 'function') startTextScanner();
                    }
                }
                if (typeof stopOcrStreaming === 'function') stopOcrStreaming();
                if (typeof startOcrStreaming === 'function') startOcrStreaming();
                const scannerResultsEl = document.getElementById('scanner-results');
                if (scannerResultsEl) {
                    scannerResultsEl.innerHTML = `<p class="text-green-600">OpenCV is ready. Scanner refreshed.</p>`;
                }
            }
        }        
        document.addEventListener('DOMContentLoaded', () => {
            const getEl = (id) => document.getElementById(id);
            let hasUnsavedChanges = false;
            let state = getInitialState();
            let finalSummaryData = {}; // === Floating Scanner Variables ===
            let floatingScanner = null;
            let floatingStream = null;
            let floatingOcrStreaming = false;
            let floatingOcrStreamInterval = null;
            let currentScannerMode = 'barcode';
            let currentScannerContext = 'demo'; // 'demo' or 'final'
            let pyodide = null;
            let pyodideReady = false;
            let lastScannedText = null; // Store latest scanned text
            let scanHistory = []; // Store scan history
            
            // === Pyodide OCR Variables ===
            let pyodideWorker = null;
            let floatingOcrSettings = {
                confidence: 60,
                preprocessing: 'enhanced',
                speed: 800
            };

            // === Initialize Pyodide for Enhanced OCR ===
            async function initializePyodide() {                
                try {
                    if (pyodideReady) return;
                    pyodide = await loadPyodide();
                    // Install required packages
                    await pyodide.loadPackage(['opencv-python', 'numpy', 'pillow']);
                    // Load enhanced OCR processing script with optimized Serial/SKU processing
                    await pyodide.runPython(`
import cv2
import numpy as np
from PIL import Image, ImageEnhance, ImageFilter
import base64
import io
import re

def process_image_enhanced(image_data_base64, preprocessing_mode='enhanced'):
    """
    Enhanced image processing using OpenCV and Python
    Optimized for Apple product serial number and SKU recognition
    with advanced Serial/SKU data processing capabilities
    """
    try:
        # Decode base64 image
        image_data = base64.b64decode(image_data_base64.split(',')[1])
        image = Image.open(io.BytesIO(image_data))
        
        # Convert to OpenCV format
        img_array = np.array(image)
        if len(img_array.shape) == 3:
            img = cv2.cvtColor(img_array, cv2.COLOR_RGB2BGR)
        else:
            img = img_array
            
        # Convert to grayscale
        if len(img.shape) == 3:
            gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        else:
            gray = img

        # === OPTIMIZED SERIAL/SKU PREPROCESSING ===
        # Apply preprocessing based on mode with Serial/SKU optimization
        if preprocessing_mode == 'basic':
            # Basic sharpening optimized for Serial/SKU text
            kernel = np.array([[-1,-1,-1,-1,-1], 
                              [-1,2,2,2,-1], 
                              [-1,2,8,2,-1], 
                              [-1,2,2,2,-1], 
                              [-1,-1,-1,-1,-1]]) / 8
            processed = cv2.filter2D(gray, -1, kernel)
            
            # Enhance contrast for Serial/SKU readability
            processed = cv2.convertScaleAbs(processed, alpha=1.2, beta=10)
            _, processed = cv2.threshold(processed, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
            
        elif preprocessing_mode == 'enhanced':
            # Enhanced Apple Serial/SKU optimized processing
            # Advanced CLAHE specifically tuned for Serial/SKU text
            clahe = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(6,6))
            processed = clahe.apply(gray)
            
            # Serial/SKU specific bilateral filtering
            processed = cv2.bilateralFilter(processed, 11, 80, 80)
            
            # Enhance Serial/SKU text definition
            enhancer = ImageEnhance.Sharpness(Image.fromarray(processed))
            processed = np.array(enhancer.enhance(2.0))
            
            # Unsharp masking optimized for Serial/SKU characters
            blurred = cv2.GaussianBlur(processed, (3, 3), 0)
            processed = cv2.addWeighted(processed, 1.8, blurred, -0.8, 0)
            
            # Serial/SKU adaptive thresholding
            processed = cv2.adaptiveThreshold(processed, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 13, 4)
            
        elif preprocessing_mode == 'aggressive':
            # Aggressive preprocessing for difficult Serial/SKU conditions
            # Advanced CLAHE for challenging lighting
            clahe = cv2.createCLAHE(clipLimit=4.0, tileGridSize=(4,4))
            processed = clahe.apply(gray)
            
            # Multiple denoising passes for Serial/SKU clarity
            processed = cv2.fastNlMeansDenoising(processed, None, 12, 7, 21)
            processed = cv2.bilateralFilter(processed, 13, 90, 90)
            
            # Multi-scale sharpening for Serial/SKU text
            sharp1 = cv2.GaussianBlur(processed, (2, 2), 0)
            sharp2 = cv2.GaussianBlur(processed, (4, 4), 0)
            processed = cv2.addWeighted(processed, 2.2, sharp1, -0.6, 0)
            processed = cv2.addWeighted(processed, 1.2, sharp2, -0.2, 0)
            
            # Serial/SKU specific morphological operations
            kernel1 = cv2.getStructuringElement(cv2.MORPH_RECT, (2, 1))
            kernel2 = cv2.getStructuringElement(cv2.MORPH_RECT, (1, 2))
            processed = cv2.morphologyEx(processed, cv2.MORPH_CLOSE, kernel1)
            processed = cv2.morphologyEx(processed, cv2.MORPH_OPEN, kernel2)
            
            # Final Serial/SKU optimized thresholding
            processed = cv2.adaptiveThreshold(processed, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 15, 2)
        
        # Convert back to PIL Image
        processed_image = Image.fromarray(processed)
        
        # === SERIAL/SKU SPECIFIC ENHANCEMENTS ===
        # Apply Serial/SKU text enhancement filters
        processed_image = processed_image.filter(ImageFilter.UnsharpMask(radius=1, percent=200, threshold=0))
        
        # Convert to base64 for return
        buffer = io.BytesIO()
        processed_image.save(buffer, format='PNG')
        processed_base64 = base64.b64encode(buffer.getvalue()).decode()
        
        return f"data:image/png;base64,{processed_base64}"
        
    except Exception as e:
        return f"Error: {str(e)}"

def analyze_image_quality(image_data_base64):
    """
    Analyze image quality for better Serial/SKU OCR feedback
    Enhanced with Serial/SKU specific quality metrics
    """
    try:
        # Decode base64 image
        image_data = base64.b64decode(image_data_base64.split(',')[1])
        image = Image.open(io.BytesIO(image_data))
        img_array = np.array(image)
        
        if len(img_array.shape) == 3:
            gray = cv2.cvtColor(img_array, cv2.COLOR_RGB2GRAY)
        else:
            gray = img_array
            
        # Calculate enhanced metrics for Serial/SKU processing
        brightness = np.mean(gray)
        contrast = np.std(gray)
        sharpness = cv2.Laplacian(gray, cv2.CV_64F).var()
        
        # Serial/SKU specific quality metrics
        edges = cv2.Canny(gray, 50, 150)
        edge_density = np.sum(edges > 0) / edges.size
        
        # Text region analysis for Serial/SKU
        text_regions = cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2)
        text_density = np.sum(text_regions == 0) / text_regions.size
        
        # Quality assessment optimized for Serial/SKU
        quality = {
            'brightness': float(brightness),
            'contrast': float(contrast),
            'sharpness': float(sharpness),
            'edge_density': float(edge_density),
            'text_density': float(text_density),
            'overall': 'good'
        }
        
        # Enhanced quality thresholds for Serial/SKU processing
        if brightness < 45:
            quality['overall'] = 'too_dark'
        elif brightness > 210:
            quality['overall'] = 'too_bright'
        elif contrast < 25:
            quality['overall'] = 'low_contrast'
        elif sharpness < 80:
            quality['overall'] = 'blurry'
        elif edge_density < 0.02:
            quality['overall'] = 'insufficient_detail'
        elif text_density < 0.05:
            quality['overall'] = 'no_text_detected'
            
        return quality
        
    except Exception as e:
        return {'error': str(e)}

def extract_serial_sku_patterns(text):
    """
    Advanced Serial/SKU pattern extraction and validation
    Optimized for Apple products and various SKU formats
    """
    try:
        # Clean the input text
        cleaned_text = re.sub(r'[^A-Z0-9\-_]', '', text.upper())
        
        # Enhanced Serial/SKU patterns
        patterns = {
            'apple_serial': r'[A-Z0-9]{10,12}',  # Apple serial format
            'sku_standard': r'S[A-Z0-9]{8,12}',  # Standard SKU with S prefix
            'sku_numeric': r'\d{8,12}',          # Numeric SKU
            'mixed_pattern': r'[A-Z]{2,4}\d{6,10}',  # Mixed letter-number
            'barcode_pattern': r'\d{12,14}',     # Barcode patterns
        }
        
        extracted = {}
        for pattern_name, pattern in patterns.items():
            matches = re.findall(pattern, cleaned_text)
            if matches:
                extracted[pattern_name] = matches
        
        # Score patterns based on likelihood for Serial/SKU
        scored_results = []
        for pattern_name, matches in extracted.items():
            for match in matches:
                score = calculate_serial_sku_score(match, pattern_name)
                scored_results.append({
                    'text': match,
                    'pattern': pattern_name,
                    'score': score,
                    'length': len(match)
                })
        
        # Sort by score descending
        scored_results.sort(key=lambda x: x['score'], reverse=True)
        
        return {
            'best_matches': scored_results[:3],  # Top 3 matches
            'all_patterns': extracted,
            'original_text': text,
            'cleaned_text': cleaned_text
        }
        
    except Exception as e:
        return {'error': str(e)}

def calculate_serial_sku_score(text, pattern_type):
    """
    Calculate confidence score for Serial/SKU matches
    """
    score = 0
    
    # Base score by pattern type
    pattern_scores = {
        'apple_serial': 90,
        'sku_standard': 85,
        'mixed_pattern': 70,
        'sku_numeric': 60,
        'barcode_pattern': 50
    }
    score += pattern_scores.get(pattern_type, 30)
    
    # Length scoring (optimal lengths for Serial/SKU)
    length = len(text)
    if 8 <= length <= 12:
        score += 20
    elif 6 <= length <= 14:
        score += 10
    else:
        score -= 10
    
    # Character composition scoring
    letters = sum(1 for c in text if c.isalpha())
    digits = sum(1 for c in text if c.isdigit())
    
    # Prefer mixed alphanumeric for serials
    if letters > 0 and digits > 0:
        score += 15
    
    # Apple serial specific patterns
    if pattern_type == 'apple_serial':
        if letters >= 3 and digits >= 6:
            score += 25
        if not any(char in text for char in ['O', 'I']):  # Apple avoids O, I
            score += 10
    
    # SKU specific patterns
    if 'sku' in pattern_type:
        if text.startswith('S') and len(text) >= 9:
            score += 20
        if digits >= length * 0.6:  # SKUs often numeric-heavy
            score += 10
    
    return min(score, 100)  # Cap at 100
                    `);
                      pyodideReady = true;
                      } catch (error) {
                    // Silent error handling for production
                }
            }            
            // === Floating Scanner Functions ===
            function initializeFloatingScanner() {
                floatingScanner = document.getElementById('floating-scanner');
                
                // Make header draggable with enhanced responsiveness
                const header = document.getElementById('scanner-header');
                let isDragging = false;
                let currentX = 0;
                let currentY = 0;
                let initialX = 0;
                let initialY = 0;
                let xOffset = 0;
                let yOffset = 0;
                
                function dragStart(e) {
                    // Only drag if clicking on the header itself, not buttons
                    if (e.target.tagName === 'BUTTON' || e.target.closest('button')) {
                        return;
                    }
                    
                    const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                    const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                    
                    initialX = clientX - xOffset;
                    initialY = clientY - yOffset;
                    isDragging = true;
                    
                    // Enhanced visual feedback
                    floatingScanner.style.cursor = 'grabbing';
                    floatingScanner.style.userSelect = 'none';
                    floatingScanner.style.transition = 'none'; // Disable transition during drag
                    header.style.transform = 'scale(0.98)'; // Subtle scale effect
                }
                  function drag(e) {
                    if (isDragging) {
                        e.preventDefault();
                        
                        const clientX = e.clientX || (e.touches && e.touches[0].clientX);
                        const clientY = e.clientY || (e.touches && e.touches[0].clientY);
                        
                        const newX = clientX - initialX;
                        const newY = clientY - initialY;
                        
                        // Only update if position actually changed (performance optimization)
                        if (Math.abs(newX - currentX) > 1 || Math.abs(newY - currentY) > 1) {
                            currentX = newX;
                            currentY = newY;
                            
                            xOffset = currentX;
                            yOffset = currentY;
                            
                            // Constrain to viewport bounds
                            const rect = floatingScanner.getBoundingClientRect();
                            const maxX = window.innerWidth - rect.width;
                            const maxY = window.innerHeight - rect.height;
                            
                            currentX = Math.max(0, Math.min(currentX, maxX));
                            currentY = Math.max(0, Math.min(currentY, maxY));
                            
                            // Smooth transform with GPU acceleration
                            requestAnimationFrame(() => {
                                floatingScanner.style.transform = `translate3d(${currentX}px, ${currentY}px, 0)`;
                            });
                        }
                    }
                }
                
                function dragEnd() {
                    if (isDragging) {
                        initialX = currentX;
                        initialY = currentY;
                        isDragging = false;
                        
                        // Restore visual feedback
                        floatingScanner.style.cursor = '';
                        floatingScanner.style.userSelect = '';
                        floatingScanner.style.transition = 'transform 0.3s ease-in-out, visibility 0.3s ease-in-out, opacity 0.3s ease-in-out';
                        header.style.transform = 'scale(1)';
                    }
                }
                
                // Enhanced event listeners for both mouse and touch
                header.addEventListener('mousedown', dragStart);
                header.addEventListener('touchstart', dragStart, { passive: false });
                
                document.addEventListener('mousemove', drag);
                document.addEventListener('touchmove', drag, { passive: false });
                
                document.addEventListener('mouseup', dragEnd);
                document.addEventListener('touchend', dragEnd);
                  // Initialize event listeners
                setupFloatingTabSwitching();
                setupFloatingControls();
            }

            function setupFloatingTabSwitching() {
                const barcodeTab = document.getElementById('floating-barcode-tab');
                const textTab = document.getElementById('floating-text-tab');
                const barcodeView = document.getElementById('floating-barcode-view');
                const textView = document.getElementById('floating-text-view');
                
                barcodeTab.addEventListener('click', () => switchFloatingTab('barcode'));
                textTab.addEventListener('click', () => switchFloatingTab('text'));
                  function switchFloatingTab(mode) {
                    currentScannerMode = mode;
                    const ocrControls = document.getElementById('floating-ocr-controls');
                    const ocrPreview = document.getElementById('floating-ocr-preview');
                    
                    if (mode === 'barcode') {
                        barcodeTab.classList.add('active');
                        textTab.classList.remove('active');
                        barcodeView.classList.remove('hidden');
                        textView.classList.add('hidden');
                        ocrControls.classList.add('hidden');
                        ocrPreview.classList.add('hidden');
                        
                        stopFloatingTextScanner();
                        stopFloatingOcrStreaming();
                        startFloatingBarcodeScanner();
                    } else {
                        textTab.classList.add('active');
                        barcodeTab.classList.remove('active');
                        textView.classList.remove('hidden');
                        barcodeView.classList.add('hidden');
                        ocrControls.classList.remove('hidden');
                        
                        stopFloatingBarcodeScanner();
                        startFloatingTextScanner();
                        setTimeout(startFloatingOcrStreaming, 800);
                    }
                }
            }

            function setupFloatingControls() {
                // Confidence slider
                const confidenceSlider = document.getElementById('floating-confidence-slider');
                const confidenceValue = document.getElementById('floating-confidence-value');
                
                confidenceSlider.addEventListener('input', (e) => {
                    floatingOcrSettings.confidence = parseInt(e.target.value);
                    confidenceValue.textContent = e.target.value + '%';
                });
                  // Preprocessing select
                const preprocessingSelect = document.getElementById('floating-preprocessing-select');
                preprocessingSelect.addEventListener('change', (e) => {
                    floatingOcrSettings.preprocessing = e.target.value;
                });
                  // Close button
                const closeBtn = document.getElementById('close-floating-scanner');
                closeBtn.addEventListener('click', closeFloatingScanner);
            }            async function startFloatingTextScanner() {
                try {
                    if (floatingStream) {
                        floatingStream.getTracks().forEach(track => track.stop());
                    }
                    
                    const constraints = {
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 1920, max: 1920 },
                            height: { ideal: 1080, max: 1080 },
                            frameRate: { ideal: 30, max: 30 }
                        }
                    };
                    
                    floatingStream = await navigator.mediaDevices.getUserMedia(constraints);
                    const video = document.getElementById('floating-text-video');                    
                    video.srcObject = floatingStream;
                    video.play();
                } catch (err) {
                    updateFloatingResults(`<p class="text-red-500">Camera error: ${err.message}</p>`);
                }
            }

            function stopFloatingTextScanner() {
                const video = document.getElementById('floating-text-video');
                if (video && video.srcObject) {
                    const tracks = video.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    video.srcObject = null;
                }
                floatingStream = null;
            }

            function startFloatingBarcodeScanner() {
                const barcodeView = document.getElementById('floating-barcode-view');
                
                Quagga.init({
                    inputStream: {
                        name: "Live",
                        type: "LiveStream",
                        target: barcodeView,
                        constraints: { facingMode: "environment" }
                    },
                    decoder: {
                        readers: [
                            "code_128_reader", "ean_reader", "ean_8_reader",
                            "code_39_reader", "upc_reader", "upc_e_reader"
                        ]
                    },
                    locate: true
                }, (err) => {
                    if (err) {
                        updateFloatingResults(`<p class="text-red-500">Barcode scanner error: ${err.message}</p>`);
                        return;
                    }
                    Quagga.start();
                });
                
                Quagga.onDetected(onFloatingBarcodeDetected);
            }

            function stopFloatingBarcodeScanner() {
                if (typeof Quagga !== 'undefined' && Quagga.running) {
                    Quagga.offDetected(onFloatingBarcodeDetected);
                    Quagga.stop();
                }
                
                const quaggaVideo = document.querySelector('#floating-barcode-view video');
                if (quaggaVideo && quaggaVideo.srcObject) {
                    quaggaVideo.srcObject.getTracks().forEach(track => track.stop());
                    quaggaVideo.srcObject = null;
                }
            }

            function startFloatingOcrStreaming() {
                if (floatingOcrStreaming) return;
                floatingOcrStreaming = true;
                updateFloatingResults('<p class="text-blue-500">กำลังสแกนแบบเรียลไทม์...</p>');
                floatingOcrStreamInterval = setInterval(processFloatingOcrFrame, floatingOcrSettings.speed);
            }

            function stopFloatingOcrStreaming() {
                floatingOcrStreaming = false;
                if (floatingOcrStreamInterval) {
                    clearInterval(floatingOcrStreamInterval);
                    floatingOcrStreamInterval = null;
                }
            }

            async function processFloatingOcrFrame() {
                if (!floatingOcrStreaming || !floatingStream || !cvReady) return;
                  const video = document.getElementById('floating-text-video');
                if (video.readyState < 2) return;
                
                const startTime = performance.now();
                
                const canvas = document.createElement('canvas');
                
                // Enhanced crop settings for Apple products
                const cropY = video.videoHeight * 0.45;
                const cropHeight = video.videoHeight * 0.18;
                const cropX = video.videoWidth * 0.05;
                const cropWidth = video.videoWidth * 0.90;
                
                canvas.width = cropWidth;
                canvas.height = cropHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

                // Show preview
                const preview = document.getElementById('floating-ocr-preview');
                if (preview) {
                    preview.classList.remove('hidden');
                    preview.width = canvas.width;
                    preview.height = canvas.height;
                    preview.getContext('2d').drawImage(canvas, 0, 0);
                }

                try {
                    let processedImageData;
                      if (pyodideReady) {
                        // Use Pyodide for enhanced Serial/SKU processing
                        const imageDataURL = canvas.toDataURL('image/png');
                        
                        // Analyze image quality first
                        const quality = pyodide.runPython(`analyze_image_quality("""${imageDataURL}""")`);
                        const qualityObj = quality.toJs();
                        
                        if (qualityObj.error) {
                            throw new Error(qualityObj.error);
                        }
                          // Provide enhanced quality feedback for Serial/SKU
                        if (qualityObj.overall === 'too_dark') {
                            updateFloatingResults(`<p class="text-yellow-600">ภาพมืดเกินไป กรุณาเพิ่มแสงสว่าง (${qualityObj.brightness.toFixed(0)})</p>`);
                            return;
                        } else if (qualityObj.overall === 'too_bright') {
                            updateFloatingResults(`<p class="text-yellow-600">ภาพสว่างเกินไป กรุณาลดแสงสว่าง (${qualityObj.brightness.toFixed(0)})</p>`);
                            return;
                        } else if (qualityObj.overall === 'low_contrast') {
                            updateFloatingResults(`<p class="text-yellow-600">ภาพไม่ชัดเจน กรุณาปรับโฟกัส (ความชัด: ${qualityObj.contrast.toFixed(0)})</p>`);
                            return;
                        } else if (qualityObj.overall === 'blurry') {
                            updateFloatingResults(`<p class="text-yellow-600">ภาพเบลอ กรุณาปรับโฟกัส (ความคม: ${qualityObj.sharpness.toFixed(0)})</p>`);
                            return;
                        } else if (qualityObj.overall === 'insufficient_detail') {
                            updateFloatingResults(`<p class="text-yellow-600">รายละเอียดไม่เพียงพอ กรุณาเข้าใกล้ข้อความ</p>`);
                            return;
                        } else if (qualityObj.overall === 'no_text_detected') {
                            updateFloatingResults(`<p class="text-yellow-600">ไม่พบข้อความ กรุณาจัดตำแหน่งกล้อง</p>`);
                            return;
                        }
                        
                        // Process image with Pyodide enhanced Serial/SKU processing
                        processedImageData = pyodide.runPython(`process_image_enhanced("""${imageDataURL}""", "${floatingOcrSettings.preprocessing}")`);
                        
                        if (processedImageData.startsWith('Error:')) {
                            throw new Error(processedImageData);
                        }
                        
                        // Convert processed image back to canvas
                        const img = new Image();
                        img.onload = async () => {
                            const processedCanvas = document.createElement('canvas');
                            processedCanvas.width = img.width;
                            processedCanvas.height = img.height;
                            const processedCtx = processedCanvas.getContext('2d');
                            processedCtx.drawImage(img, 0, 0);
                            
                            await performOCRRecognition(processedCanvas, startTime);
                        };
                        img.src = processedImageData;
                        
                    } else {
                        // Fallback to OpenCV processing
                        await performOpenCVProcessing(canvas, startTime);
                    }
                      } catch (err) {
                    updateFloatingResults(`<p class="text-red-500">Processing error: ${err.message}</p>`);
                }
            }

            async function performOpenCVProcessing(canvas, startTime) {
                if (!cvReady) return;
                
                let src = cv.imread(canvas);
                let dst = new cv.Mat();
                
                // Apply OpenCV preprocessing based on settings
                if (floatingOcrSettings.preprocessing === 'basic') {
                    cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);
                    const sharpKernel = cv.matFromArray(3, 3, cv.CV_32FC1, [0, -1, 0, -1, 5, -1, 0, -1, 0]);
                    cv.filter2D(dst, dst, -1, sharpKernel);
                    sharpKernel.delete();
                    cv.threshold(dst, dst, 0, 255, cv.THRESH_OTSU | cv.THRESH_BINARY_INV);
                } else if (floatingOcrSettings.preprocessing === 'enhanced') {
                    cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);
                    const clahe = new cv.CLAHE(2.0, new cv.Size(8, 8));
                    clahe.apply(dst, dst);
                    clahe.delete();
                    cv.bilateralFilter(dst, dst, 9, 75, 75);
                    const blurred = new cv.Mat();
                    cv.GaussianBlur(dst, blurred, new cv.Size(3, 3), 0, 0, cv.BORDER_DEFAULT);
                    cv.addWeighted(dst, 1.5, blurred, -0.5, 0, dst);
                    blurred.delete();
                    cv.threshold(dst, dst, 0, 255, cv.THRESH_OTSU | cv.THRESH_BINARY_INV);
                }
                
                cv.imshow(canvas, dst);
                src.delete();
                dst.delete();
                
                await performOCRRecognition(canvas, startTime);
            }

            async function performOCRRecognition(canvas, startTime) {
                if (!tesseractWorker) {
                    await initTesseract('eng', true);
                }
                
                const result = await tesseractWorker.recognize(canvas);
                const processingTime = performance.now() - startTime;
                
                let text = result.data.text.replace(/\s/g, '').toUpperCase();
                let confidence = result.data.confidence;
                  // Enhanced Serial/SKU processing with Pyodide
                if (pyodideReady) {
                    try {
                        // Use Pyodide for advanced Serial/SKU pattern extraction
                        const extractionResult = pyodide.runPython(`extract_serial_sku_patterns("""${text}""")`);
                        const patterns = extractionResult.toJs();
                        
                        if (patterns.error) {
                            throw new Error(patterns.error);
                        }
                        
                        // Check if we have high-confidence Serial/SKU matches
                        if (patterns.best_matches && patterns.best_matches.length > 0) {
                            const bestMatch = patterns.best_matches[0];
                            
                            // Validate confidence and score thresholds
                            if (bestMatch.score >= 70 && confidence >= floatingOcrSettings.confidence) {
                                const finalText = bestMatch.text;
                                const patternType = bestMatch.pattern;
                                
                                updateFloatingResults(`
                                    <div class="text-left space-y-1">
                                        <p><strong>${patternType.includes('serial') ? 'Serial' : 'SKU'}:</strong> <span class="font-mono text-blue-600">${finalText}</span></p>
                                        <div class="flex justify-between text-xs text-gray-500">
                                            <span>Score: ${bestMatch.score}%</span>
                                            <span>OCR: ${confidence.toFixed(1)}%</span>
                                        </div>
                                        <p class="text-xs text-green-600">Pattern: ${patternType}</p>
                                    </div>
                                `);
                                
                                processFloatingScannedCode(finalText, 'DEMO-Enhanced Text Scan');
                                stopFloatingOcrStreaming();
                                return;
                            }
                        }
                        
                        // Show scanning progress with pattern information
                        const patternCount = Object.keys(patterns.all_patterns || {}).length;
                        updateFloatingResults(`
                            <div class="text-center space-y-1">
                                <p class="text-blue-500">Scanning Serial/SKU...</p>
                                <div class="flex justify-between text-xs text-gray-500">
                                    <span>OCR: ${confidence.toFixed(1)}%</span>
                                    <span>Patterns: ${patternCount}</span>
                                </div>
                                <p class="text-xs text-gray-400">${patterns.cleaned_text.substring(0, 20)}${patterns.cleaned_text.length > 20 ? '...' : ''}</p>
                            </div>
                        `);
                        
                    } catch (pyodideError) {
                        // Pyodide pattern extraction failed, falling back to basic processing
                        // Fallback to basic processing
                        performBasicSerialSKUProcessing(text, confidence);
                    }
                } else {
                    // Fallback when Pyodide is not ready
                    performBasicSerialSKUProcessing(text, confidence);
                }
            }
            
            function performBasicSerialSKUProcessing(text, confidence) {
                // Apple-specific text post-processing (fallback)
                text = text.replace(/[|]/g, 'I')
                           .replace(/[0]/g, 'O')
                           .replace(/[8]/g, 'B')
                           .replace(/[5]/g, 'S')
                           .replace(/[1]/g, 'I')
                           .replace(/[\.]/g, '')
                           .replace(/[,]/g, '')
                           .replace(/[\s]/g, '');
                
                // Enhanced Apple serial validation
                const appleSerialMatch = text.match(/[A-Z0-9\-]{8,}/);
                const isValidAppleSerial = appleSerialMatch && (
                    text.length >= 8 && text.length <= 14 &&
                    /[A-Z]/.test(text) &&
                    /[0-9]/.test(text) &&
                    !/[^A-Z0-9\-]/.test(text)
                );
                  if (isValidAppleSerial && confidence >= floatingOcrSettings.confidence) {
                    const finalText = appleSerialMatch[0];
                    updateFloatingResults(`<p>Serial/SKU: <b>${finalText}</b></p>`);
                    processFloatingScannedCode(finalText, 'DEMO-Text Scan');
                    stopFloatingOcrStreaming();
                } else {
                    updateFloatingResults(`<p class='text-blue-500'>Scanning... (${confidence.toFixed(1)}%)</p>`);
                }
            }

            async function captureAndRecognizeFloating() {
                if (!floatingStream || !cvReady) {
                    updateFloatingResults(`<p class="text-red-500">Camera or OpenCV not ready</p>`);
                    return;
                }
                
                updateFloatingResults(`<p class="text-blue-500">กำลังประมวลผลตัวอักษร...</p>`);
                const captureBtn = document.getElementById('floating-capture-btn');
                captureBtn.disabled = true;
                
                try {
                    const video = document.getElementById('floating-text-video');
                    const canvas = document.createElement('canvas');
                    
                    const cropHeightPercentage = 0.15;
                    const cropWidthPercentage = 0.70;
                    const sWidth = video.videoWidth * cropWidthPercentage;
                    const sHeight = video.videoHeight * cropHeightPercentage;
                    const sx = video.videoWidth * (1 - cropWidthPercentage) / 2;
                    const sy = video.videoHeight * 0.45;
                    
                    canvas.width = sWidth;
                    canvas.height = sHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);
                    
                    await performOCRRecognition(canvas, performance.now());
                    
                } catch (err) {
                    updateFloatingResults(`<p class="text-red-500">Capture error: ${err.message}</p>`);
                } finally {
                    captureBtn.disabled = false;
                }
            }            
            
            function processFloatingScannedCode(code, reason) {
                const scannedText = code.toUpperCase();
                // Store latest scanned text and add to history
                lastScannedText = scannedText;
                scanHistory.unshift({ text: scannedText, timestamp: new Date().toLocaleTimeString(), reason });
                if (scanHistory.length > 10) scanHistory.pop(); // Keep last 10 scans
                
                let item = null;
                
                // Determine which dataset to search based on context
                const searchData = currentScannerContext === 'demo' ? state.demoMaster : state.reconciledData;
                  if (!searchData || searchData.length === 0) {
                    playSound('error');
                    updateFloatingResults(`<div class="text-center w-full"><p class="font-bold text-red-600">No data available</p><p class="text-sm text-slate-500">Scanned: ${scannedText}</p><p class="text-xs text-slate-400">Latest scan stored</p></div>`);
                    return;
                }
                
                // Use shared matching function
                item = findItemByScannedText(searchData, scannedText);
                
                if (item) {
                    playSound('success');
                    
                    if (currentScannerContext === 'demo') {
                        // Update demo count
                        let currentCount = typeof item.counted === 'number' ? item.counted : 0;
                        item.counted = currentCount + 1;
                        state.demoCounts[item.SKU] = { qty: item.counted, reason: reason };
                        applyDemoView();
                        
                        const diff = item.counted - item.SOH;
                        let statusText = (diff === 0) ? 'Matched' : (diff > 0) ? 'Overage' : 'Shortage';
                        let statusColor = (diff === 0) ? 'text-green-600' : (diff > 0) ? 'text-yellow-600' : 'text-blue-600';
                        
                        updateFloatingResults(`<div class="text-left w-full space-y-1"><p class="font-medium text-slate-800">${item.Description}</p><p class="text-sm text-slate-500">SKU: ${item.SKU}</p><div class="flex justify-between items-baseline pt-1"><span class="text-lg font-bold text-slate-700">Count: <span class="text-blue-600">${item.counted}</span> / ${item.SOH}</span><span class="text-lg font-bold ${statusColor}">${statusText}</span></div><p class="text-xs text-green-600 mt-1">✓ Match found for: ${scannedText}</p></div>`);
                    } else {
                        // Final report context - just highlight the found item
                        updateFloatingResults(`<div class="text-left w-full space-y-1"><p class="font-medium text-slate-800">${item.Description}</p><p class="text-sm text-slate-500">SKU: ${item.SKU}</p><div class="flex justify-between items-baseline pt-1"><span class="text-lg font-bold text-slate-700">Counted: <span class="text-blue-600">${item.Recount}</span> / ${item.SOH}</span><span class="text-lg font-bold">${item.FinalDiff === 0 ? '<span class="text-green-600">Matched</span>' : item.FinalDiff > 0 ? '<span class="text-yellow-600">Overage</span>' : '<span class="text-blue-600">Shortage</span>'}</span></div><p class="text-xs text-green-600 mt-1">✓ Match found for: ${scannedText}</p></div>`);
                    }
                    
                    // Scroll to item in table
                    const tableContainer = currentScannerContext === 'demo' ? 
                        document.getElementById('demo-count-container') : 
                        document.getElementById('final-report-table-container');
                        
                    const row = tableContainer.querySelector(`tr[data-sku="${item.SKU}"]`);
                    if (row) {
                        row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        row.classList.add('ring-2', 'ring-offset-2', 'ring-green-500');
                        setTimeout(() => row.classList.remove('ring-2', 'ring-offset-2', 'ring-green-500'), 800);
                    }                } else {
                    playSound('error');
                    // Show scanned text even when no match found
                    updateFloatingResults(`<div class="text-center w-full"><p class="font-bold text-red-600">SKU Not Found</p><p class="text-sm text-slate-700 font-medium">Scanned: ${scannedText}</p><p class="text-xs text-slate-400 mt-1">Latest scan stored • No matching SKU in ${currentScannerContext} data</p></div>`);
                }
            }

            const floatingScanCooldown = {};
            function onFloatingBarcodeDetected(result) {
                const code = result.codeResult.code.trim();
                const now = Date.now();
                if (floatingScanCooldown[code] && now - floatingScanCooldown[code] < 2000) return;
                floatingScanCooldown[code] = now;
                processFloatingScannedCode(code, 'DEMO-Barcode');
            }            
            function openFloatingScanner(context = 'demo') {
                currentScannerContext = context;
                currentScannerMode = 'barcode';
                  // Reset scanner state
                document.getElementById('floating-barcode-tab').classList.add('active');
                document.getElementById('floating-text-tab').classList.remove('active');
                document.getElementById('floating-barcode-view').classList.remove('hidden');
                document.getElementById('floating-text-view').classList.add('hidden');
                document.getElementById('floating-ocr-preview').classList.add('hidden');
                document.getElementById('floating-ocr-controls').classList.add('hidden');
                
                // Ensure proper display and visibility
                floatingScanner.style.display = 'block';
                floatingScanner.style.visibility = 'visible';
                floatingScanner.style.opacity = '1';
                
                // Show scanner with animation
                floatingScanner.classList.add('active');
                
                // Start with barcode scanner
                setTimeout(() => {
                    startFloatingBarcodeScanner();
                }, 300);
                
                // Initialize Pyodide if not already done
                if (!pyodideReady) {
                    initializePyodide();
                }
                  updateFloatingResults('<p class="text-blue-500">Scanner ready</p>');
            }
            function closeFloatingScanner() {                
                if (!floatingScanner) return;
                // Stop all scanner activities first
                stopFloatingTextScanner();
                stopFloatingBarcodeScanner();
                stopFloatingOcrStreaming();
                
                // Clear all video streams
                const video = document.getElementById('floating-text-video');
                if (video && video.srcObject) {                    
                    const tracks = video.srcObject.getTracks();
                    tracks.forEach(track => {
                        track.stop();
                    });
                    video.srcObject = null;
                }
                
                // Force stop Quagga barcode scanner
                if (typeof Quagga !== 'undefined' && Quagga.running) {                    
                    try {
                        Quagga.offDetected(onFloatingBarcodeDetected);
                        Quagga.stop();                    
                    } catch (err) {
                        // Silent error handling for production
                    }
                }
                
                // Clear barcode scanner video
                const barcodeView = document.getElementById('floating-barcode-view');
                const quaggaVideo = barcodeView.querySelector('video');
                if (quaggaVideo && quaggaVideo.srcObject) {
                    const tracks = quaggaVideo.srcObject.getTracks();                
                    tracks.forEach(track => track.stop());
                    quaggaVideo.srcObject = null;
                }
                
                // Reset any custom transform on scanner
                floatingScanner.style.transform = '';
                
                // Ensure proper transition is enabled
                floatingScanner.style.transition = 'transform 0.3s ease-in-out, visibility 0.3s ease-in-out, opacity 0.3s ease-in-out';
                
                // Hide scanner completely with proper CSS states
                floatingScanner.classList.remove('active');
                  // Force complete hiding after animation
                setTimeout(() => {
                    if (!floatingScanner.classList.contains('active')) {
                        floatingScanner.style.display = 'none';
                        floatingScanner.style.visibility = 'hidden';
                        floatingScanner.style.opacity = '0';
                    }
                }, 350); // Wait for CSS transition to complete
                
                // Reset tab states for next opening
                setTimeout(() => {
                    document.getElementById('floating-barcode-tab').classList.add('active');
                    document.getElementById('floating-text-tab').classList.remove('active');
                    document.getElementById('floating-barcode-view').classList.remove('hidden');
                    document.getElementById('floating-text-view').classList.add('hidden');
                    document.getElementById('floating-ocr-preview').classList.add('hidden');
                    document.getElementById('floating-ocr-controls').classList.add('hidden');
                      // Clear results when scanner is closed
                    updateFloatingResults('<p class="text-gray-400">Click scan to start</p>');
                    
                    currentScannerMode = 'barcode';
                }, 400); // Wait for animation to complete
            }

            function updateFloatingResults(html) {
                const resultsEl = document.getElementById('floating-scanner-results');
                if (resultsEl) {
                    resultsEl.innerHTML = html;
                }            }

            // === OCR Enhancement Variables ===
            let tesseractWorker = null;            // === OCR Variables (simplified) ===
            let ocrSettings = {
                demo: { confidence: 60, language: 'eng', preprocessing: 'enhanced', speed: 800 },
                final: { confidence: 60, language: 'eng', preprocessing: 'enhanced', speed: 800 }
            };

            // === OCR Enhancement Functions ===
            async function initTesseract(language = 'eng', isDemo = true) {
                const worker = isDemo ? tesseractWorker : finalTesseractWorker;
                if (worker) {
                    await worker.terminate();
                }
                
                const newWorker = await Tesseract.createWorker(language);
                
                // Enhanced OCR parameters for Apple product serial numbers
                await newWorker.setParameters({
                    // Character whitelist optimized for Apple serials
                    tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_',
                    // Single line mode for serial numbers
                    tessedit_pageseg_mode: Tesseract.PSM.SINGLE_LINE,
                    // Improved OCR engine mode for better accuracy
                    tessedit_ocr_engine_mode: Tesseract.OEM.LSTM_ONLY,
                    // Enable dictionary for better word recognition
                    tessedit_enable_dict_correction: 1,
                    // Numeric mode for better digit recognition
                    tessedit_enable_numeric_mode: 1,
                    // Improve recognition of similar characters
                    tessedit_char_unblacklist: '',
                    // Better handling of mixed alphanumeric content
                    preserve_interword_spaces: 0,
                    // Optimize for Apple's typical serial number patterns
                    user_defined_dpi: 300,
                    // Better edge detection for clear text
                    edges_use_image_gradients: 1
                });
                  if (isDemo) {
                    tesseractWorker = newWorker;
                } else {
                    finalTesseractWorker = newWorker;
                }
                
                return newWorker;
            }

            function generateCacheKey(imageData, settings) {
                const canvas = document.createElement('canvas');
                canvas.width = 50;
                canvas.height = 20;
                const ctx = canvas.getContext('2d');
                ctx.putImageData(imageData, 0, 0);
                const hash = btoa(canvas.toDataURL()).slice(0, 16);
                return `${hash}-${settings.language}-${settings.preprocessing}-${settings.confidence}`;
            }            function learnSuccessPattern(text, confidence, processingTime, isDemo = true) {
                const pattern = text.substring(0, 3); // First 3 characters as pattern
                const patternMap = isDemo ? ocrPatternLearning : finalOcrPatternLearning;
                
                if (!patternMap.has(pattern)) {
                    patternMap.set(pattern, { count: 0, avgConfidence: 0, avgTime: 0 });
                }
                const existing = patternMap.get(pattern);
                existing.count++;
                existing.avgConfidence = (existing.avgConfidence + confidence) / 2;
                existing.avgTime = (existing.avgTime + processingTime) / 2;
            }            function boostConfidenceForKnownPatterns(text, confidence, isDemo = true) {
                const pattern = text.substring(0, 3);
                const patternMap = isDemo ? ocrPatternLearning : finalOcrPatternLearning;
                const learned = patternMap.get(pattern);
                if (learned && learned.count > 2) {
                    return Math.min(confidence + (learned.avgConfidence * 0.1), 100);
                }
                return confidence;
            }            // Error recovery functions
            function handleOcrError(error, isDemo = true) {
                const errorMsg = error.message || 'Unknown OCR error';
                // OCR error handled silently for production
                
                // Handle error processing
                if (isDemo) {
                } else {
                }
                  // Attempt recovery based on error type
                if (errorMsg.includes('Worker')) {
                    // Worker-related error - reinitialize
                    setTimeout(() => {
                        initTesseract(isDemo ? ocrSettings.demo.language : ocrSettings.final.language, isDemo);
                    }, 1000);
                } else if (errorMsg.includes('canvas') || errorMsg.includes('image')) {
                    // Image processing error - skip frame
                } else if (errorMsg.includes('memory')) {                    // Memory issue - clear cache and restart
                    cleanupOcrCache();
                    setTimeout(() => {
                        initTesseract(isDemo ? ocrSettings.demo.language : ocrSettings.final.language, isDemo);
                    }, 2000);
                }
                
                return false; // Indicate error was handled
            }

            function validateOcrResult(result, confidence, expectedPattern = /[A-Z0-9\-]{8,}/) {
                if (!result || !result.data) return false;
                
                const text = result.data.text.replace(/\s/g, '').toUpperCase();
                const hasValidPattern = expectedPattern.test(text);
                const hasValidConfidence = confidence >= 30; // Minimum threshold
                
                return hasValidPattern && hasValidConfidence;
            }

            function adaptiveOcrSettings(performance, isDemo = true) {
                const settings = isDemo ? ocrSettings.demo : ocrSettings.final;
                const recentPerformance = (isDemo ? ocrPerformanceHistory : finalOcrPerformanceHistory).slice(-10);
                
                if (recentPerformance.length < 5) return; // Not enough data
                
                const avgConfidence = recentPerformance.reduce((sum, p) => sum + p.confidence, 0) / recentPerformance.length;
                const successRate = recentPerformance.filter(p => p.success).length / recentPerformance.length;
                  // Adapt preprocessing based on performance
                if (successRate < 0.3 && avgConfidence < 70) {
                    // Poor performance - increase preprocessing
                    if (settings.preprocessing === 'basic') {
                        settings.preprocessing = 'enhanced';
                    } else if (settings.preprocessing === 'enhanced') {
                        settings.preprocessing = 'aggressive';
                    }
                } else if (successRate > 0.8 && avgConfidence > 85) {
                    // Great performance - reduce preprocessing for speed
                    if (settings.preprocessing === 'aggressive') {
                        settings.preprocessing = 'enhanced';
                    } else if (settings.preprocessing === 'enhanced') {
                        settings.preprocessing = 'basic';
                    }
                }
                
                // Update UI if needed
                const selectElement = document.getElementById(isDemo ? 'ocr-preprocessing-select' : 'final-ocr-preprocessing-select');
                if (selectElement && selectElement.value !== settings.preprocessing) {
                    selectElement.value = settings.preprocessing;
                }            }

            // Cache management functions
            function cleanupOcrCache() {
                const now = Date.now();
                const maxAge = 5 * 60 * 1000; // 5 minutes
                
                // Clean demo cache
                for (const [key, value] of ocrResultsCache.entries()) {
                    if (now - value.timestamp > maxAge) {
                        ocrResultsCache.delete(key);
                    }
                }
                
                // Clean final cache
                for (const [key, value] of finalOcrResultsCache.entries()) {
                    if (now - value.timestamp > maxAge) {
                        finalOcrResultsCache.delete(key);
                    }
                }
                
                // Limit cache size
                const maxCacheSize = 100;
                if (ocrResultsCache.size > maxCacheSize) {
                    const entries = Array.from(ocrResultsCache.entries());
                    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
                    const toDelete = entries.slice(0, entries.length - maxCacheSize);
                    toDelete.forEach(([key]) => ocrResultsCache.delete(key));
                }
                
                if (finalOcrResultsCache.size > maxCacheSize) {
                    const entries = Array.from(finalOcrResultsCache.entries());
                    entries.sort((a, b) => a[1].timestamp - b[1].timestamp);
                    const toDelete = entries.slice(0, entries.length - maxCacheSize);
                    toDelete.forEach(([key]) => finalOcrResultsCache.delete(key));                
                }
            }
            
            function resetOcrStats() {
                ocrSuccessCount = 0;
                ocrTotalAttempts = 0;
                ocrCacheHits = 0;
                ocrPerformanceHistory.length = 0;
                ocrResultsCache.clear();
                ocrPatternLearning.clear();
                  finalOcrSuccessCount = 0;
                finalOcrTotalAttempts = 0;
                finalOcrCacheHits = 0;
                finalOcrPerformanceHistory.length = 0;
                finalOcrResultsCache.clear();
                finalOcrPatternLearning.clear();
            }            // Auto-cleanup cache every 2 minutes
            setInterval(cleanupOcrCache, 2 * 60 * 1000);

            // === Shared SKU Matching Functions ===
            function getMatchingAlgorithms() {
                return [
                    // Algorithm 1: Direct SKU contained in scanned text
                    (sku, scanned) => scanned.includes(sku),
                    // Algorithm 2: SKU with S prefix contained in scanned text
                    (sku, scanned) => scanned.includes(sku.slice(1)),
                    // Algorithm 3: SKU without S prefix (if SKU starts with S)
                    (sku, scanned) => sku.startsWith('S') && scanned.includes(sku.slice(1)),
                    // Algorithm 4: Scanned text with S prefix matches SKU
                    (sku, scanned) => ('S' + scanned) === sku,
                    // Algorithm 5: Last 5 characters pattern match
                    (sku, scanned) => {
                        if (sku.length >= 5) {
                            const skuLast5 = sku.slice(-5);
                            return scanned.includes(skuLast5);
                        }
                        return false;
                    },
                    // Algorithm 6: First 5 characters pattern match
                    (sku, scanned) => {
                        if (sku.length >= 5) {
                            const skuFirst5 = sku.slice(0, 5);
                            return scanned.includes(skuFirst5);
                        }
                        return false;
                    },
                    // Algorithm 7: Middle pattern match (removes first and last char)
                    (sku, scanned) => {
                        if (sku.length >= 6) {
                            const skuMiddle = sku.slice(1, -1);
                            return scanned.includes(skuMiddle);
                        }
                        return false;
                    },
                    // Algorithm 8: Fuzzy match for Apple serial patterns
                    (sku, scanned) => {
                        const cleanSku = sku.replace(/^S?/, '').replace(/[-_].*$/, '');
                        const cleanScanned = scanned.replace(/[-_].*$/, '');
                        return cleanSku.length >= 4 && cleanScanned.includes(cleanSku);
                    },
                    // Algorithm 9: CS prefix matching
                    (sku, scanned) => sku.includes('CS' + scanned),
                    // Algorithm 10: cs prefix matching
                    (sku, scanned) => sku.includes('cs' + scanned),
                    // Algorithm 11: 0 prefix matching
                    (sku, scanned) => sku.includes('0' + scanned),
                    // Algorithm 12: SKU without CS prefix (if SKU starts with CS)
                    (sku, scanned) => sku.startsWith('CS') && scanned.includes(sku.slice(2)),
                    // Algorithm 13: SKU without cs prefix (if SKU starts with cs)
                    (sku, scanned) => sku.startsWith('cs') && scanned.includes(sku.slice(2)),
                    // Algorithm 14: SKU without 0 prefix (if SKU starts with 0)
                    (sku, scanned) => sku.startsWith('0') && scanned.includes(sku.slice(1))
                ];
            }

            function findItemByScannedText(items, scannedText) {
                // Try direct matches first
                let item = items.find(i => i.SKU === scannedText) ||
                          items.find(i => i.SKU === 'S' + scannedText) ||
                          items.find(i => i.SKU === 'CS' + scannedText) ||
                          items.find(i => i.SKU === 'cs' + scannedText) ||
                          items.find(i => i.SKU === '0' + scannedText);

                // If not found, try advanced matching algorithms
                if (!item) {
                    const matchingAlgorithms = getMatchingAlgorithms();
                    for (const dataItem of items) {
                        for (const algorithm of matchingAlgorithms) {
                            if (algorithm(dataItem.SKU, scannedText)) {
                                item = dataItem;
                                break;
                            }
                        }
                        if (item) break;
                    }
                }

                return item;
            }            function getInitialState() {
                return {
                    sohData: [], sohLookup: {}, scannerMaster: [], demoMaster: [],
                    demoCounts: {}, demoSort: { column: 'SKU', direction: 'asc' },
                    netDiffData: [], reconciledData: [], finalReportSort: { column: 'SKU', direction: 'asc' },
                    charts: { cost: null, qty: null, category: null },
                    branchName: null, branchCode: null, countDate: null,
                    sohUpdatedSkus: new Set(), // Track SKUs that had SOH updated
                };
            }
            
            const formatNumber = (num) => (num ?? 0).toLocaleString('en-US');

            function showLoader(message = "Processing...") { 
                getEl('loader-message').textContent = message;
                getEl('loader-overlay').classList.remove('hidden'); 
            }
            function hideLoader() { getEl('loader-overlay').classList.add('hidden'); }
            
            function showModal(title, message, options = {}) {
                getEl('modal-title').textContent = title;
                getEl('modal-message').innerHTML = message;
                const confirmBtn = getEl('modal-confirm-btn');
                const cancelBtn = getEl('modal-cancel-btn');
                confirmBtn.textContent = options.confirmText || 'OK';
                confirmBtn.onclick = () => { hideModal(); if (options.onConfirm) options.onConfirm(); };
                cancelBtn.classList.toggle('hidden', !options.onCancel);
                if (options.onCancel) {
                    cancelBtn.textContent = options.cancelText || 'Cancel';
                    cancelBtn.onclick = () => { hideModal(); options.onCancel(); };
                }
                getEl('modal-container').classList.remove('hidden');
                setTimeout(() => getEl('modal-box').classList.add('scale-100', 'opacity-100'), 10);
            }

            function hideModal() {
                getEl('modal-box').classList.add('scale-95', 'opacity-0');
                setTimeout(() => getEl('modal-container').classList.add('hidden'), 200);
            }

            let saveStatusTimeout;
            function showSaveStatus(message, isWarning) {
                const statusEl = getEl('save-status');
                clearTimeout(saveStatusTimeout);
                statusEl.textContent = message;
                statusEl.className = `text-left text-sm font-semibold opacity-100 ${isWarning ? 'text-red-600' : 'text-green-600'}`;
                if (!isWarning) {
                    saveStatusTimeout = setTimeout(() => statusEl.classList.add('opacity-0'), 3000);
                }
            }
            function updateInfoBox() {
                if (state.branchName) {
                    getEl('info-branch-code').textContent = state.branchCode || '';
                    getEl('info-branch-name').textContent = state.branchName;
                    getEl('info-count-date').textContent = state.countDate;
                    getEl('info-box-container').classList.remove('hidden');
                } else {
                    getEl('info-box-container').classList.add('hidden');
                }
            }
            function resetAppState() {
                // Destroy existing charts
                Object.values(state.charts).forEach(chart => chart?.destroy());
                
                // Reset application state
                state = getInitialState();
                hasUnsavedChanges = false;
                finalSummaryData = {};
                
                // Reset scanner-related variables
                lastScannedText = null;
                scanHistory = [];
                currentScannerMode = 'barcode';
                currentScannerContext = 'demo';
                floatingOcrStreaming = false;
                
                // Clear OCR streaming if active
                if (floatingOcrStreamInterval) {
                    clearInterval(floatingOcrStreamInterval);
                    floatingOcrStreamInterval = null;
                }
                
                // Reset floating scanner settings
                floatingOcrSettings = {
                    confidence: 60,
                    preprocessing: 'enhanced',
                    speed: 800
                };
            }
            function resetUI() {
                // Hide/show main containers
                getEl('workspace-container').classList.add('hidden');
                getEl('final-report-container').classList.add('hidden');
                getEl('upload-container').classList.remove('hidden');
                  // Clear all file inputs
                ['initialSohFile', 'firstScanLogfile', 'secondScanLogfile', 'latestSohFile', 'salesDataFile', 'firstMasterFile', 'secondMasterFile'].forEach(id => {
                    const el = getEl(id);
                    if (el) el.value = '';
                });
                
                // Reset file name displays
                getEl('initialSohFileName').textContent = '(.xlsx, .csv)';
                getEl('latestSohFileName').textContent = '';
                
                // Hide info box and result containers
                getEl('info-box-container').classList.add('hidden');
                getEl('step2-results').classList.add('hidden');
                getEl('sales-processing-results').classList.add('hidden');                // Clear result container contents
                getEl('netdiff-summary-container').innerHTML = '';
                getEl('demo-count-container').innerHTML = '';
                getEl('demo-summary').innerHTML = '';
                getEl('final-report-table-container').innerHTML = '';
                getEl('final-summary').innerHTML = '';
                
                // Clear floating scanner results
                const floatingResults = getEl('floating-scanner-results');
                if (floatingResults) floatingResults.innerHTML = '';
                
                // Close floating scanner if open
                const floatingScanner = getEl('floating-scanner');
                if (floatingScanner && floatingScanner.classList.contains('active')) {
                    closeFloatingScanner();
                }
                
                // Reset button states
                getEl('downloadMasterForScan').disabled = true;
                getEl('processFirstCount').disabled = true;
                getEl('finalizeFromFirstCount').disabled = true;
                getEl('generateRecountMasterFile').disabled = true;                
                getEl('processSecondCount').disabled = true;
                getEl('processSalesData').disabled = true;
                getEl('latestSohFile').disabled = true;
                
                // Reset search inputs
                const demoSearchInput = getEl('demoSearchInput');
                if (demoSearchInput) demoSearchInput.value = '';
                const finalSearchInput = getEl('finalSearchInput');
                if (finalSearchInput) finalSearchInput.value = '';
                
                // Reset filter selects
                const demoFilterSelect = getEl('demoFilterSelect');
                if (demoFilterSelect) demoFilterSelect.value = 'all';
                const finalFilterSelect = getEl('finalFilterSelect');
                if (finalFilterSelect) finalFilterSelect.value = 'all';
                
                // Reset main tabs to demo view
                const demoTab = getEl('main-tab-demo');
                const workflowTab = getEl('main-tab-workflow');
                if (demoTab && workflowTab) {
                    demoTab.classList.add('active');
                    workflowTab.classList.remove('active');
                    getEl('main-panel-demo').classList.remove('hidden');
                    getEl('main-panel-workflow').classList.add('hidden');
                }
                  // Reset workflow step tabs to step 1
                document.querySelectorAll('#wf-step-tabs .tab-button').forEach(btn => btn.classList.remove('active'));
                getEl('wf-tab-btn-1').classList.add('active');
                document.querySelectorAll('.workflow-step').forEach(div => div.classList.add('hidden'));
                getEl('wf-step1').classList.remove('hidden');
                
                // Reset OCR controls to default values
                const confidenceSlider = getEl('floating-confidence-slider');
                const confidenceValue = getEl('floating-confidence-value');
                const preprocessingSelect = getEl('floating-preprocessing-select');
                if (confidenceSlider) {
                    confidenceSlider.value = '60';
                    if (confidenceValue) confidenceValue.textContent = '60%';
                }
                if (preprocessingSelect) {
                    preprocessingSelect.value = 'enhanced';
                }
            }
            
            function setUnsavedChanges(status){
                hasUnsavedChanges = status;
                if (status) {
                    showSaveStatus("Unsaved changes", true);
                }
            }
            
            function startNewJob() {
                showModal('Start New Job?', 'Are you sure? All unsaved progress will be lost.', {
                    confirmText: 'Yes, Start New Job',
                    onConfirm: () => {
                        resetAppState();
                        resetUI();
                        getEl('save-status').classList.add('opacity-0');
                    },
                    onCancel: ()=> {},
                    cancelText: 'Cancel'
                });
            }
            async function handleSohFileUpload(e) {
                const file = e.target.files[0];
                if (!file) return;
                getEl('initialSohFileName').textContent = file.name;
                showLoader();
                try {
                    resetAppState();
                    const data = await parseExcelFile(file);
                    if (!data?.length) throw new Error("File is empty or invalid.");
                    if (!data[0]?.BRANCH_NAME) throw new Error("'BRANCH_NAME' column is missing.");
                    
                    // Extract branch information
                    state.branchName = data[0].BRANCH_NAME;
                    
                    // Extract BRANCH_CODE if available
                    if (data[0]?.BRANCH_CODE) {
                        state.branchCode = data[0].BRANCH_CODE;
                    } else {
                        // If BRANCH_CODE column doesn't exist, try to extract from BRANCH_NAME
                        // Assume format like "001 - Branch Name" or similar
                        const branchNameMatch = state.branchName.match(/^(\d+)/);
                        state.branchCode = branchNameMatch ? branchNameMatch[1] : 'UNK';
                    }
                    
                    state.countDate = new Date().toLocaleDateString('en-CA');
                    const { forScan, forDemo, lookup } = processAndSeparateSoh(data);
                    if (Object.keys(lookup).length === 0) throw new Error("No valid stock items found. Check SKU/AVAILABLE_QTY columns.");
                    state.sohData = data;
                    state.sohLookup = lookup;
                    state.scannerMaster = forScan;
                    state.demoMaster = forDemo.map(item => ({ ...item, counted: null, reason: 'DEMO-Manual' }));
                    rebuildUiFromState();
                    setUnsavedChanges(true); 
                } catch (error) {
                    showModal("Error Processing File", error.message);
                    resetAppState();
                    resetUI();
                } finally {
                    hideLoader();
                }
            }            function handleSaveProgressToFile() {
                if (!state.sohData.length) {
                    return showModal("Info", "There is no progress to save.");
                }
                const stateToSave = { 
                    ...state, 
                    charts: {},
                    // Convert Set to Array for JSON serialization
                    sohUpdatedSkus: state.sohUpdatedSkus ? Array.from(state.sohUpdatedSkus) : []
                };
                const blob = new Blob([JSON.stringify(stateToSave, null, 2)], { type: 'application/json' });
                const branchInfo = state.branchCode ? `${state.branchCode}_${state.branchName.replace(/\s+/g, '_')}` : state.branchName.replace(/\s+/g, '_');
                const fileName = `${state.countDate}_stock_count_${branchInfo}.json`;
                downloadFile(blob, fileName);
                hasUnsavedChanges = false;
                showSaveStatus("Progress saved to file", false);
            }

            function handleLoadProgressFromFile(e) {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const loadedState = JSON.parse(event.target.result);
                        if (!loadedState?.sohData?.length) throw new Error("Invalid or empty progress file.");
                        restoreState(loadedState);
                        showModal("Success", "Progress has been loaded.");
                    } catch(err) {
                        showModal("Error", "Could not parse the selected file. Please ensure it's a valid progress file.");
                    }
                };
                reader.readAsText(file);
                e.target.value = '';
            }
              function parseExcelFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const workbook = XLSX.read(e.target.result, { type: 'array' });
                            resolve(XLSX.utils.sheet_to_json(workbook.Sheets[workbook.SheetNames[0]]));
                        } catch (err) { reject(err); }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            }            function parseSalesExcelFile(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const workbook = XLSX.read(e.target.result, { 
                                type: 'array',
                                cellStyles: false,
                                cellNF: false,
                                cellDates: false
                            });
                            
                            const worksheet = workbook.Sheets[workbook.SheetNames[0]];
                            
                            // Step 1: Unmerge all cells by expanding merged cell values
                            // Get the range of the worksheet
                            const range = XLSX.utils.decode_range(worksheet['!ref'] || 'A1:A1');
                            
                            // Process merged cells if they exist
                            if (worksheet['!merges']) {
                                worksheet['!merges'].forEach(merge => {
                                    // Get the value from the top-left cell of the merged range
                                    const topLeftCell = XLSX.utils.encode_cell({r: merge.s.r, c: merge.s.c});
                                    const mergedValue = worksheet[topLeftCell] ? worksheet[topLeftCell].v : '';
                                    
                                    // Fill all cells in the merged range with the same value
                                    for (let row = merge.s.r; row <= merge.e.r; row++) {
                                        for (let col = merge.s.c; col <= merge.e.c; col++) {
                                            const cellAddr = XLSX.utils.encode_cell({r: row, c: col});
                                            if (!worksheet[cellAddr]) {
                                                worksheet[cellAddr] = { t: 's', v: mergedValue };
                                            }
                                        }
                                    }
                                });
                                // Remove merge information
                                delete worksheet['!merges'];
                            }
                            
                            // Step 2: Convert to JSON array (this gives us all rows)
                            const jsonData = XLSX.utils.sheet_to_json(worksheet, { 
                                header: 1, // Use array format instead of object format
                                defval: '', // Default value for empty cells
                                raw: false // Convert values to strings
                            });
                            
                            // Step 3: Remove top 5 rows
                            const dataAfterTopRemoval = jsonData.slice(5);
                            
                            // Step 4: Remove blank rows from bottom
                            // Find the last row that has meaningful content
                            let lastMeaningfulRowIndex = -1;
                            for (let i = dataAfterTopRemoval.length - 1; i >= 0; i--) {
                                const row = dataAfterTopRemoval[i];
                                if (row && row.some(cell => cell && String(cell).trim() !== '')) {
                                    lastMeaningfulRowIndex = i;
                                    break;
                                }
                            }
                            
                            // Trim the array to remove blank rows from bottom
                            const cleanedData = lastMeaningfulRowIndex >= 0 
                                ? dataAfterTopRemoval.slice(0, lastMeaningfulRowIndex + 1)
                                : [];
                            
                            resolve(cleanedData);
                        } catch (err) { 
                            reject(err); 
                        }
                    };
                    reader.onerror = reject;
                    reader.readAsArrayBuffer(file);
                });
            }

            function processAndSeparateSoh(sohData) {
                const forScan = [], forDemo = [], lookup = {};
                const targetWhCode = sohData.find(row => row.WH_CODE)?.WH_CODE;
                if (!targetWhCode) throw new Error("Could not determine warehouse code (WH_CODE).");                
                sohData.filter(row => row.WH_CODE === targetWhCode).forEach(row => {
                    // Extract basic info first
                    const desc = String(row.DESCRIPTION || '').toUpperCase();
                    const family = String(row.FAMILY || '').toUpperCase();
                    const originalSku = String(row.SKU || '').trim().toUpperCase();
                    
                    // DEMO detection logic - matches Excel conditions on ORIGINAL SKU column:
                    // 1. LEFT(SKU,1)="D" 
                    // 2. ISNUMBER(SEARCH("DEMO",SKU))
                    // 3. ISNUMBER(SEARCH("DEMO",Description))
                    // 4. Family="DEMO"
                    const isDemo = (
                        !originalSku.startsWith('DLCGZ') && (
                            originalSku.startsWith('D') ||           // Condition 1: First character is 'D'
                            originalSku.includes('DEMO') ||          // Condition 2: SKU contains "DEMO" anywhere
                            desc.includes('DEMO') ||                 // Condition 3: Description contains "DEMO"
                            family === 'DEMO'                       // Condition 4: Family equals "DEMO"
                        )
                    );
                    
                    // NOW do serial/SKU combination logic
                    const isSerial = !!row.SERIAL_NO;
                    const sku = String(isSerial ? row.SERIAL_NO : row.SKU || '').replace(/\./g, ' ').trim().toUpperCase();
                    if (!sku) return;
                    const isSerialControlled = row.SERIAL_CONTROL === 'Y' || isSerial;
                    const qty = parseInt(String(row.AVAILABLE_QTY ?? 0).replace(/,/g, ''), 10);                    
                    const srpRaw = row.SRP_AMT_INC_VAT;
                    const srp = srpRaw === null || srpRaw === undefined || srpRaw === '' ? 0 : parseFloat(String(srpRaw).replace(/,/g, ''));
                    if (lookup[sku] && !isSerialControlled) {
                        const existing = lookup[sku];
                        const newTotalQty = existing.SOH + qty;
                        const newTotalSrpValue = (existing.SOH * existing.Price) + (qty * srp);
                        existing.SOH = newTotalQty;
                        existing.Price = newTotalQty > 0 ? newTotalSrpValue / newTotalQty : 0;
                        // Update flags if any instance is DEMO
                        existing.isDemo = existing.isDemo || isDemo;
                    } else if (!lookup[sku]) {
                        lookup[sku] = {
                            SKU: sku,
                            Description: (row.DESCRIPTION || '').replace(/,/g, ' '),
                            SOH: qty,
                            Price: srp,
                            Age: row.AGE,
                            CLASS_NAME: row.CLASS_NAME || 'UNCATEGORIZED',
                            FAMILY: row.FAMILY || '',
                            isSerialControlled,
                            isDemo
                        };
                    }
                });
                Object.values(lookup).forEach(item => {
                    if (item.SOH > 0) (item.isDemo ? forDemo : forScan).push(item);
                });
                return { forScan, forDemo, lookup };
            }            function restoreState(loadedState) {
                resetAppState();
                state = { ...state, ...loadedState, charts: getInitialState().charts };
                
                // Handle SOH updated SKUs - convert array back to Set if needed
                if (loadedState.sohUpdatedSkus) {
                    if (Array.isArray(loadedState.sohUpdatedSkus)) {
                        state.sohUpdatedSkus = new Set(loadedState.sohUpdatedSkus);
                    } else if (loadedState.sohUpdatedSkus instanceof Set) {
                        state.sohUpdatedSkus = loadedState.sohUpdatedSkus;
                    }
                } else {
                    state.sohUpdatedSkus = new Set();
                }
                
                const { forScan, forDemo, lookup } = processAndSeparateSoh(state.sohData);
                state.sohLookup = lookup;
                state.scannerMaster = forScan;                state.demoMaster = forDemo.map(item => ({ 
                    ...item, 
                    counted: state.demoCounts[item.SKU]?.qty ?? null,
                    reason: state.demoCounts[item.SKU]?.reason ?? 'DEMO-Manual' 
                }));
                rebuildUiFromState();
            }

            function downloadFile(content, fileName) {
                const blob = (typeof content === 'string') ? new Blob([content], { type: 'text/csv;charset=utf-8;' }) : content;
                const link = document.createElement("a");
                link.href = URL.createObjectURL(blob);
                link.download = fileName;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }
            
            function rebuildUiFromState() {
                if (state.sohData.length > 0) {
                    getEl('workspace-container').classList.remove('hidden');
                    getEl('upload-container').classList.add('hidden');
                    getEl('downloadMasterForScan').disabled = false;
                    updateInfoBox();
                    applyDemoView();
                    if (state.netDiffData.length > 0) {
                        renderFirstCountSummary();
                        getEl('step2-results').classList.remove('hidden');
                        getEl('finalizeFromFirstCount').disabled = false;
                        getEl('generateRecountMasterFile').disabled = false;
                        getEl('latestSohFile').disabled = false;
                    }
                    if (state.reconciledData.length > 0) {
                        applyFinalReportView();
                        renderFinalReportCharts();
                        getEl('final-report-container').classList.remove('hidden');
                    }
                    switchMainTab('demo');
                } else {
                    resetUI();
                }
            }
            
            function switchMainTab(tabName) {
                const isDemo = tabName === 'demo';
                getEl('main-panel-demo').classList.toggle('hidden', !isDemo);
                getEl('main-panel-workflow').classList.toggle('hidden', isDemo);
                getEl('main-tab-demo').classList.toggle('active', isDemo);
                getEl('main-tab-workflow').classList.toggle('active', !isDemo);
            }

            function changeWorkflowTab(tabIndex) {
                document.querySelectorAll('.workflow-step').forEach(div => div.classList.add('hidden'));
                getEl(`wf-step${tabIndex}`).classList.remove('hidden');
                document.querySelectorAll('#wf-step-tabs .tab-button').forEach(btn => btn.classList.remove('active'));
                getEl(`wf-tab-btn-${tabIndex}`).classList.add('active');
            }

            function handleSort(sortKey, column, applyViewFn) {
                const sortState = state[sortKey];
                if (sortState.column === column) {
                    sortState.direction = sortState.direction === 'asc' ? 'desc' : 'asc';
                } else {
                    sortState.column = column;
                    sortState.direction = 'asc';
                }
                applyViewFn();
                setUnsavedChanges(true);
            }

            function getDiffColorClass(diff) {
                if (diff < 0) return 'text-red-600 font-bold';
                if (diff > 0) return 'text-yellow-500 font-bold';
                return 'text-green-600 font-bold';
            }            
            function applyDemoView() {
                if (state.demoMaster.length === 0) {
                    getEl('demo-count-container').innerHTML = '<p class="p-6 text-center text-slate-500">No DEMO items found.</p>';
                    updateDemoSummary();
                    return;
                }
                const searchValue = getEl('demoSearchInput').value.toUpperCase();
                const filterValue = getEl('demoFilterSelect').value;
                let dataView = state.demoMaster.filter(item => {
                    if (!(item.SKU.toUpperCase().includes(searchValue) || item.Description.toUpperCase().includes(searchValue))) return false;
                    const diff = (item.counted === null) ? null : item.counted - item.SOH;
                    if (filterValue === 'uncounted') return item.counted === null;
                    if (filterValue === 'discrepancy') return diff !== null && diff !== 0;
                    if (filterValue === 'matched') return diff !== null && diff === 0;
                    return true;
                });
                const { column, direction } = state.demoSort;
                dataView.sort((a, b) => {
                    let valA, valB;
                    
                    // Handle special calculated field "diff"
                    if (column === 'diff') {
                        valA = (a.counted === null) ? null : a.counted - a.SOH;
                        valB = (b.counted === null) ? null : b.counted - b.SOH;
                    } else if (column === 'counted') {
                        valA = a.counted;
                        valB = b.counted;
                    } else {
                        valA = a[column];
                        valB = b[column];
                    }
                    
                    // Handle null/undefined values
                    if (valA === null || valA === undefined) return 1;
                    if (valB === null || valB === undefined) return -1;
                    
                    // Sort by data type
                    if (typeof valA === 'string') {
                        return direction === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                    }
                    return direction === 'asc' ? valA - valB : valB - valA;
                });
                renderDemoCountTable(dataView);
                updateDemoSummary();
            }            
            function renderDemoCountTable(data) {
                const container = getEl('demo-count-container');
                // Responsive table styling
                const headers = `<thead><tr>
                    <th class="p-3 text-center w-12">NO.</th>
                    <th class="p-3 text-left" data-sort-by="SKU">SKU<span class="sort-indicator"></span></th>
                    <th class="p-3 text-left" data-sort-by="Description">Description<span class="sort-indicator"></span></th>
                    <th class="p-3 text-center" data-sort-by="Price">SRP<span class="sort-indicator"></span></th>
                    <th class="p-3 text-center" data-sort-by="Age">Age<span class="sort-indicator"></span></th>
                    <th class="p-3 text-center" data-sort-by="SOH">SOH<span class="sort-indicator"></span></th>
                    <th class="p-3 text-center" data-sort-by="counted">Counted<span class="sort-indicator"></span></th>
                    <th class="p-3 text-center" data-sort-by="diff">Diff<span class="sort-indicator"></span></th>
                    <th class="p-3 text-center" data-sort-by="remark">Remark<span class="sort-indicator"></span></th>
                </tr></thead>`;
                const body = data.length > 0 ? data.map((item, idx) => renderDemoTableRow(item, idx)).join('') : `<tr><td colspan="9" class="text-center p-6 text-slate-500">No items match filter.</td></tr>`;
                container.innerHTML = `<table class="w-full text-sm">${headers}<tbody>${body}</tbody></table>`;
                
                // Update sort indicators with colors
                const sortingTh = container.querySelector(`th[data-sort-by="${state.demoSort.column}"]`);
                if (sortingTh) {
                    const indicator = sortingTh.querySelector('.sort-indicator');
                    indicator.textContent = state.demoSort.direction === 'asc' ? '▲' : '▼';
                    // Add color: green for ascending, red for descending
                    indicator.style.color = state.demoSort.direction === 'asc' ? '#22c55e' : '#ef4444';
                }
            }

            function renderDemoTableRow(item, idx) {
                const diff = (item.counted === null) ? null : item.counted - item.SOH;
                const diffText = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
                let { rowClass } = getRowVisuals(diff, true);
                return `<tr class="border-b border-slate-200 transition-colors duration-200 ${rowClass}" data-sku="${item.SKU}">
                    <td class="p-3 text-center">${idx + 1}</td>
                    <td class="p-3 font-medium text-slate-700">${item.SKU}</td>
                    <td class="p-3 text-slate-600">${item.Description}</td>
                    <td class="p-3 text-center text-slate-600">${item.Price ?? 0}</td>
                    <td class="p-3 text-center text-slate-600">${item.Age || 'N/A'}</td>
                    <td class="p-3 text-center text-slate-600">${item.SOH}</td>
                    <td class="p-3 text-center text-slate-600"><input type="number" value="${item.counted ?? ''}" class="w-full text-center p-1.5 border border-slate-300 rounded-md bg-white"/></td>
                    <td class="p-3 text-center font-bold diff-cell ${getDiffColorClass(diff)}">${diffText}</td>
                    <td class="p-3 text-center"><input type="text" value="${item.remark ?? ''}" class="w-full text-center p-1.5 border border-slate-300 rounded-md bg-white"/></td>
                </tr>`;
            }

            function updateDemoSummary() {
                const totalSOH = state.demoMaster.reduce((sum, item) => sum + item.SOH, 0);
                const totalSOHPrice = state.demoMaster.reduce((sum, item) => sum + (item.SOH * (item.Price ?? 0)), 0);
                const countedSKUs = Object.values(state.demoCounts).filter(c => c.qty !== null).length;
                const countedSOHValue = state.demoMaster.reduce((sum, item) => {
                    const counted = state.demoCounts[item.SKU]?.qty;
                    return sum + ((counted ?? 0) * (item.Price ?? 0));
                }, 0);
                const countedSOH = state.demoMaster.reduce((sum, item) => {
                    const counted = state.demoCounts[item.SKU]?.qty;
                    return sum + (counted ?? 0);
                }, 0);
                const diffItems = state.demoMaster.filter(item => { const countInfo = state.demoCounts[item.SKU]; return countInfo && countInfo.qty !== null && countInfo.qty !== item.SOH; }).length;
                getEl('demo-summary').innerHTML = `
                    <div class="flex justify-between gap-4"><span>Total DEMO SOH:</span><span class="font-bold">${formatNumber(totalSOH)}</span></div>
                    <div class="flex justify-between gap-4"><span>Total DEMO SOH Value:</span><span class="font-bold text-blue-600">${formatNumber(totalSOHPrice)}</span></div>
                    <div class="flex justify-between gap-4"><span>Counted DEMO SOH:</span><span class="font-bold text-green-600">${formatNumber(countedSOH)}</span></div>
                    <div class="flex justify-between gap-4"><span>Counted DEMO SOH Value:</span><span class="font-bold text-green-600">${formatNumber(countedSOHValue)}</span></div>
                    <div class="flex justify-between gap-4"><span>Total DEMO SKUs:</span><span class="font-bold">${formatNumber(state.demoMaster.length)}</span></div>
                    <div class="flex justify-between gap-4"><span>Counted SKUs:</span><span class="font-bold text-green-600">${countedSKUs}</span></div>
                    <div class="flex justify-between gap-4"><span>Discrepancies:</span><span class="font-bold text-red-600">${diffItems}</span></div>
                `;
            }

            function updateDemoCount(sku, value) {
                const item = state.demoMaster.find(i => i.SKU === sku);
                if (!item) return;
                const intValue = value === '' ? null : parseInt(value, 10);
                item.counted = isNaN(intValue) ? null : intValue;                if (intValue === null) delete state.demoCounts[sku];
                else state.demoCounts[sku] = { qty: intValue, reason: 'DEMO-Manual' };
                if (state.reconciledData.length > 0) {
                    const reportItem = state.reconciledData.find(i => i.SKU === sku);
                    if (reportItem) {
                        const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(sku);
                        reportItem.Recount = intValue ?? 0;
                        reportItem.FinalDiff = reportItem.Recount - reportItem.SOH;
                        reportItem.ReasonFinal = wasSohUpdated ? 'SOHupdated-DEMO-Manual' : 'DEMO-Manual';
                        applyFinalReportView();
                        renderFinalReportCharts();
                    }
                }
                const row = getEl('demo-count-container').querySelector(`tr[data-sku="${sku}"]`);
                if (row) {
                    const diff = item.counted === null ? null : item.counted - item.SOH;
                    row.querySelector('.diff-cell').textContent = diff === null ? '-' : (diff > 0 ? `+${diff}` : diff);
                    row.querySelector('.diff-cell').className = `p-3 text-center font-bold diff-cell ${getDiffColorClass(diff)}`;
                    updateTableRowVisuals(row, diff, true);
                }
                updateDemoSummary();
                updateFinalReportSummary();
                setUnsavedChanges(true);
            }
              function exportDemoTable() {
                const dataToExport = state.demoMaster.map((item, idx) => ({ 
                    NO: idx + 1, 
                    SKU: item.SKU, 
                    Description: item.Description, 
                    SRP: item.Price, 
                    Age: item.Age, 
                    SOH: item.SOH, 
                    Counted: item.counted, 
                    Diff: item.counted === null ? '' : item.counted - item.SOH,
                    Flag: item.isDemo ? 'DEMO' : 'NONE'
                }));
                const csv = Papa.unparse(dataToExport, { header: true });
                const branchInfo = state.branchCode ? `${state.branchCode}_${state.branchName.replace(/\s+/g, '_')}` : state.branchName.replace(/\s+/g, '_');
                downloadFile(csv, `${state.countDate}_DEMO_Count_${branchInfo}.csv`);
            }
            function downloadMasterForScan() {
                // Exclude DEMO items using processed flags
                const scanRows = Object.values(state.sohLookup).filter(item => !item.isDemo && item.SOH > 0);
                const rowsForCsv = scanRows.map(item => [item.SKU, item.Description, item.Price, item.Age, item.SOH]);
                
                // Use new file naming convention: Master_branchcode_date.csv
                const branchInfo = state.branchCode ? `${state.branchCode}_${state.countDate}` : `${state.branchName.replace(/\s+/g, '_')}_${state.countDate}`;
                const fileName = `Master_${branchInfo}.csv`;
                downloadFile(Papa.unparse(rowsForCsv, { header: false }), fileName);
            }
            
            async function processFirstCount() {
                showLoader('Processing First Count...');
                try {
                    const logFiles = getEl('firstScanLogfile').files;
                    const masterFile = getEl('firstMasterFile').files[0];
                    
                    if (!logFiles.length && !masterFile) {
                        throw new Error("Please upload at least one file (Logfile or Master.csv) for the first count.");
                    }
                    
                    if (!state.sohData.length) {
                        throw new Error("Please upload SOH data first.");
                    }
                    
                    let scanCounts = [];
                    
                    // Process Logfile(s) if uploaded
                    if (logFiles.length > 0) {
                        const logfileData = await (async function(files){ 
                            const p = Array.from(files).map(f => new Promise((res, rej) => { 
                                Papa.parse(f, { 
                                    skipEmptyLines: true, 
                                    complete: r => { 
                                        const d = r.data.map(row => { 
                                            if(!row || row.length < 3 || !row[2]) return null; 
                                            const sku = String(row[2]).trim(); 
                                            const qty = parseInt(String(row[4] ?? 1).replace(/,/g,''), 10); 
                                            return {sku, qty: isNaN(qty) ? 1: qty};
                                        }).filter(Boolean); 
                                        res(d); 
                                    }, 
                                    error: rej
                                }); 
                            })); 
                            return Promise.all(p).then(r => r.flat()); 
                        })(logFiles);
                        scanCounts = scanCounts.concat(logfileData);
                    }
                    
                    // Process Master.csv if uploaded
                    if (masterFile) {
                        const masterData = await new Promise((resolve, reject) => {
                            Papa.parse(masterFile, {
                                skipEmptyLines: true,
                                complete: result => {
                                    try {
                                        const data = result.data.map(row => {
                                            if (!row || row.length < 6 || !row[0]) return null;
                                            const sku = String(row[0]).trim(); // Column 1: Part No.
                                            const qty = parseInt(String(row[5] || '0').replace(/,/g, ''), 10); // Column 6: Actual Qty
                                            // Only include items that were actually counted (qty > 0)
                                            if (isNaN(qty) || qty <= 0) return null;
                                            return { sku, qty };
                                        }).filter(Boolean);
                                        resolve(data);
                                    } catch (error) {
                                        reject(error);
                                    }
                                },
                                error: reject
                            });
                        });
                        scanCounts = scanCounts.concat(masterData);
                    }                    const processedCounts = {};
                    for(const item of scanCounts){ 
                        const {sku, qty} = item; 
                        const isSerial = state.sohLookup[sku] ? state.sohLookup[sku].isSerialControlled : false; 
                        if(isSerial){ 
                            if(!processedCounts[sku]) processedCounts[sku] = {qty: 1, reason: 'Scan'};
                        } else { 
                            const currentQty = processedCounts[sku] ? processedCounts[sku].qty : 0; 
                            processedCounts[sku] = {qty: currentQty + qty, reason: 'Scan'};
                        }
                    }
                    const combinedCounts = { ...processedCounts, ...state.demoCounts };
                    const netDiffMap = new Map(Object.values(state.sohLookup).filter(item => item.SOH > 0).map(item => [item.SKU, { ...item, Scan1: 0, Reason1: '' }]));
                    for (const [sku, data] of Object.entries(combinedCounts)) {
                        const entry = netDiffMap.get(sku);
                        if (entry) { entry.Scan1 = data.qty; entry.Reason1 = data.reason; }
                    }                    state.netDiffData = Array.from(netDiffMap.values()).map(item => {
                        // Check if this item already has sales data in reconciledData
                        const existingReconciledItem = state.reconciledData.find(r => r.SKU === item.SKU);
                        const hasSalesData = existingReconciledItem && 
                            existingReconciledItem.ReasonFinal && 
                            existingReconciledItem.ReasonFinal.includes('Sales:');
                        
                        if (hasSalesData) {
                            // Preserve sales data and add first count on top
                            const salesMatch = existingReconciledItem.ReasonFinal.match(/Sales: (\d+) units added/);
                            const salesQty = salesMatch ? parseInt(salesMatch[1], 10) : 0;
                            
                            return {
                                ...item, 
                                Counted1: item.Scan1,
                                Diff1: item.Scan1 - item.SOH, 
                                Recount: item.Scan1 + salesQty, 
                                FinalDiff: (item.Scan1 + salesQty) - item.SOH, 
                                ReasonFinal: item.Reason1 ? `${item.Reason1} + ${existingReconciledItem.ReasonFinal}` : existingReconciledItem.ReasonFinal, 
                                Remark: existingReconciledItem.Remark || ''
                            };
                        } else {
                            // Normal processing without existing sales data
                            return {
                                ...item, 
                                Counted1: item.Scan1,
                                Diff1: item.Scan1 - item.SOH, 
                                Recount: item.Scan1, 
                                FinalDiff: item.Scan1 - item.SOH, 
                                ReasonFinal: item.Reason1, 
                                Remark: '' 
                            };
                        }
                    });
                    renderFirstCountSummary();
                    getEl('step2-results').classList.remove('hidden');
                    getEl('finalizeFromFirstCount').disabled = false;
                    getEl('generateRecountMasterFile').disabled = false;
                    getEl('latestSohFile').disabled = false;
                    setUnsavedChanges(true);
                    
                    // Generate success message showing what files were processed
                    let processedFiles = [];
                    if (logFiles.length > 0) processedFiles.push(`${logFiles.length} Logfile(s)`);
                    if (masterFile) processedFiles.push('Master.csv');
                    const message = `First count processed successfully using: ${processedFiles.join(' and ')}.`;
                    
                    showModal("Success", message);
                } catch (error) {
                    showModal("Error", `Processing failed: ${error.message}`);
                } finally {
                    hideLoader();
                }
            }
            
            function renderFirstCountSummary() {
                const summary = state.netDiffData.reduce((acc, item) => { acc.totalSOH += item.SOH; if (item.Scan1 !== 0 || item.Reason1) acc.countedSOH += item.SOH; return acc; }, { totalSOH: 0, countedSOH: 0 });
                const uncountedSOH = summary.totalSOH - summary.countedSOH;
                getEl('netdiff-summary-container').innerHTML = `<div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center"><div class="p-4 bg-blue-100 rounded-lg"><p class="font-medium text-blue-800">Total SOH</p><p class="text-3xl font-bold text-blue-600 mt-1">${formatNumber(summary.totalSOH)}</p></div><div class="p-4 bg-green-100 rounded-lg"><p class="font-medium text-green-800">Counted SOH</p><p class="text-3xl font-bold text-green-600 mt-1">${formatNumber(summary.countedSOH)}</p></div><div class="p-4 bg-red-100 rounded-lg"><p class="font-medium text-red-800">Uncounted SOH</p><p class="text-3xl font-bold text-red-600 mt-1">${formatNumber(uncountedSOH)}</p></div></div>`;
            }            
            function finalizeFromFirstCount() {
                if (!state.netDiffData.length) return showModal("Warning", "Please process the first count (Step 2).");
                // --- Patch: Sync latest DEMO counts before finalizing ---
                state.netDiffData.forEach(item => {
                    if (item.isDemo) {
                        // Check if item has been manually edited in final table
                        const existingReconciledItem = state.reconciledData.find(r => r.SKU === item.SKU);
                        const hasManualEdit = existingReconciledItem && existingReconciledItem.ReasonFinal === 'Manual Edit';
                        
                        if (hasManualEdit) {
                            // Skip updating - preserve manual edit
                            return;
                        }                        
                        const demoCount = state.demoCounts[item.SKU];
                        const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(item.SKU);                        if (demoCount && typeof demoCount.qty === 'number') {
                            item.Recount = demoCount.qty;
                            item.FinalDiff = demoCount.qty - item.SOH;
                            const baseReason = demoCount.reason || 'DEMO-Manual';
                            item.ReasonFinal = wasSohUpdated ? `SOHupdated-${baseReason}` : baseReason;                        } else {
                            item.Recount = 0;
                            item.FinalDiff = -item.SOH;
                            item.ReasonFinal = wasSohUpdated ? 'SOHupdated-DEMO-N/A' : 'DEMO-N/A';
                        }
                    }
                });
                state.reconciledData = state.netDiffData.map(item => {
                    // Check if item already has sales data in reconciledData
                    const existingReconciledItem = state.reconciledData.find(r => r.SKU === item.SKU);
                    const hasSalesData = existingReconciledItem && 
                        existingReconciledItem.ReasonFinal && 
                        existingReconciledItem.ReasonFinal.includes('Sales:');
                    
                    if (hasSalesData) {
                        // Preserve sales data from existing reconciledData
                        return {
                            ...item,
                            Recount: existingReconciledItem.Recount,
                            FinalDiff: existingReconciledItem.FinalDiff,
                            ReasonFinal: item.ReasonFinal ? `${item.ReasonFinal} + ${existingReconciledItem.ReasonFinal}` : existingReconciledItem.ReasonFinal,
                            Remark: existingReconciledItem.Remark || ''
                        };
                    } else {
                        // No existing sales data - use item as is
                        return {...item};
                    }
                });
                applyFinalReportView();
                renderFinalReportCharts();
                getEl('final-report-container').classList.remove('hidden');
                getEl('final-report-container').scrollIntoView({ behavior: 'smooth' });
                setUnsavedChanges(true);
            }            async function processSalesData() {
                showLoader('Processing Sales Data...');
                try {
                    const salesFile = getEl('salesDataFile').files[0];
                    if (!salesFile) throw new Error("Please select a sales data file.");

                    const salesData = await parseSalesExcelFile(salesFile);
                    if (!salesData?.length) throw new Error("Sales data file is empty or invalid after processing.");                    // Filter out completely empty rows (already cleaned by parseSalesExcelFile)
                    const cleanedData = salesData.filter(row => {
                        // Row is now an array, check if it has meaningful data
                        return Array.isArray(row) && row.some(cell => cell && String(cell).trim() !== '');
                    });

                    if (!cleanedData.length) throw new Error("No valid sales data found after cleaning.");

                    // Process sales data - extract relevant columns
                    const processedSales = [];
                    const salesMap = new Map(); // For aggregating by SKU
                      cleanedData.forEach((row, index) => {
                        try {
                            // Row is now an array, access columns directly by index (0-based)
                            const serial = row[53] || null; // Column 54 (Serial) -> index 53
                            const productName = row[19] || null; // Column 20 (Product Name) -> index 19
                            const qty = row[26] || null; // Column 27 (QTY) -> index 26
                            const billNo = row[9] || null; // Column 10 (Bill No) -> index 9

                            if (serial && qty && !isNaN(parseFloat(qty))) {
                                // Apply the same SKU transformation as SOH processing
                                const sku = String(serial).replace(/\./g, ' ').trim().toUpperCase();
                                const quantity = Math.abs(parseFloat(qty)); // Use absolute value
                                const product = String(productName || '').trim();
                                const bill = String(billNo || '').trim();

                                // Use enhanced matching to find the item in sohLookup
                                const allSohItems = Object.values(state.sohLookup);
                                const matchedItem = findItemByScannedText(allSohItems, sku);
                                
                                // Use the matched SKU if found, otherwise use the original
                                const finalSku = matchedItem ? matchedItem.SKU : sku;

                                if (salesMap.has(finalSku)) {
                                    const existing = salesMap.get(finalSku);
                                    existing.totalQty += quantity;
                                    existing.bills.push(bill);
                                } else {
                                    salesMap.set(finalSku, {
                                        sku: finalSku,
                                        productName: product,
                                        totalQty: quantity,
                                        bills: [bill],
                                        originalSerial: sku, // Keep track of original for debugging
                                        matched: !!matchedItem
                                    });
                                }
                            }
                        } catch (rowError) {
                            // Skip problematic rows silently
                        }
                    });

                    const salesSummary = Array.from(salesMap.values());

                    // Calculate matching statistics for debugging
                    const matchedCount = salesSummary.filter(sale => sale.matched).length;
                    const unmatchedCount = salesSummary.length - matchedCount;                    // Apply sales data to tracking - simplified approach
                    let adjustedItems = 0;
                    if (state.sohLookup && Object.keys(state.sohLookup).length > 0) {
                        salesSummary.forEach(sale => {
                            if (state.sohLookup[sale.sku]) {
                                adjustedItems++;
                                // Note: We no longer track SalesDuringCount in sohLookup 
                                // as sales are directly added to final count in the processing above
                            }
                        });                          // Update netDiffData if it exists - enhanced sales integration with new conditions
                        if (state.netDiffData.length > 0) {
                            state.netDiffData.forEach(item => {
                                const sale = salesSummary.find(s => s.sku === item.SKU);
                                if (sale) {
                                    const billNumbers = sale.bills.filter(bill => bill.trim() !== '').join(', ');
                                      // Check if this item already has any count (manual, first count, or recount)
                                    const hasExistingCount = (
                                        // Has been manually counted
                                        (item.ReasonFinal && (item.ReasonFinal.includes('Manual') || item.ReasonFinal.includes('Re-Scan') || item.ReasonFinal.includes('Scan'))) ||
                                        // Has been counted in first count (Scan1 > 0 or has Reason1)
                                        (item.Scan1 > 0 || (item.Reason1 && item.Reason1.trim() !== '')) ||
                                        // Has been recounted (Recount different from initial and not due to previous sales)
                                        (item.Recount !== item.Scan1 && !item.ReasonFinal?.includes('Sales:')) ||
                                        // Has any counting reason that's not sales-related (excluding uncounted items)
                                        (item.ReasonFinal && !item.ReasonFinal.includes('Sales:') && item.ReasonFinal.trim() !== '' && item.ReasonFinal !== 'DEMO-N/A' && !item.ReasonFinal.includes('N/A'))
                                    );
                                    
                                    if (hasExistingCount) {
                                        // Skip updating count, only add "sold now" to remark
                                        const soldNowText = `Sold now: ${billNumbers}`;
                                        if (item.Remark && item.Remark.trim() !== '') {
                                            // Remove any previous "sold now" entries before adding new one
                                            item.Remark = item.Remark.replace(/\s*\|\s*Sold now:[^|]*/g, '');
                                            item.Remark += ` | ${soldNowText}`;
                                        } else {
                                            item.Remark = soldNowText;
                                        }
                                    } else {
                                        // Check if this is a re-processing of sales data (overwrite mode)
                                        const hasPreviousSales = item.ReasonFinal && item.ReasonFinal.includes('Sales:');
                                        
                                        if (hasPreviousSales) {
                                            // Overwrite previous sales data instead of adding up
                                            // First, remove previous sales count addition
                                            const previousSalesMatch = item.ReasonFinal.match(/Sales: (\d+) units added/);
                                            if (previousSalesMatch) {
                                                const previousSalesQty = parseInt(previousSalesMatch[1], 10);
                                                item.Recount = Math.max(0, item.Recount - previousSalesQty);
                                            }
                                            
                                            // Remove previous sales bill numbers from remarks
                                            if (item.Remark) {
                                                item.Remark = item.Remark.replace(/\s*\|\s*Bills:[^|]*/g, '');
                                                item.Remark = item.Remark.replace(/^Bills:[^|]*\s*\|\s*/, '');
                                                item.Remark = item.Remark.replace(/^Bills:[^|]*$/, '');
                                            }
                                        }
                                          // Apply new sales data
                                        item.Recount = (item.Recount || 0) + sale.totalQty;
                                        item.FinalDiff = item.Recount - item.SOH;
                                        
                                        // Update reason to indicate sales during count with SOH tracking
                                        const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(item.SKU);
                                        const salesReason = `Sales: ${sale.totalQty} units added`;
                                        item.ReasonFinal = wasSohUpdated ? `SOHupdated-${salesReason}` : salesReason;
                                        
                                        // Add bill numbers to remarks
                                        if (billNumbers) {
                                            if (item.Remark && item.Remark.trim() !== '') {
                                                item.Remark += ` | Bills: ${billNumbers}`;
                                            } else {
                                                item.Remark = `Bills: ${billNumbers}`;
                                            }
                                        }
                                    }
                                }
                            });                        
                        }                        // Update reconciledData if it exists - enhanced sales integration with same conditions
                        if (state.reconciledData.length > 0) {
                            state.reconciledData.forEach(item => {
                                const sale = salesSummary.find(s => s.sku === item.SKU);
                                if (sale) {
                                    const billNumbers = sale.bills.filter(bill => bill.trim() !== '').join(', ');
                                    
                                    // Check if this item already has any count (manual, first count, or recount)
                                    const hasExistingCount = (
                                        // Has been manually counted
                                        (item.ReasonFinal && (item.ReasonFinal.includes('Manual') || item.ReasonFinal.includes('Re-Scan') || item.ReasonFinal.includes('Scan'))) ||
                                        // Has been counted in first count (Scan1 > 0 or has Reason1)
                                        (item.Scan1 > 0 || (item.Reason1 && item.Reason1.trim() !== '')) ||
                                        // Has been recounted (Recount different from initial and not due to previous sales)
                                        (item.Recount !== item.Scan1 && !item.ReasonFinal?.includes('Sales:')) ||
                                        // Has any counting reason that's not sales-related (excluding uncounted items)
                                        (item.ReasonFinal && !item.ReasonFinal.includes('Sales:') && item.ReasonFinal.trim() !== '' && item.ReasonFinal !== 'DEMO-N/A' && !item.ReasonFinal.includes('N/A'))
                                    );
                                    
                                    if (hasExistingCount) {
                                        // Skip updating count, only add "sold now" to remark
                                        const soldNowText = `Sold now: ${billNumbers}`;
                                        if (item.Remark && item.Remark.trim() !== '') {
                                            // Remove any previous "sold now" entries before adding new one
                                            item.Remark = item.Remark.replace(/\s*\|\s*Sold now:[^|]*/g, '');
                                            item.Remark += ` | ${soldNowText}`;
                                        } else {
                                            item.Remark = soldNowText;
                                        }
                                    } else {
                                        // Check if this is a re-processing of sales data (overwrite mode)
                                        const hasPreviousSales = item.ReasonFinal && item.ReasonFinal.includes('Sales:');
                                        
                                        if (hasPreviousSales) {
                                            // Overwrite previous sales data instead of adding up
                                            // First, remove previous sales count addition
                                            const previousSalesMatch = item.ReasonFinal.match(/Sales: (\d+) units added/);
                                            if (previousSalesMatch) {
                                                const previousSalesQty = parseInt(previousSalesMatch[1], 10);
                                                item.Recount = Math.max(0, item.Recount - previousSalesQty);
                                            }
                                            
                                            // Remove previous sales bill numbers from remarks
                                            if (item.Remark) {
                                                item.Remark = item.Remark.replace(/\s*\|\s*Bills:[^|]*/g, '');
                                                item.Remark = item.Remark.replace(/^Bills:[^|]*\s*\|\s*/, '');
                                                item.Remark = item.Remark.replace(/^Bills:[^|]*$/, '');
                                            }
                                        }
                                          // Add sales count directly to final count (not reducing SOH)
                                        item.Recount = (item.Recount || 0) + sale.totalQty;
                                        item.FinalDiff = item.Recount - item.SOH;
                                          // Update reason to indicate sales during count with SOH tracking
                                        const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(item.SKU);
                                        const salesReason = `Sales: ${sale.totalQty} units added`;
                                        item.ReasonFinal = wasSohUpdated ? `SOHupdated-${salesReason}` : salesReason;
                                        
                                        // Add bill numbers to remarks
                                        if (billNumbers) {
                                            if (item.Remark && item.Remark.trim() !== '') {
                                                item.Remark += ` | Bills: ${billNumbers}`;
                                            } else {
                                                item.Remark = `Bills: ${billNumbers}`;
                                            }
                                        }
                                    }
                                }
                            });
                            applyFinalReportView();
                            renderFinalReportCharts();
                        }
                    }                    
                    // Display results
                    const resultsEl = getEl('sales-processing-results');
                    
                    // Create matched sales table
                    const matchedSales = salesSummary.filter(sale => sale.matched);
                    const matchedSalesTable = matchedSales.length > 0 ? `
                        <div class="mt-4">
                            <h5 class="font-medium text-slate-700 mb-2">📋 Matched Sales Records</h5>
                            <div class="max-h-64 overflow-y-auto border border-slate-200 rounded-lg">
                                <table class="w-full text-xs">
                                    <thead class="bg-slate-50 sticky top-0">
                                        <tr>
                                            <th class="p-2 text-left font-medium text-slate-600">SKU</th>
                                            <th class="p-2 text-center font-medium text-slate-600">Qty</th>
                                            <th class="p-2 text-left font-medium text-slate-600">Bill Numbers</th>
                                        </tr>
                                    </thead>
                                    <tbody>
                                        ${matchedSales.map(sale => `
                                            <tr class="border-b border-slate-100 hover:bg-slate-50">
                                                <td class="p-2 font-mono text-slate-700">${sale.sku}</td>
                                                <td class="p-2 text-center text-orange-600 font-medium">${sale.totalQty}</td>
                                                <td class="p-2 text-slate-600 text-xs">${sale.bills.filter(bill => bill.trim() !== '').join(', ') || 'N/A'}</td>
                                            </tr>
                                        `).join('')}
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    ` : '';
                    
                    resultsEl.innerHTML = `
                        <div class="space-y-2">
                            <div class="flex justify-between">
                                <span>📊 Total Sales Records:</span>
                                <span class="font-bold text-blue-600">${salesSummary.length}</span>
                            </div>
                            <div class="flex justify-between">
                                <span>✅ SKUs Matched:</span>
                                <span class="font-bold text-green-600">${matchedCount}</span>
                            </div>
                            <div class="flex justify-between">
                                <span>❌ SKUs Not Matched:</span>
                                <span class="font-bold text-orange-600">${unmatchedCount}</span>
                            </div>
                            <div class="flex justify-between">
                                <span>🔄 Items with Sales Data:</span>
                                <span class="font-bold text-green-600">${adjustedItems}</span>
                            </div>
                            ${matchedSalesTable}
                            ${unmatchedCount > 0 ? `
                            <div class="mt-3 text-xs text-slate-600">
                                <details class="cursor-pointer">
                                    <summary class="font-medium text-orange-600">Debug: Unmatched SKUs (Top 5)</summary>
                                    <div class="mt-2 space-y-1 max-h-32 overflow-y-auto">
                                        ${salesSummary.filter(sale => !sale.matched).slice(0, 5).map(sale => 
                                            `<div class="text-xs text-orange-600">
                                                <div>Original: "${sale.originalSerial}"</div>
                                                <div>Processed: "${sale.sku}"</div>
                                                <div class="text-slate-400 mb-1">---</div>
                                            </div>`
                                        ).join('')}
                                    </div>
                                </details>
                            </div>
                            ` : ''}
                        </div>
                    `;
                    resultsEl.classList.remove('hidden');

                    setUnsavedChanges(true);
                    showModal("Success", `Sales data processed successfully. ${adjustedItems} items now have sales tracking data and bill number references added to remarks.`);
                } catch (error) {
                    showModal("Error", `Sales data processing failed: ${error.message}`);
                } finally {
                    hideLoader();
                }
            }
              function generateRecountMasterFile() {
                // Include items that need recounting:
                // 1. Items with discrepancies (Diff1 !== 0)
                // 2. Items that were never counted (Scan1 === 0 && !Reason1)
                // 3. Exclude DEMO items (!isDemo)
                const itemsToRecount = state.netDiffData.filter(item => 
                    !item.isDemo && (item.Diff1 !== 0 || (item.Scan1 === 0 && !item.Reason1))
                );
                
                if (!itemsToRecount.length) {
                    return showModal("Info", "No non-DEMO items require a recount.");
                }
                
                // Show preview of what will be included
                const discrepancyCount = itemsToRecount.filter(item => item.Diff1 !== 0).length;
                const uncountedCount = itemsToRecount.filter(item => item.Scan1 === 0 && !item.Reason1).length;
                const totalSOH = itemsToRecount.reduce((sum, item) => sum + item.SOH, 0);
                
                const previewMessage = `
                    <div class="text-left">
                        <p class="mb-2"><strong>Items to be included in recount:</strong></p>
                        <ul class="list-disc pl-5 space-y-1">
                            <li>Items with discrepancies: <span class="font-medium text-blue-600">${discrepancyCount}</span></li>
                            <li>Items not counted: <span class="font-medium text-red-600">${uncountedCount}</span></li>
                            <li><strong>Total items: <span class="text-green-600">${itemsToRecount.length}</span></strong></li>
                            <li><strong>Total SOH: <span class="text-purple-600">${formatNumber(totalSOH)}</span></strong></li>
                        </ul>
                    </div>
                `;
                showModal("Generate Recount Master File", previewMessage, {
                    onConfirm: () => {
                        // Use new file naming convention: Master_ReCount_branchcode_date.csv
                        const branchInfo = state.branchCode ? `${state.branchCode}_${state.countDate}` : `${state.branchName.replace(/\s+/g, '_')}_${state.countDate}`;
                        const fileName = `Master_ReCount_${branchInfo}.csv`;
                        
                        const rowsForCsv = itemsToRecount.map(item => [item.SKU, item.Description, item.Price, item.Age, item.SOH]);
                        downloadFile(Papa.unparse(rowsForCsv, { header: false }), fileName);
                        showModal("Success", `Recount master file generated with ${itemsToRecount.length} items.`);
                    },
                    onCancel: () => {},
                    confirmText: "Generate File",
                    cancelText: "Cancel"
                });
            }            async function handleLatestSohUpload(e) {
                const file = e.target.files[0]; if (!file) return;
                getEl('latestSohFileName').textContent = file.name;
                showLoader("Updating SOH...");
                try {
                    const latestSohRaw = await parseExcelFile(file);
                    if (!latestSohRaw?.length) throw new Error("Latest SOH file is empty or invalid.");
                    const { lookup: latestSohProcessedLookup } = processAndSeparateSoh(latestSohRaw);
                    if (Object.keys(latestSohProcessedLookup).length === 0) throw new Error("No valid stock items found in the latest SOH file.");
                    
                    // Track SKUs with updated SOH
                    const sohUpdatedSkus = new Set();
                    let updatedCount = 0;
                    
                    state.netDiffData.forEach(item => {
                        if (latestSohProcessedLookup[item.SKU] !== undefined) {
                            const oldSoh = item.SOH;
                            const newSoh = latestSohProcessedLookup[item.SKU].SOH;
                            if (oldSoh !== newSoh) { 
                                item.SOH = newSoh; 
                                item.Diff1 = item.Scan1 - item.SOH; 
                                sohUpdatedSkus.add(item.SKU);
                                updatedCount++; 
                            }
                        }
                    });
                    Object.values(state.sohLookup).forEach(item => {
                        if (latestSohProcessedLookup[item.SKU] !== undefined) {
                            const oldSoh = item.SOH;
                            const newSoh = latestSohProcessedLookup[item.SKU].SOH;
                            if (oldSoh !== newSoh) {
                                item.SOH = newSoh;
                                sohUpdatedSkus.add(item.SKU);
                            }
                        }
                    });
                    if (state.reconciledData.length > 0) {
                        state.reconciledData.forEach(item => {
                            if (latestSohProcessedLookup[item.SKU] !== undefined) { 
                                const oldSoh = item.SOH;
                                const newSoh = latestSohProcessedLookup[item.SKU].SOH;
                                if (oldSoh !== newSoh) {
                                    item.SOH = newSoh; 
                                    item.FinalDiff = item.Recount - item.SOH;
                                    sohUpdatedSkus.add(item.SKU);
                                      // Update reason to include SOHupdated
                                    if (!item.ReasonFinal || item.ReasonFinal === 'DEMO-N/A' || item.ReasonFinal === 'N/A Re-Scan') {
                                        item.ReasonFinal = 'SOHupdated';
                                    } else if (!item.ReasonFinal.includes('SOHupdated')) {
                                        item.ReasonFinal = `SOHupdated-${item.ReasonFinal}`;
                                    }
                                } else {
                                    item.SOH = newSoh; 
                                    item.FinalDiff = item.Recount - item.SOH;
                                }
                            }
                        });
                        applyFinalReportView(); renderFinalReportCharts();
                    }
                    
                    // Store SOH updated SKUs for future reference
                    if (!state.sohUpdatedSkus) state.sohUpdatedSkus = new Set();
                    sohUpdatedSkus.forEach(sku => state.sohUpdatedSkus.add(sku));
                    
                    showModal("Success", `SOH updated for ${updatedCount} items. You can now generate a new recount file or finalize the report.`);
                    setUnsavedChanges(true);
                } catch (error) { showModal("Error Updating SOH", error.message);
                } finally { hideLoader(); e.target.value = ''; getEl('latestSohFileName').textContent = ''; }
            }
            
            async function processSecondCount() {
                showLoader('Processing Recount...');
                try {
                    const logFiles = getEl('secondScanLogfile').files;
                    const masterFile = getEl('secondMasterFile').files[0];
                    
                    if (!logFiles.length && !masterFile) {
                        throw new Error("Please upload at least one file (Logfile or Master.csv) for the recount.");
                    }
                    
                    let recountData = [];
                    
                    // Process Logfile(s) if uploaded
                    if (logFiles.length > 0) {
                        const logfileData = await (async function(files){ 
                            const p = Array.from(files).map(f => new Promise((res, rej) => { 
                                Papa.parse(f, { 
                                    skipEmptyLines: true, 
                                    complete: r => { 
                                        const d = r.data.map(row => { 
                                            if(!row || row.length < 3 || !row[2]) return null; 
                                            const sku = String(row[2]).trim(); 
                                            const qty = parseInt(String(row[4] ?? 1).replace(/,/g,''), 10); 
                                            return {sku, qty: isNaN(qty) ? 1: qty};
                                        }).filter(Boolean); 
                                        res(d); 
                                    }, 
                                    error: rej
                                }); 
                            })); 
                            return Promise.all(p).then(r => r.flat()); 
                        })(logFiles);
                        recountData = recountData.concat(logfileData);
                    }
                    
                    // Process Master.csv if uploaded
                    if (masterFile) {
                        const masterData = await new Promise((resolve, reject) => {
                            Papa.parse(masterFile, {
                                skipEmptyLines: true,
                                complete: result => {
                                    try {
                                        const data = result.data.map(row => {
                                            if (!row || row.length < 6 || !row[0]) return null;
                                            const sku = String(row[0]).trim(); // Column 1: Part No.
                                            const qty = parseInt(String(row[5] || '0').replace(/,/g, ''), 10); // Column 6: Actual Qty
                                            // Only include items that were actually counted (qty > 0)
                                            if (isNaN(qty) || qty <= 0) return null;
                                            return { sku, qty };
                                        }).filter(Boolean);
                                        resolve(data);
                                    } catch (error) {
                                        reject(error);
                                    }
                                },
                                error: reject
                            });
                        });
                        recountData = recountData.concat(masterData);
                    }
                    
                    // Convert recount data array to SKU-keyed object for easier lookup
                    const recountCounts = {};
                    recountData.forEach(item => {
                        if (recountCounts[item.sku]) {
                            recountCounts[item.sku] += item.qty; // Sum if same SKU appears multiple times
                        } else {
                            recountCounts[item.sku] = item.qty;
                        }
                    });                    state.reconciledData = state.netDiffData.map(item => {
                        const newItem = {...item};
                        
                        // Check if item has been manually edited in final table
                        const existingReconciledItem = state.reconciledData.find(r => r.SKU === item.SKU);
                        const hasManualEdit = existingReconciledItem && (
                            existingReconciledItem.ReasonFinal === 'Manual Edit' ||
                            existingReconciledItem.ReasonFinal === 'SOHupdated-Manual Edit'
                        );
                        
                        if (hasManualEdit) {
                            // Skip updating - preserve manual edit
                            return existingReconciledItem;
                        }
                        
                        // Check if item has existing sales data that should be preserved
                        const hasSalesData = existingReconciledItem && 
                            existingReconciledItem.ReasonFinal && 
                            existingReconciledItem.ReasonFinal.includes('Sales:');
                        
                        if (hasSalesData) {
                            // Preserve existing sales data and only update if this item was recounted
                            if (recountCounts[newItem.SKU] !== undefined) {
                                // Item was recounted - add recount data to existing sales count
                                const salesMatch = existingReconciledItem.ReasonFinal.match(/Sales: (\d+) units added/);
                                const salesQty = salesMatch ? parseInt(salesMatch[1], 10) : 0;
                                
                                // Set base count from recount, then add sales on top
                                newItem.Recount = recountCounts[newItem.SKU] + salesQty;
                                newItem.FinalDiff = newItem.Recount - newItem.SOH;
                                
                                // Update reason to combine recount and sales info
                                const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(newItem.SKU);
                                const baseRecountReason = wasSohUpdated ? 'SOHupdated-Re-Scan' : 'Re-Scan';
                                newItem.ReasonFinal = `${baseRecountReason} + ${existingReconciledItem.ReasonFinal}`;
                                
                                // Preserve existing remarks (which contain bill numbers)
                                newItem.Remark = existingReconciledItem.Remark || '';
                            } else {
                                // Item was not recounted - preserve all existing sales data
                                return existingReconciledItem;
                            }
                        } else {
                            // No existing sales data - proceed with normal recount logic
                            // Initialize Recount and ReasonFinal for all items
                            if (!newItem.isDemo && newItem.Diff1 !== 0) {
                                // Items that need recounting
                                const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(newItem.SKU);                            
                                if (recountCounts[newItem.SKU] !== undefined) { 
                                    newItem.Recount = recountCounts[newItem.SKU]; 
                                    newItem.ReasonFinal = wasSohUpdated ? 'SOHupdated-Re-Scan' : 'Re-Scan';                            
                                } else { 
                                    newItem.Recount = 0; 
                                    newItem.ReasonFinal = wasSohUpdated ? 'SOHupdated-N/A Re-Scan' : 'N/A Re-Scan'; 
                                }
                            } else if (newItem.isDemo) {
                                // Demo items: get current count from demo panel
                                const demoCount = state.demoCounts[newItem.SKU];
                                const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(newItem.SKU);                            
                                if (demoCount && typeof demoCount.qty === 'number') {
                                    newItem.Recount = demoCount.qty;
                                    const baseReason = demoCount.reason || 'DEMO-Manual';
                                    newItem.ReasonFinal = wasSohUpdated ? `SOHupdated-${baseReason}` : baseReason;                            
                                } else {
                                    const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(newItem.SKU);
                                    newItem.Recount = 0;
                                    newItem.ReasonFinal = wasSohUpdated ? 'SOHupdated-DEMO-N/A' : 'DEMO-N/A';
                                }} else {
                                // Items that don't need recounting (items with no difference)
                                newItem.Recount = newItem.Counted1 || 0;
                                // Keep the original reason for items that don't need recounting
                                // Don't change to "No Recount Needed" - preserve the original counting reason
                            }
                            
                            newItem.FinalDiff = newItem.Recount - newItem.SOH;
                        }
                        
                        return newItem;
                    });

                    applyFinalReportView(); 
                    renderFinalReportCharts();
                    getEl('final-report-container').classList.remove('hidden');
                    getEl('final-report-container').scrollIntoView({ behavior: 'smooth' });
                    setUnsavedChanges(true);
                    
                    // Generate success message showing what files were processed
                    let processedFiles = [];
                    if (logFiles.length > 0) processedFiles.push(`${logFiles.length} Logfile(s)`);
                    if (masterFile) processedFiles.push('Master.csv');
                    const message = `Recount processed successfully using: ${processedFiles.join(' and ')}. Final report is now available.`;
                    
                    showModal("Success", message);
                } catch (error) { 
                    showModal("Error", "Recount processing failed: " + error.message);
                } finally { 
                    hideLoader(); 
                }
            }

            function applyFinalReportView() {
                if (!state.reconciledData.length) return;
                const searchValue = getEl('finalSearchInput').value.toUpperCase();
                const filterValue = getEl('finalFilterSelect').value;
                let dataView = state.reconciledData.filter(item => {
                    if (!(item.SKU.toUpperCase().includes(searchValue) || item.Description.toUpperCase().includes(searchValue))) return false;
                    if (filterValue === 'discrepancy') return item.FinalDiff !== 0;
                    if (filterValue === 'demo') return item.isDemo;
                    if (filterValue === 'normal') return !item.isDemo;
                    return true;
                });                const { column, direction } = state.finalReportSort;                dataView.sort((a, b) => {
                    let valA = column === 'FinalDiff' ? Math.abs(a[column]) : a[column];
                    let valB = column === 'FinalDiff' ? Math.abs(b[column]) : b[column];
                    
                    // Handle field name mapping for certain columns
                    if (column === 'SRP') {
                        valA = a.Price || 0;
                        valB = b.Price || 0;
                    } else if (column === 'FinalCount') {
                        valA = a.Recount || 0;
                        valB = b.Recount || 0;
                    }
                    
                    // Handle null/undefined values for string columns
                    if (column === 'ReasonFinal' || column === 'Remark') {
                        valA = valA || '';
                        valB = valB || '';
                    }
                    
                    if (typeof valA === 'string') return direction === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
                    return direction === 'asc' ? valA - valB : valB - valA;
                });
                renderFinalReportTable(dataView);
                updateFinalReportSummary();
            }            function renderFinalReportTable(data) {
                const container = getEl('final-report-table-container');
                if (!data.length) { container.innerHTML = '<p class="text-center p-10 text-slate-500">No data matches the current filter.</p>'; return; }
                const headers = `<thead><tr><th class="p-3 text-center w-12">NO.</th><th class="p-3 text-left" data-sort-by="SKU">SKU<span class="sort-indicator"></span></th><th class="p-3 text-left" data-sort-by="Description">Description<span class="sort-indicator"></span></th><th class="p-3 text-center" data-sort-by="SRP">SRP<span class="sort-indicator"></span></th><th class="p-3 text-center" data-sort-by="Age">Age<span class="sort-indicator"></span></th><th class="p-3 text-center" data-sort-by="SOH">SOH<span class="sort-indicator"></span></th><th class="p-3 text-center" data-sort-by="FinalCount">Final Count<span class="sort-indicator"></span></th><th class="p-3 text-center" data-sort-by="FinalDiff">Final Diff<span class="sort-indicator"></span></th><th class="p-3 text-left" data-sort-by="ReasonFinal">Reason<span class="sort-indicator"></span></th><th class="p-3 text-left" data-sort-by="Remark">Remark<span class="sort-indicator"></span></th></tr></thead>`;
                const body = `<tbody>${data.map((item, idx) => renderFinalReportRow(item, idx)).join('')}</tbody>`;
                container.innerHTML = `<table class="w-full text-sm">${headers}${body}</tbody></table>`;
                
                // Update sort indicators with colors
                const sortingTh = container.querySelector(`th[data-sort-by="${state.finalReportSort.column}"]`);
                if (sortingTh) { 
                    const indicator = sortingTh.querySelector('.sort-indicator');
                    indicator.textContent = state.finalReportSort.direction === 'asc' ? '▲' : '▼'; 
                    // Add color: green for ascending, red for descending
                    indicator.style.color = state.finalReportSort.direction === 'asc' ? '#22c55e' : '#ef4444';
                }
            }
            function renderFinalReportRow(item, idx) {
                const { rowClass, statusDotColor } = getRowVisuals(item.FinalDiff, item.isDemo);
                return `<tr class="border-b border-slate-200 ${rowClass}" data-sku="${item.SKU}">
                    <td class="p-3 text-center">${idx + 1}</td>
                    <td class="p-3 font-medium text-slate-800">${item.SKU}</td>
                    <td class="p-3 text-slate-600">${item.Description}</td>
                    <td class="p-3 text-center">${item.Price ?? 0}</td>
                    <td class="p-3 text-center text-slate-600">${item.Age || 'N/A'}</td>
                    <td class="p-3 text-center">${item.SOH}</td>
                    <td class="p-3 text-center w-24"><input type="number" value="${item.Recount}" class="w-full text-center p-1.5 border border-slate-300 rounded-md"/></td>
                    <td class="p-3 font-bold text-center ${getDiffColorClass(item.FinalDiff)}">${item.FinalDiff > 0 ? '+' : ''}${item.FinalDiff}</td>
                    <td class="p-3 text-slate-600">${item.ReasonFinal || 'N/A'}</td>
                    <td class="p-3 w-40"><input type="text" value="${item.Remark || ''}" class="w-full p-1.5 border border-slate-300 rounded-md"/></td>
                </tr>`;
            }

            function getRowVisuals(diff, isDemo = false) {
                if (diff === 0) return { rowClass: isDemo ? 'bg-sky-50' : 'bg-green-50', statusDotColor: isDemo ? 'bg-sky-500' : 'bg-green-500' };
                if (diff !== null) return { rowClass: diff > 0 ? 'bg-yellow-50' : 'bg-red-50', statusDotColor: 'bg-red-500' };
                return { rowClass: 'bg-white', statusDotColor: 'bg-gray-400' };
            }            function updateTableRowVisuals(row, diff, isDemo = false) {
                const { rowClass } = getRowVisuals(diff, isDemo);
                row.className = `border-b border-slate-200 ${rowClass}`;
                // Note: .status-dot element doesn't exist in table rows, so no need to update it
            }              function updateFinalCount(sku, value) {
                const item = state.reconciledData.find(i => i.SKU === sku); if (!item) return;
                const newCount = value === '' ? 0 : parseInt(value, 10);
                item.Recount = isNaN(newCount) ? 0 : newCount;
                item.FinalDiff = item.Recount - item.SOH; 
                
                // Handle SOH updated reason tracking
                const wasSohUpdated = state.sohUpdatedSkus && state.sohUpdatedSkus.has(sku);
                if (wasSohUpdated) {
                    item.ReasonFinal = 'SOHupdated-Manual Edit';
                } else {
                    item.ReasonFinal = 'Manual Edit';
                }
                const row = getEl('final-report-table-container').querySelector(`tr[data-sku="${sku}"]`);                
                  if(row) {
                    // Update Final Count column (index 6) with the new count value
                    row.cells[6].querySelector('input[type="number"]').value = item.Recount;
                    // Update Final Diff column (index 7) with the calculated difference
                    row.cells[7].textContent = item.FinalDiff > 0 ? `+${item.FinalDiff}` : item.FinalDiff;
                    row.cells[7].className = `p-3 font-bold text-center ${getDiffColorClass(item.FinalDiff)}`;
                    // Update Reason column (index 8)
                    row.cells[8].textContent = item.ReasonFinal;
                    updateTableRowVisuals(row, item.FinalDiff, item.isDemo);
                }
                updateFinalReportSummary();
                updateDemoSummary();
                renderFinalReportCharts();
                setUnsavedChanges(true);
            }            
            function updateRemark(sku, value) {
                const item = state.reconciledData.find(i => i.SKU === sku); if (item) { 
                    item.Remark = value; setUnsavedChanges(true); 
                }
            }

            function updateDemoRemark(sku, value) {
                const item = state.demoMaster.find(i => i.SKU === sku);
                if (item) {
                    item.remark = value;
                    setUnsavedChanges(true);
                }
            }

            function updateFinalReportSummary() {
                const summaryEl = getEl('final-summary');
                if (!state.reconciledData.length) {
                    summaryEl.innerHTML = ''; return; 
                }
                const summary = state.reconciledData.reduce((acc, item) => {
                    const diffCost = item.FinalDiff * item.Price;
                    if (item.FinalDiff > 0) {
                        acc.overQty += item.FinalDiff; acc.overCost += diffCost; 
                    } 
                    else if (item.FinalDiff < 0) {
                        acc.shortQty += item.FinalDiff; acc.shortCost += diffCost; 
                    }
                    acc.totalCountedQty += item.Recount; acc.totalCountedCost += item.Recount * item.Price;
                    acc.totalSOHPrice += item.SOH * (item.Price ?? 0);
                    acc.totalSOHQty += item.SOH;
                    return acc;
                }, { 
                    overQty: 0, overCost: 0, shortQty: 0, shortCost: 0, totalCountedQty: 0, totalCountedCost: 0, totalSOHPrice: 0, totalSOHQty: 0 
                });
                finalSummaryData = summary; // Save for JSON export
                finalSummaryData.netDiffCost = summary.overCost + summary.shortCost;

                summaryEl.innerHTML = `<h4 class="font-semibold text-center mb-1 text-slate-700">Report Summary</h4><div class="grid grid-cols-2 gap-x-4">
                    <div class="text-green-600"><strong>Over Qty:</strong> ${formatNumber(summary.overQty)}</div>
                    <div class="text-green-600"><strong>Over Cost:</strong> ${formatNumber(summary.overCost)}</div>
                    <div class="text-red-600"><strong>Short Qty:</strong> ${formatNumber(summary.shortQty)}</div>
                    <div class="text-red-600"><strong>Short Cost:</strong> ${formatNumber(summary.shortCost)}</div>
                    <div class="col-span-2 border-t pt-1 mt-1"></div>
                    <div class="text-blue-600"><strong>Total SOH Qty:</strong> ${formatNumber(summary.totalSOHQty)}</div>
                    <div class="text-blue-600"><strong>Total SOH Value:</strong> ${formatNumber(summary.totalSOHPrice)}</div>
                    <div class="text-blue-600"><strong>Total Counted Qty:</strong> ${formatNumber(summary.totalCountedQty)}</div>
                    <div class="text-blue-600"><strong>Total Counted Cost:</strong> ${formatNumber(summary.totalCountedCost)}</div>
                    <div class="font-bold col-span-2 border-t pt-1 mt-1"></div>
                    <div class="font-bold"><strong>Net Diff Qty:</strong> ${formatNumber(summary.overQty + summary.shortQty)}</div>
                    <div class="font-bold"><strong>Net Diff Cost:</strong> ${formatNumber(finalSummaryData.netDiffCost)}</div>
                </div>`;
            }

            function renderFinalReportCharts() {
                if (!state.reconciledData.length) return;
                Object.values(state.charts).forEach(chart => chart?.destroy());
                const summary = state.reconciledData.reduce((acc, item) => {
                    if (item.FinalDiff > 0) {
                        acc.overCost += item.FinalDiff * item.Price; acc.overQty += item.FinalDiff; 
                    } 
                    else if (item.FinalDiff < 0) {
                        acc.shortCost += Math.abs(item.FinalDiff * item.Price); acc.shortQty += Math.abs(item.FinalDiff); 
                    }
                    if (item.FinalDiff !== 0) {
                        const cat = item.CLASS_NAME || 'UNCATEGORIZED'; acc.byCategory[cat] = (acc.byCategory[cat] || 0) + item.FinalDiff; 
                    }
                    return acc;
                }, { 
                    overCost: 0, shortCost: 0, overQty: 0, shortQty: 0, byCategory: {} 
                   });
                const chartOptions = { 
                    responsive: true, maintainAspectRatio: false, plugins: { legend: { position: 'top' } } 
                };
                state.charts.cost = new Chart(getEl('costChart'), { type: 'doughnut', data: { labels: ['Over', 'Short'], datasets: [{ data: [summary.overCost, summary.shortCost], backgroundColor: ['#22c55e', '#ef4444'] }] }, options: chartOptions });
                state.charts.qty = new Chart(getEl('qtyChart'), { type: 'doughnut', data: { labels: ['Over', 'Short'], datasets: [{ data: [summary.overQty, summary.shortQty], backgroundColor: ['#22c55e', '#ef4444'] }] }, options: chartOptions });
                const categoryData = Object.entries(summary.byCategory).sort(([,a],[,b]) => Math.abs(b) - Math.abs(a)).slice(0, 15);
                state.charts.category = new Chart(getEl('categoryChart'), { type: 'bar', data: { labels: categoryData.map(([name]) => name.substring(0, 15)), datasets: [{ label: 'Net Qty Difference', data: categoryData.map(([, qty]) => qty), backgroundColor: categoryData.map(([, qty]) => qty > 0 ? 'rgba(34, 197, 94, 0.7)' : 'rgba(239, 68, 68, 0.7)'), }] }, options: { ...chartOptions, indexAxis: 'y', scales: { y: { beginAtZero: true } } } });
            }
              function exportFinalReport() {
                if (!state.reconciledData.length) return showModal("Info", "No data to export.");
                const dataToExport = state.reconciledData.map((item, idx) => ({
                    NO: idx + 1, 
                    SKU: item.SKU, 
                    Description: item.Description, 
                    SRP: item.Price, 
                    Age: item.Age, 
                    SOH: item.SOH, 
                    Scan: item.Scan1, 
                    Recount: item.Recount, 
                    FinalDiff: item.FinalDiff, 
                    Remark: item.Remark || '', 
                    Reason: item.ReasonFinal,
                    Flag: item.isDemo ? 'DEMO' : 'NONE'
                }));
                const branchInfo = state.branchCode ? `${state.branchCode}_${state.branchName.replace(/\s+/g, '_')}` : state.branchName.replace(/\s+/g, '_');
                downloadFile(Papa.unparse(dataToExport, { header: true }), `${state.countDate}_Report_${branchInfo}.csv`);
            }
            function exportStockCountToJSON() {
                if (!state.reconciledData.length) {
                    alert('กรุณาประมวลผลข้อมูลให้ถึงขั้นตอนสุดท้ายก่อนทำการ Export');
                    return;
                }
                const exportData = {
                    tool: 'stock-count',
                    details: {
                        branch: state.branchName,
                        branchCode: state.branchCode,
                        date: state.countDate,
                    },
                    summary: finalSummaryData,
                    data: state.reconciledData.filter(item => item.FinalDiff !== 0)
                };
                const jsonString = JSON.stringify(exportData, null, 2);
                const blob = new Blob([jsonString], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const branchInfo = state.branchCode ? `${state.branchCode}_${state.branchName.replace(/\s+/g, '_')}` : state.branchName.replace(/\s+/g, '_');
                a.download = `${state.countDate}_Stock-Count_${branchInfo}.json`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }
              function handlePrintReport() {
                // Prepare input values for printing by copying them to parent cell data attributes
                const inputs = document.querySelectorAll('#final-report-table-container input, #demo-count-container input');
                
                // Store original data-print-value attributes from parent cells
                const originalValues = new Map();
                
                inputs.forEach(input => {
                    const parentCell = input.closest('td');
                    if (parentCell) {
                        // Store original value if exists
                        if (parentCell.hasAttribute('data-print-value')) {
                            originalValues.set(parentCell, parentCell.getAttribute('data-print-value'));
                        }
                        
                        // Set current input value to parent cell's data-print-value for printing
                        const value = input.value || '';
                        if (value.trim() !== '') {
                            parentCell.setAttribute('data-print-value', value);
                        } else {
                            parentCell.setAttribute('data-print-value', '-');
                        }
                    }
                });
                
                // Print the document
                window.print();
                
                // Clean up: restore original data-print-value attributes
                setTimeout(() => {
                    originalValues.forEach((originalValue, parentCell) => {
                        parentCell.setAttribute('data-print-value', originalValue);
                    });
                    
                    // Remove data-print-value from cells that didn't have it originally
                    inputs.forEach(input => {
                        const parentCell = input.closest('td');
                        if (parentCell && !originalValues.has(parentCell)) {
                            parentCell.removeAttribute('data-print-value');
                        }
                    });
                }, 500); // Small delay to ensure print dialog has opened
            }
            
            let audioCtx;
            function playSound(type) {
                if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)(); if (!audioCtx) return;
                const oscillator = audioCtx.createOscillator(); const gainNode = audioCtx.createGain();
                oscillator.connect(gainNode); gainNode.connect(audioCtx.destination);                if (type === 'success') { oscillator.type = 'sine'; oscillator.frequency.setValueAtTime(600, audioCtx.currentTime); gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime); oscillator.frequency.exponentialRampToValueAtTime(880, audioCtx.currentTime + 0.05); } 
                else { oscillator.type = 'square'; oscillator.frequency.setValueAtTime(200, audioCtx.currentTime); gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime); oscillator.frequency.exponentialRampToValueAtTime(100, audioCtx.currentTime + 0.1); }
                oscillator.start(audioCtx.currentTime); oscillator.stop(audioCtx.currentTime + 0.15);
            }

            let currentScanner = 'barcode'; // Legacy - kept for compatibility
            
            const startTextScanner = async () => {
                try {
                    if (activeStream) {
                        activeStream.getTracks().forEach(track => track.stop());
                    }
                    
                    // Enhanced camera constraints for iPad Gen10 and Apple product scanning
                    const cameraConstraints = {
                        video: {
                            facingMode: 'environment',
                            width: { ideal: 1920, max: 1920 },
                            height: { ideal: 1080, max: 1080 },
                            frameRate: { ideal: 30, max: 30 },
                            focusMode: 'continuous',
                            exposureMode: 'continuous',
                            whiteBalanceMode: 'continuous'
                        }
                    };
                    
                    activeStream = await navigator.mediaDevices.getUserMedia(cameraConstraints);
                    textScannerVideo.srcObject = activeStream;
                    textScannerVideo.play();
                } catch (err) {
                    scannerResultsEl.innerHTML = `<p class="text-red-500">Camera error: ${err.message}</p>`;
                }
            };
            
            function stopTextScanner() {
                // Stop all video tracks from the video element, not just activeStream
                const video = document.getElementById('text-scanner-video');
                if (video && video.srcObject) {
                    const tracks = video.srcObject.getTracks();
                    tracks.forEach(track => track.stop());
                    video.srcObject = null;
                }
                activeStream = null;
            }
            
            const captureAndRecognize = async () => {
                if (!activeStream || !cvReady) {
                    scannerResultsEl.innerHTML = `<p class="text-red-500">Camera or OpenCV is not ready.</p>`;
                    return;
                }
                scannerResultsEl.innerHTML = `<p class="text-blue-500">กำลังประมวลผลตัวอักษร...</p>`;
                captureBtn.disabled = true;

                const video = textScannerVideo;
                const canvas = document.createElement('canvas');

                // Crop a very narrow, focused region (centered)
                const cropHeightPercentage = 0.10; // Even narrower band (10% of height)
                const cropWidthPercentage = 0.55;  // Focus on center 55% of width
                const sWidth = video.videoWidth * cropWidthPercentage;
                const sHeight = video.videoHeight * cropHeightPercentage;
                const sx = video.videoWidth * (1 - cropWidthPercentage) / 2;
                const sy = video.videoHeight * 0.45; // Centered vertically

                canvas.width = sWidth;
                canvas.height = sHeight;

                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, sx, sy, sWidth, sHeight, 0, 0, sWidth, sHeight);

                // OpenCV preprocessing: grayscale, contrast, denoise, adaptive threshold
                let src = cv.imread(canvas);
                let gray = new cv.Mat();
                let denoised = new cv.Mat();
                let thresh = new cv.Mat();

                cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY, 0);
                cv.equalizeHist(gray, gray); // Contrast
                cv.GaussianBlur(gray, denoised, new cv.Size(3, 3), 0, 0, cv.BORDER_DEFAULT); // Denoise
                cv.adaptiveThreshold(
                    denoised, thresh, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 15, 8
                );

                cv.imshow(canvas, thresh);

                src.delete();
                gray.delete();
                denoised.delete();
                thresh.delete();

                try {
                    const result = await Tesseract.recognize(canvas, 'eng', {
                        logger: m => {
                            if (m.status === 'recognizing text') {
                                scannerResultsEl.innerHTML = `<p class="text-blue-500">${m.status} (${(m.progress * 100).toFixed(0)}%)...</p>`;
                            }
                        },
                        tessedit_char_whitelist: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-',
                    });

                    // Post-process: Remove spaces, filter by length/pattern
                    let recognizedText = result.data.text.replace(/\s/g, '').toUpperCase();
                    // Accept only if matches expected pattern (8+ alphanum, adjust as needed)
                    const match = recognizedText.match(/[A-Z0-9\-]{8,}/);
                    if (match) {
                        recognizedText = match[0];
                        scannerResultsEl.innerHTML = `<p>Found text: ${recognizedText}</p>`;
                        processScannedCode(recognizedText, 'DEMO-Text Scan');
                    } else {
                        scannerResultsEl.innerHTML = `<p class="text-red-500">ไม่พบตัวอักษรที่ชัดเจน</p>`;
                    }
                } catch (err) {
                    scannerResultsEl.innerHTML = `<p class="text-red-500">OCR Error: ${err.message}</p>`;
                } finally {
                    captureBtn.disabled = false;
                }
            };

            const startOcrStreaming = () => {
                if (ocrStreaming) return;
                ocrStreaming = true;
                scannerResultsEl.innerHTML = '<p class="text-blue-500">กำลังสแกนแบบเรียลไทม์...</p>';
                ocrStreamInterval = setInterval(processOcrFrame, 700); // every 700ms
            };

            const stopOcrStreaming = () => {
                ocrStreaming = false;
                if (ocrStreamInterval) clearInterval(ocrStreamInterval);
                ocrStreamInterval = null;
            };            const processOcrFrame = async () => {
                if (!ocrStreaming || !activeStream || !cvReady) return;
                const video = textScannerVideo;
                if (video.readyState < 2) return;
                
                const startTime = performance.now();
                ocrTotalAttempts++;
                
                const canvas = document.createElement('canvas');
                
                // --- Enhanced Crop Settings for Apple Products ---
                // Optimized crop for Apple serial numbers typically found on back/bottom
                const cropY = video.videoHeight * 0.45;        // Higher up for better Apple serial scanning
                const cropHeight = video.videoHeight * 0.18;   // Taller crop for better text capture
                const cropX = video.videoWidth * 0.05;         // Slight left margin for better frame
                const cropWidth = video.videoWidth * 0.90;     // Wider crop for better coverage
                
                canvas.width = cropWidth;
                canvas.height = cropHeight;
                const ctx = canvas.getContext('2d');
                ctx.drawImage(video, cropX, cropY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

                // Show cropped preview
                const preview = document.getElementById('ocr-crop-preview');
                if (preview) {
                    preview.width = canvas.width;
                    preview.height = canvas.height;
                    preview.getContext('2d').drawImage(canvas, 0, 0);
                }

                // Check cache first
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const cacheKey = generateCacheKey(imageData, ocrSettings.demo);
                if (ocrResultsCache.has(cacheKey)) {
                    ocrCacheHits++;
                    const cachedResult = ocrResultsCache.get(cacheKey);
                    
                    if (cachedResult.text && cachedResult.text.match(/[A-Z0-9\-]{8,}/)) {
                        scannerResultsEl.innerHTML = `<p>Serial Number: <b>${cachedResult.text}</b> (cached)</p>`;
                        processScannedCode(cachedResult.text, 'DEMO-Text Scan');
                        stopOcrStreaming();
                        return;
                    }
                }

                // --- Enhanced Lighting Detection for Apple Products ---
                let total = 0;
                let pixelCount = 0;
                let contrastSum = 0;
                let prevPixel = 0;
                
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const pixel = (imageData.data[i] + imageData.data[i+1] + imageData.data[i+2]) / 3;
                    total += pixel;
                    pixelCount++;
                    
                    // Calculate contrast for better lighting assessment
                    if (pixelCount > 1) {
                        contrastSum += Math.abs(pixel - prevPixel);
                    }
                    prevPixel = pixel;
                }
                
                const avgBrightness = total / pixelCount;
                const avgContrast = contrastSum / (pixelCount - 1);
                
                // Enhanced lighting feedback for Apple products
                if (avgBrightness < 55) {
                    scannerResultsEl.innerHTML = `<p class="text-yellow-600">ภาพมืดเกินไป กรุณาเพิ่มแสงสว่าง (${avgBrightness.toFixed(0)})</p>`;
                    return;
                } else if (avgBrightness > 220) {
                    scannerResultsEl.innerHTML = `<p class="text-yellow-600">ภาพสว่างเกินไป กรุณาลดแสงสว่าง (${avgBrightness.toFixed(0)})</p>`;
                    return;
                } else if (avgContrast < 15) {
                    scannerResultsEl.innerHTML = `<p class="text-yellow-600">ภาพไม่ชัดเจน กรุณาปรับโฟกัส (${avgContrast.toFixed(0)})</p>`;
                    return;
                }

                // --- Enhanced Preprocessing Algorithms for Apple Products ---
                let src = cv.imread(canvas);
                let dst = new cv.Mat();
                
                if (ocrSettings.demo.preprocessing === 'basic') {
                    // Basic Apple-optimized preprocessing
                    cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);
                    
                    // Apply mild sharpening for Apple serial text
                    const sharpKernel = cv.matFromArray(3, 3, cv.CV_32FC1, [0, -1, 0, -1, 5, -1, 0, -1, 0]);
                    cv.filter2D(dst, dst, -1, sharpKernel);
                    sharpKernel.delete();
                    
                    cv.threshold(dst, dst, 0, 255, cv.THRESH_OTSU | cv.THRESH_BINARY_INV);
                } else if (ocrSettings.demo.preprocessing === 'enhanced') {
                    // Enhanced Apple-optimized preprocessing
                    cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);
                    
                    // CLAHE for better contrast on Apple products
                    const clahe = new cv.CLAHE(2.0, new cv.Size(8, 8));
                    clahe.apply(dst, dst);
                    clahe.delete();
                    
                    // Bilateral filter for noise reduction while preserving edges
                    cv.bilateralFilter(dst, dst, 9, 75, 75);
                    
                    // Unsharp masking for Apple text enhancement
                    const blurred = new cv.Mat();
                    cv.GaussianBlur(dst, blurred, new cv.Size(3, 3), 0, 0, cv.BORDER_DEFAULT);
                    cv.addWeighted(dst, 1.5, blurred, -0.5, 0, dst);
                    blurred.delete();
                    
                    cv.threshold(dst, dst, 0, 255, cv.THRESH_OTSU | cv.THRESH_BINARY_INV);
                } else if (ocrSettings.demo.preprocessing === 'aggressive') {
                    // Aggressive Apple-optimized preprocessing
                    cv.cvtColor(src, dst, cv.COLOR_RGBA2GRAY, 0);
                    
                    // Advanced CLAHE for difficult lighting
                    const clahe = new cv.CLAHE(3.0, new cv.Size(6, 6));
                    clahe.apply(dst, dst);
                    clahe.delete();
                    
                    // Multiple denoising passes for Apple products
                    cv.fastNlMeansDenoising(dst, dst, 10, 7, 21);
                    
                    // Adaptive bilateral filtering
                    cv.bilateralFilter(dst, dst, 11, 80, 80);
                    
                    // Multi-scale sharpening for Apple text
                    const sharp1 = new cv.Mat();
                    const sharp2 = new cv.Mat();
                    cv.GaussianBlur(dst, sharp1, new cv.Size(3, 3), 0, 0, cv.BORDER_DEFAULT);
                    cv.GaussianBlur(dst, sharp2, new cv.Size(5, 5), 0, 0, cv.BORDER_DEFAULT);
                    cv.addWeighted(dst, 2.0, sharp1, -0.5, 0, dst);
                    cv.addWeighted(dst, 1.0, sharp2, -0.5, 0, dst);
                    sharp1.delete();
                    sharp2.delete();
                    
                    // Adaptive thresholding with morphological operations
                    cv.adaptiveThreshold(dst, dst, 255, cv.ADAPTIVE_THRESH_GAUSSIAN_C, cv.THRESH_BINARY_INV, 11, 6);
                    
                    // Morphological operations optimized for Apple text
                    const kernel1 = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(2, 2));
                    const kernel2 = cv.getStructuringElement(cv.MORPH_RECT, new cv.Size(3, 1));
                    cv.morphologyEx(dst, dst, cv.MORPH_CLOSE, kernel1);
                    cv.morphologyEx(dst, dst, cv.MORPH_OPEN, kernel2);
                    kernel1.delete();
                    kernel2.delete();
                }
                  cv.imshow(canvas, dst);
                src.delete();
                dst.delete();
                
                try {
                    if (!tesseractWorker) {
                        await initTesseract(ocrSettings.demo.language, true);
                    }
                    
                    // --- Enhanced OCR Processing for Apple Products ---
                    const result = await tesseractWorker.recognize(canvas);
                    const processingTime = performance.now() - startTime;
                    
                    let text = result.data.text.replace(/\s/g, '').toUpperCase();
                    let confidence = result.data.confidence;
                    
                    // --- Apple-specific Text Post-processing ---
                    // Remove common OCR artifacts for Apple serials
                    text = text.replace(/[|]/g, 'I')      // Common OCR mistake
                             .replace(/[0]/g, 'O')       // Zero to O confusion
                             .replace(/[8]/g, 'B')       // Eight to B confusion
                             .replace(/[5]/g, 'S')       // Five to S confusion
                             .replace(/[1]/g, 'I')       // One to I confusion
                    
                    // Update performance tracking
                    ocrPerformanceHistory.push({ time: processingTime, confidence, success: false });
                    if (ocrPerformanceHistory.length > 50) ocrPerformanceHistory.shift();
                    
                    // Process validation results
                    
                    // --- Enhanced Apple Serial Validation ---
                    const appleSerialMatch = text.match(/[A-Z0-9\-]{8,}/);
                    const isValidAppleSerial = appleSerialMatch && (
                        text.length >= 8 && text.length <= 14 &&
                        /[A-Z]/.test(text) &&      // Must contain letters
                        /[0-9]/.test(text) &&      // Must contain numbers
                        !/[^A-Z0-9\-]/.test(text)  // Only valid characters
                    );
                    
                    if (isValidAppleSerial && confidence >= ocrSettings.demo.confidence) {
                        const finalText = appleSerialMatch[0];
                        
                        // Cache successful result
                        ocrResultsCache.set(cacheKey, { text: finalText, confidence, timestamp: Date.now() });
                        
                        // Learn successful pattern
                        learnSuccessPattern(finalText, confidence, processingTime);
                        
                        // Update success tracking
                        ocrSuccessCount++;
                        ocrPerformanceHistory[ocrPerformanceHistory.length - 1].success = true;
                        
                        
                        scannerResultsEl.innerHTML = `<p>Apple Serial: <b>${finalText}</b></p>`;
                        processScannedCode(finalText, 'DEMO-Text Scan');
                        stopOcrStreaming();
                    } else {
                        scannerResultsEl.innerHTML = `<p class='text-blue-500'>Scanning Apple products... (${confidence.toFixed(1)}%)</p>`;
                    }
                    
                    // Adaptive settings based on performance
                    if (ocrPerformanceHistory.length > 0 && ocrPerformanceHistory.length % 10 === 0) {
                        adaptiveOcrSettings(ocrPerformanceHistory, true);
                    }
                } catch (err) {
                    handleOcrError(err, true);
                    scannerResultsEl.innerHTML = `<p class='text-red-500'>Apple OCR Error: ${err.message}</p>`;
                }
            };

            const startBarcodeScanner = () => {
                 Quagga.init({ inputStream: { name: "Live", type: "LiveStream", target: getEl('qr-reader'), constraints: { facingMode: "environment" } }, decoder: { readers: [ "code_128_reader", "ean_reader", "ean_8_reader", "code_39_reader", "upc_reader", "upc_e_reader" ] }, locate: true }, (err) => { if (err) { scannerResultsEl.innerHTML = `<p class="text-red-500">Camera error: ${err.message}</p>`; return; } Quagga.start(); });
                 Quagga.onDetected(onBarcodeDetected);
            };
            
            function stopBarcodeScanner() {
                if (typeof Quagga !== 'undefined' && Quagga.running) {
                    Quagga.offDetected(onBarcodeDetected);
                    Quagga.stop();
                }
                // Extra cleanup: stop video tracks from Quagga's video element
                const quaggaVideo = document.querySelector('#qr-reader video');
                if (quaggaVideo && quaggaVideo.srcObject) {
                    quaggaVideo.srcObject.getTracks().forEach(track => track.stop());
                    quaggaVideo.srcObject = null;
                }
            }
              const openScannerModal = () => {
                openFloatingScanner('demo');
            };            const closeScannerModal = () => {
                // Legacy function - now handled by floating scanner
                closeFloatingScanner();
            };const processScannedCode = (code, reason) => {
                const scannedText = code.toUpperCase();
                
                // Use shared matching function for enhanced Apple product matching
                let item = findItemByScannedText(state.demoMaster, scannedText);

                if (item) {
                    playSound('success');
                    let currentCount = typeof item.counted === 'number' ? item.counted : 0;
                    item.counted = currentCount + 1;
                    state.demoCounts[item.SKU] = { qty: item.counted, reason: reason };
                    applyDemoView();
                    const row = getEl('demo-count-container').querySelector(`tr[data-sku="${item.SKU}"]`);
                    if (row) {
                        row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        row.classList.add('ring-2', 'ring-offset-2', 'ring-green-500');
                        setTimeout(() => row.classList.remove('ring-2', 'ring-offset-2', 'ring-green-500'), 800);
                    }
                    const diff = item.counted - item.SOH;
                    let statusText = (diff === 0) ? 'Matched' : (diff > 0) ? 'Overage' : 'Shortage';
                    let statusColor = (diff === 0) ? 'text-green-600' : (diff > 0) ? 'text-yellow-600' : 'text-blue-600';
                    scannerResultsEl.innerHTML = `<div class="text-left w-full space-y-1"><p class="font-medium text-slate-800">${item.Description}</p><p class="text-sm text-slate-500">SKU: ${item.SKU}</p><div class="flex justify-between items-baseline pt-1"><span class="text-lg font-bold text-slate-700">Count: <span class="text-blue-600">${item.counted}</span> / ${item.SOH}</span><span class="text-lg font-bold ${statusColor}">${statusText}</span></div></div>`;
                } else {
                    playSound('error');
                    scannerResultsEl.innerHTML = `<div class="text-center w-full"><p class="font-bold text-red-600">SKU Not Found</p><p class="text-sm text-slate-500">${scannedText}</p></div>`;
                }
            };
            
            const scanCooldown = {};
            const onBarcodeDetected = (result) => {
                const code = result.codeResult.code.trim();
                const now = Date.now(); if (scanCooldown[code] && now - scanCooldown[code] < 10000) return;
                scanCooldown[code] = now;
                processScannedCode(code, 'DEMO-Barcode');
            };
              function initializeAppListeners() {
                function addListener(id, event, handler) {
                    const el = getEl(id);
                    if (el) {
                        el.addEventListener(event, handler);
                    }
                }

                // Export SOH Excel functionality
                function exportSohExcel() {
                    try {
                        // Use the same processed data as the app (sohLookup)
                        const allItems = Object.values(state.sohLookup).filter(item => item.SOH > 0);
                          if (allItems.length === 0) {
                            showModal("Warning", "No SOH data available to export");
                            return;
                        }

                        // Sort by SKU for consistency
                        allItems.sort((a, b) => a.SKU.localeCompare(b.SKU));
                          // Prepare data for export - use existing isDemo flag
                        const rows = allItems.map(item => {
                            return {
                                SKU: item.SKU,
                                Description: item.Description,
                                SRP: item.Price,
                                Age: item.Age,
                                SOH: item.SOH,
                                FAMILY: item.isDemo ? 'DEMO' : 'NONE'
                            };
                        });
                        const ws = XLSX.utils.json_to_sheet(rows);
                        const wb = XLSX.utils.book_new();
                        XLSX.utils.book_append_sheet(wb, ws, "SOH Export");
                        
                        // Use new file naming convention: countdate_function_branchcode_branchname
                        const branchInfo = state.branchCode ? `${state.branchCode}_${state.branchName.replace(/\s+/g, '_')}` : state.branchName.replace(/\s+/g, '_');
                        const filename = `${state.countDate || new Date().toISOString().split('T')[0]}_SOH_Export_${branchInfo}.xlsx`;
                        XLSX.writeFile(wb, filename);
                          showModal("Success", `Successfully exported ${allItems.length} items to ${filename}`);
                    } catch (error) {
                        // Export SOH Excel error handled silently for production
                        showModal("Error", "Failed to export SOH Excel file");
                    }
                }
                
                addListener('newJobButton', 'click', startNewJob);
                addListener('save-progress-button', 'click', handleSaveProgressToFile);
                addListener('main-tab-demo', 'click', () => switchMainTab('demo'));
                addListener('main-tab-workflow', 'click', () => switchMainTab('workflow'));
                addListener('downloadMasterForScan', 'click', downloadMasterForScan);
                addListener('processFirstCount', 'click', processFirstCount);
                addListener('finalizeFromFirstCount', 'click', finalizeFromFirstCount);
                addListener('generateRecountMasterFile', 'click', generateRecountMasterFile);
                addListener('processSecondCount', 'click', processSecondCount);
                addListener('exportCsvButton', 'click', exportFinalReport);
                addListener('exportJsonButton', 'click', exportStockCountToJSON);
                addListener('refreshChartsButton', 'click', renderFinalReportCharts);
                addListener('exportDemoCsvButton', 'click', exportDemoTable);
                addListener('exportSohExcelBtn', 'click', exportSohExcel);
                addListener('openScannerBtn', 'click', openScannerModal);
                addListener('final-openScannerBtn', 'click', finalOpenScannerModal);
                // closeScannerBtn removed - handled by floating scanner
                addListener('print-final-report-btn', 'click', handlePrintReport);
                // Scanner tab switching removed - handled by floating scanner
                // Capture button removed - handled by floating scanner

                addListener('demoSearchInput', 'keyup', applyDemoView);
                addListener('demoFilterSelect', 'change', applyDemoView);
                addListener('finalSearchInput', 'keyup', applyFinalReportView);
                addListener('finalFilterSelect', 'change', applyFinalReportView);
                addListener('load-progress-file', 'change', handleLoadProgressFromFile);                
                addListener('initialSohFile', 'change', handleSohFileUpload);                
                addListener('firstScanLogfile', 'change', () => updateFirstCountButton());
                addListener('firstMasterFile', 'change', () => updateFirstCountButton());
                addListener('salesDataFile', 'change', () => getEl('processSalesData').disabled = getEl('salesDataFile').files.length === 0);
                addListener('processSalesData', 'click', processSalesData);
                addListener('latestSohFile', 'change', handleLatestSohUpload);                
                addListener('secondScanLogfile', 'change', () => updateSecondCountButton());
                addListener('secondMasterFile', 'change', () => updateSecondCountButton());

                function updateSecondCountButton() {
                    const logFiles = getEl('secondScanLogfile').files.length > 0;
                    const masterFile = getEl('secondMasterFile').files.length > 0;
                    
                    // Enable button if at least one file type is uploaded
                    getEl('processSecondCount').disabled = !(logFiles || masterFile);
                }                function updateFirstCountButton() {
                    const logFiles = getEl('firstScanLogfile').files.length > 0;
                    const masterFile = getEl('firstMasterFile').files.length > 0;
                      // Enable button if at least one file type is uploaded
                    getEl('processFirstCount').disabled = !(logFiles || masterFile);
                }

                addListener('wf-step-tabs', 'click', e => { if (e.target.id.startsWith('wf-tab-btn-')) changeWorkflowTab(e.target.id.slice(-1)); });
                addListener('demo-count-container', 'click', e => { const header = e.target.closest('th[data-sort-by]'); if (header) handleSort('demoSort', header.dataset.sortBy, applyDemoView); });
                addListener('demo-count-container', 'input', e => { const { target: input } = e; const sku = input.closest('tr').dataset.sku; if (input.matches('input[type="number"]')) updateDemoCount(sku, input.value); else if (input.matches('input[type="text"]')) updateDemoRemark(sku, input.value); });
                addListener('final-report-table-container', 'click', e => { const header = e.target.closest('th[data-sort-by]'); if (header) handleSort('finalReportSort', header.dataset.sortBy, applyFinalReportView); });
                addListener('final-report-table-container', 'input', e => { const { target: input } = e; const sku = input.closest('tr').dataset.sku; if (input.matches('input[type="number"]')) updateFinalCount(sku, input.value); else if (input.matches('input[type="text"]')) updateRemark(sku, input.value); });
                  const handleEnter = (event) => { if (event.key === 'Enter') { const allInputs = Array.from(event.currentTarget.querySelectorAll('input[type="number"], input[type="text"]')); const currentIndex = allInputs.indexOf(event.target); if (currentIndex > -1 && currentIndex < allInputs.length - 1) allInputs[currentIndex + 1].focus(); } };
                addListener('demo-count-container', 'keydown', handleEnter);
                addListener('final-report-table-container', 'keydown', handleEnter);

                // === OCR Enhancement Event Listeners ===
                // Demo scanner OCR controls
                addListener('ocr-confidence-slider', 'input', (e) => {
                    ocrSettings.demo.confidence = parseInt(e.target.value);
                    document.getElementById('ocr-confidence-value').textContent = e.target.value + '%';
                });
                addListener('ocr-speed-select', 'change', (e) => {
                    ocrSettings.demo.speed = parseInt(e.target.value);
                    if (ocrStreamInterval) {
                        clearInterval(ocrStreamInterval);
                        ocrStreamInterval = setInterval(processOcrFrame, ocrSettings.demo.speed);
                    }
                });
                addListener('ocr-language-select', 'change', async (e) => {
                    ocrSettings.demo.language = e.target.value;
                    if (tesseractWorker) {
                        await initTesseract(ocrSettings.demo.language, true);
                    }
                });                addListener('ocr-preprocessing-select', 'change', (e) => {
                    ocrSettings.demo.preprocessing = e.target.value;
                });

                // Final scanner OCR controls
                addListener('final-ocr-confidence-slider', 'input', (e) => {
                    ocrSettings.final.confidence = parseInt(e.target.value);
                    document.getElementById('final-ocr-confidence-value').textContent = e.target.value + '%';
                });                addListener('final-ocr-speed-select', 'change', (e) => {
                    ocrSettings.final.speed = parseInt(e.target.value);
                    if (finalOcrStreaming) {
                        clearInterval(finalOcrStreamInterval);
                        finalOcrStreamInterval = setInterval(finalProcessOcrFrame, ocrSettings.final.speed);
                    }
                });
                addListener('final-ocr-language-select', 'change', async (e) => {
                    ocrSettings.final.language = e.target.value;
                    if (finalTesseractWorker) {
                        await initTesseract(ocrSettings.final.language, false);
                    }                });
                
                addListener('final-ocr-preprocessing-select', 'change', (e) => {
                    ocrSettings.final.preprocessing = e.target.value;
                });

                window.addEventListener('beforeunload', (e) => { if (hasUnsavedChanges) e.preventDefault(); });
            }
            
            initializeAppListeners();
            
            // === Initialize Floating Scanner ===
            
            function setupFloatingScanner() {
                floatingScanner = document.getElementById('floating-scanner');
                if (floatingScanner) {
                    // Call the actual initialization function
                    initializeFloatingScanner();
                } else {
                    // Floating scanner element not found - handled silently for production
                    // Retry after a short delay in case DOM is still loading
                    setTimeout(() => {
                        floatingScanner = document.getElementById('floating-scanner');
                        if (floatingScanner) {
                            initializeFloatingScanner();
                        }
                    }, 100);                }
            }
            
            // Initialize floating scanner after DOM is ready
            setupFloatingScanner();            // --- Final Report Scanner Logic ---
              function finalOpenScannerModal() {
                openFloatingScanner('final');
            }

            function finalCloseScannerModal() {
                // Legacy function - now handled by floating scanner
                closeFloatingScanner();
            }

            const finalScanCooldown = {};
            function finalOnBarcodeDetected(result) {
                const code = result.codeResult.code.trim();
                const now = Date.now();
                if (finalScanCooldown[code] && now - finalScanCooldown[code] < 10000) return;
                finalScanCooldown[code] = now;
                processFinalScannedCode(code, 'Barcode');
            }            function processFinalScannedCode(code, reason) {
                const scannedText = code.toUpperCase();
                
                // Use shared matching function for enhanced Apple product matching
                let item = findItemByScannedText(state.reconciledData, scannedText);

                if (item) {
                    playSound('success');
                    finalScannerResultsEl.innerHTML = `<div class="text-left w-full space-y-1"><p class="font-medium text-slate-800">${item.Description}</p><p class="text-sm text-slate-500">SKU: ${item.SKU}</p><div class="flex justify-between items-baseline pt-1"><span class="text-lg font-bold text-slate-700">Counted: <span class="text-blue-600">${item.Recount}</span> / ${item.SOH}</span><span class="text-lg font-bold">${item.FinalDiff === 0 ? '<span class="text-green-600">Matched</span>' : item.FinalDiff > 0 ? '<span class="text-yellow-600">Overage</span>' : '<span class="text-blue-600">Shortage</span>'}</span></div></div>`;
                    const row = document.querySelector(`#final-report-table-container tr[data-sku="${item.SKU}"]`);
                    if (row) {
                        row.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        row.classList.add('ring-2', 'ring-offset-2', 'ring-green-500');
                        setTimeout(() => row.classList.remove('ring-2', 'ring-offset-2', 'ring-green-500'), 800);
                    }                } else {
                    playSound('error');
                    finalScannerResultsEl.innerHTML = `<div class="text-center w-full"><p class="font-bold text-red-600">SKU Not Found</p><p class="text-sm text-slate-500">${scannedText}</p></div>`;
                }
            }
        });

        // Initialize dev tools protection
        SPViAuth.setupDevToolsProtection();
    </script>
</body>
</html>
